<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chat Games with AI</title>
<style>
:root{
  --neon: #00aa44;
  --neon2: #0077cc;
  --bg: #021205;
  --panel: rgba(0,0,0,0.22);
  --muted: rgba(175,255,185,0.5);
  --text: #caffd1;
  --user: #fff8a3;
  --radius: 10px;
  --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace;
  --ambient-thumb: #9fe6a4;
  --msg-font-size: 15px;
  --msg-font-weight: 600;
}

/* base UI */
html,body{height:100%;margin:0;font-family:var(--mono);background:var(--bg);color:var(--text);-webkit-font-smoothing:antialiased;overflow:hidden}
#app{display:flex;flex-direction:column;height:100vh;}
header{padding:12px 18px;border-bottom:1px solid rgba(0,0,0,0.22);display:flex;align-items:center;justify-content:space-between;background:linear-gradient(180deg, rgba(0,0,0,0.05), transparent)}
.title{font-weight:900;letter-spacing:0.6px}
.header-right{display:flex;gap:12px;align-items:center}
#main{display:flex;flex:1;overflow:hidden}
#left{width:340px;border-right:1px solid rgba(0,0,0,0.18);padding:14px;box-sizing:border-box;background:linear-gradient(180deg, rgba(0,0,0,0.04), transparent)}
.card{background:var(--panel);border-radius:12px;padding:10px;border:1px solid rgba(0,0,0,0.12);box-shadow: inset 0 -6px 14px rgba(0,0,0,0.2)}
#chatlist{display:flex;flex-direction:column;gap:8px;overflow:auto;padding:6px 2px;max-height:48vh}
.chat-item{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);cursor:pointer;background:linear-gradient(180deg, rgba(0,0,0,0.02), rgba(0,0,0,0.06))}
.chat-item.active{box-shadow:0 10px 40px rgba(0,255,100,0.04), inset 0 -6px 10px rgba(0,0,0,0.25);border-color:rgba(0,255,120,0.18)}
.chat-left{display:flex;flex-direction:column;align-items:flex-start;gap:6px}
.chat-name{font-weight:700}
.chat-meta{font-size:12px;color:var(--muted)}
.icon-input{padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text);width:100%}
.left-controls{display:flex;gap:8px;margin-top:12px}
.left-controls button{flex:1;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:linear-gradient(180deg, rgba(0,0,0,0.03), rgba(0,0,0,0.06));color:var(--text);cursor:pointer}
#right{flex:1;display:flex;flex-direction:column;gap:12px;padding:12px}
.menu-row{display:flex;align-items:flex-start;gap:12px;justify-content:space-between}
#menu{flex:1;display:flex;flex-wrap:wrap;gap:12px;padding:12px;border-radius:12px;border:1px solid rgba(0,0,0,0.12);background:linear-gradient(180deg, rgba(0,0,0,0.03), rgba(0,0,0,0.06))}
.grid-card{min-width:180px;flex:0 0 200px;border-radius:10px;padding:12px;background:linear-gradient(180deg, rgba(0,0,0,0.02), rgba(0,0,0,0.05));border:1px solid rgba(255,255,255,0.02);cursor:pointer}
.grid-title{font-weight:800}
.grid-sub{font-size:12px;color:var(--muted)}
#terminal{flex:1;padding:18px;overflow:auto;border-radius:12px;border:1px solid rgba(0,0,0,0.08);background:linear-gradient(180deg, rgba(0,0,0,0.02), transparent);display:flex;flex-direction:column;gap:10px;scroll-behavior:smooth}
.message{max-width:78%;padding:12px 14px;border-radius:10px;margin-bottom:8px;word-wrap:break-word;opacity:0;transform:translateY(14px);position:relative;font-size:var(--msg-font-size);font-weight:var(--msg-font-weight)}
.message.enter { animation: msgEnter 360ms cubic-bezier(.2,.9,.3,1) forwards; }
@keyframes msgEnter { 0% { opacity:0; transform:translateY(14px) } 60% { opacity:1; transform:translateY(-4px) } 100% { opacity:1; transform:translateY(0) } }
.msg-system{background:rgba(0,0,0,0.06);border-left:4px solid rgba(0,255,110,0.18);color:var(--text);font-weight:800}
.msg-ai{background:rgba(0,0,0,0.04);border-left:4px solid rgba(105,200,255,0.14);color:var(--neon2);font-weight:700}
.msg-user{background:rgba(0,0,0,0.04);border-left:4px solid rgba(255,215,90,0.12);color:var(--user);align-self:flex-start;font-weight:700}
.msg-ts{position:absolute;right:10px;bottom:6px;font-size:11px;color:var(--muted);opacity:0.9}
.msg-controls{position:absolute;right:8px;top:6px;display:flex;gap:6px}
.msg-controls button{background:transparent;border:0;color:var(--muted);cursor:pointer;font-size:14px;padding:4px}
.edit-row{display:flex;gap:6px;margin-top:8px}
.edit-input{flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text)}
.ai-typing::after{ content: "█"; display:inline-block; margin-left:6px; animation: blinkCursor 600ms steps(1, end) infinite; color: var(--neon); font-weight:900; }
@keyframes blinkCursor { 0% { opacity: 1 } 50% { opacity: 0 } 100% { opacity: 1 } }
#inputbar{display:flex;gap:12px;padding:12px;border-radius:10px;border:1px solid rgba(0,0,0,0.08);background:linear-gradient(180deg, rgba(0,0,0,0.02), transparent)}
#input{flex:1;padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);background:#031403;color:var(--text);outline:none;font-size:15px;z-index:2}
#sendBtn{padding:12px 16px;border-radius:10px;background:linear-gradient(180deg,#003a12,#012207);color:var(--text);border:1px solid rgba(0,0,0,0.12);cursor:pointer}
#progressWrap{position:fixed;left:50%;top:12px;transform:translateX(-50%);min-width:420px;background:rgba(0,0,0,0.6);border:1px solid rgba(0,255,120,0.06);padding:10px;border-radius:10px;display:none;z-index:140}
#progressBarOuter{height:12px;background:#001200;border-radius:8px;overflow:hidden}
#progressBar{width:0%;height:100%;background:linear-gradient(90deg,#06f,#0f6);}
#themeSwitcher{position:fixed;right:14px;top:12px;display:flex;flex-direction:column;gap:8px;z-index:160;align-items:center}
.themebtn{width:56px;height:56px;border-radius:12px;background:linear-gradient(180deg, rgba(0,0,0,0.04), transparent);border:1px solid rgba(255,255,255,0.03);color:var(--text);font-size:20px;cursor:pointer;display:flex;align-items:center;justify-content:center}
.icon-btn{background:transparent;border:1px solid rgba(255,255,255,0.02);padding:8px;border-radius:8px;color:var(--text);cursor:pointer}
#crtToggle{font-size:13px;padding:8px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.03);color:var(--text);cursor:pointer}
.ambient-controls{display:flex;flex-direction:column;gap:6px;align-items:center}
.ambient-controls input[type="range"]{width:88px;accent-color:var(--ambient-thumb);}
.crt-overlay{pointer-events:none;position:fixed;inset:0;z-index:120}
.scanlines{position:absolute;inset:0;background-image:repeating-linear-gradient(to bottom, rgba(0,255,110,0.14) 0px, rgba(0,255,110,0.14) 3px, transparent 3px, transparent 6px);opacity:0.9;mix-blend-mode:overlay;background-size:100% 6px;animation:moveScan 6s linear infinite}
@keyframes moveScan { 0% { background-position:0 0 } 100% { background-position:0 48px } }
.gridlines{position:absolute;inset:0;background-image:linear-gradient(90deg, rgba(0,255,110,0.04) 1px, transparent 1px), linear-gradient(rgba(0,255,110,0.04) 1px, transparent 1px);background-size:200px 200px;opacity:0.12;animation:shiftGrid 18s linear infinite}
@keyframes shiftGrid { 0% { background-position:0 0, 0 0 } 50% { background-position:-60px -30px, 40px 20px } 100% { background-position:0 0, 0 0 } }
.vignette{position:absolute;inset:0;background:radial-gradient(ellipse at center, rgba(0,0,0,0) 35%, rgba(0,0,0,0.6) 80%)}
.sweep{position:absolute;left:-60%;top:0;width:40%;height:100%;background:linear-gradient(90deg, rgba(255,255,255,0.06), rgba(255,255,255,0.26), rgba(255,255,255,0.06));transform:skewX(-16deg);opacity:0.08;animation:sweep 6s linear infinite}
@keyframes sweep {0%{left:-60%}50%{left:120%}100%{left:120%}}
#toast{position:fixed;bottom:18px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.7);padding:10px 14px;border-radius:8px;color:var(--text);border:1px solid rgba(0,255,120,0.06);display:none;z-index:200}
#toast .undo{color:var(--neon);text-decoration:underline;cursor:pointer;margin-left:10px}
.small{font-size:12px;color:var(--muted)}
.kv{font-size:12px;color:var(--muted);display:block;margin-top:6px}
body.hacker{ background: linear-gradient(180deg,#041403,#021205 70%); color:var(--text); }
body.dark{ background:#08101a; color:#dfeaff }

/* Light mode high-contrast overrides (improved readability) */
body.light{
  --bg: #ffffff;
  --panel: #ffffff;
  --muted: #4a5560;
  --text: #0b1720;
  --user: #0b3a2b;
  --neon: #007a33;
  --neon2: #005fa8;
  background: var(--bg);
  color: var(--text);
}
body.light .card{ background: #fff; border: 1px solid rgba(12,18,22,0.06); box-shadow: 0 4px 14px rgba(10,20,30,0.04); }
body.light #input{ background:#fff;color:var(--text);border:1px solid rgba(12,18,22,0.06) }
body.light .grid-card, body.light .chat-item{ border-color: rgba(10,20,30,0.06); color:var(--text) }
body.light .msg-system{ background:#f3f7f3; color:var(--text); border-left:4px solid rgba(0,150,60,0.12); font-weight:800}
body.light .msg-ai{ background:#eef6ff; color:#053a68; border-left:4px solid rgba(0,120,220,0.18); font-weight:700 }
body.light .msg-user{ background:#f0fbf5; color:#064028; border-left:4px solid rgba(0,130,90,0.14); font-weight:700 }
body.light #crtOverlay{ display:none } /* optional: hide CRT in light by default */

/* Consent modal */
#consentModal{
  position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:300;
  background:rgba(255,255,255,0.98);border-radius:12px;padding:18px;border:1px solid rgba(10,20,30,0.08);width:640px;max-width:96%;
  display:none; box-shadow: 0 10px 40px rgba(0,0,0,0.12);
}
#consentModal h3{margin:0 0 8px 0;color:var(--text)}
#consentModal p{margin:6px 0;color:var(--muted);font-size:13px}
#consentModal .row{display:flex;justify-content:flex-end;margin-top:12px;gap:8px}
.btn-ghost{background:transparent;border:1px solid rgba(10,20,30,0.06);padding:8px 12px;border-radius:8px;color:var(--text);cursor:pointer}
.btn-primary{background:linear-gradient(90deg,#007b34,#00aa55);border:0;padding:8px 12px;border-radius:8px;color:#022;border-radius:8px;cursor:pointer}

/* Blob-status modal */
#blobStatusModal{
  position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:400;
  background:var(--panel);border-radius:12px;padding:14px;border:1px solid rgba(0,0,0,0.12);width:740px;max-width:96%;
  display:none; color:var(--text); box-shadow: 0 16px 60px rgba(0,0,0,0.45);
}
#blobStatusModal h4{margin:0 0 8px 0}
.blob-list{max-height:360px;overflow:auto;padding:6px;border-radius:8px;background:rgba(0,0,0,0.03)}
.blob-item{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:8px;border-bottom:1px solid rgba(255,255,255,0.03)}
.blob-item .meta{font-size:13px;color:var(--muted);max-width:56%}
.blob-actions{display:flex;gap:8px;align-items:center}
.blob-actions button{padding:6px 8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text);cursor:pointer}

/* file input style hidden */
.file-input{display:none}

@media (max-width:900px){ #left{display:none} }
</style>
</head>
<body>

<div id="app">
  <header>
    <div style="display:flex;align-items:center;gap:14px">
      <div class="title">Chat Games with AI</div>
      <button id="headerFreeChat" class="icon-btn" title="Open Free Chat">Free Chat</button>
    </div>
    <div class="header-right">
      <div class="small">AI (local) • credit: Ollama</div>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="btnExport" class="icon-btn">Export</button>
        <button id="btnImport" class="icon-btn">Import</button>
      </div>
    </div>
  </header>

  <div id="main">
    <div id="left">
      <div class="card">
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
          <div style="font-weight:800">Chats</div>
          <div class="small">Inline rename • Undo delete</div>
        </div>
        <div id="chatlist"></div>
        <div class="left-controls" style="margin-top:12px">
          <button id="btnNew" class="left-btn">+ New</button>
          <button id="btnClearFlag" class="left-btn">Clear Flag</button>
          <button id="btnExportLeft" class="left-btn">Export</button>
        </div>
      </div>

      <div style="height:12px"></div>

      <div class="card" style="margin-top:12px">
        <div style="display:flex;align-items:center;justify-content:space-between">
          <div style="font-weight:800">Free Chat & Model (UI)</div>
          <div class="small">placeholders + runtime</div>
        </div>
        <div style="margin-top:10px;display:flex;gap:8px;align-items:center">
          <button id="btnFreeChat" class="icon-btn">Free Chat</button>
          <button id="btnDownload" class="icon-btn">Simulate DL</button>
          <button id="btnPlace" class="icon-btn">Placeholders</button>
        </div>

        <!-- model/runtime controls -->
        <div style="margin-top:10px;display:flex;gap:8px;align-items:center">
          <button id="btnInstallRuntime" class="icon-btn" title="Load a local runtime from ./vendor/">Install Runtime</button>
          <button id="btnDownloadModel" class="icon-btn" title="Fetch manifest & blobs and store to IndexedDB">Download Model</button>
          <button id="btnLoadModel" class="icon-btn" title="Load model into runtime from IndexedDB">Load Model</button>
          <button id="btnDeleteModel" class="icon-btn" title="Remove stored model from browser">Delete Model</button>
        </div>

        <div style="margin-top:10px" class="small">Copy manifest / blobs to clipboard for later server-side download</div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="copyManifest" class="icon-btn">Copy Manifest</button>
          <button id="copyBlobs" class="icon-btn">Copy Blobs</button>
        </div>

        <div style="margin-top:10px" id="runtimeStatus" class="small">Runtime: <span id="runtimeLabel">not installed</span></div>
        <div style="margin-top:6px" id="modelStatus" class="small">Model: <span id="modelLabel">not loaded</span></div>

      </div>

      <div style="height:12px"></div>

      <div class="card" style="margin-top:12px">
        <div style="display:flex;align-items:center;justify-content:space-between">
          <div style="font-weight:800">Ambient</div>
          <div class="small">Hacker soundscape</div>
        </div>
        <div style="margin-top:8px;display:flex;align-items:center;gap:8px">
          <button id="ambientToggle" class="icon-btn">Play</button>
          <div class="ambient-controls">
            <input id="ambientVol" type="range" min="0" max="1" step="0.01" value="0.06">
            <div class="small">Volume</div>
          </div>
        </div>
        <div style="margin-top:8px" class="small">Press 'k' to toggle keystroke sounds.</div>
      </div>

    </div>

    <div id="right">
      <div class="menu-row">
        <div id="menu" class="card"></div>
        <div style="width:180px;display:flex;flex-direction:column;gap:10px">
          <div class="card" style="display:flex;flex-direction:column;gap:8px;align-items:center;justify-content:center">
            <div style="font-weight:700">Actions</div>
            <button id="btnExport2" class="icon-btn">Export</button>
            <button id="btnImport2" class="icon-btn">Import</button>
            <div style="height:6px"></div>
            <button id="themeBtn" class="themebtn">🧑‍💻</button>
            <button id="crtToggle" class="icon-btn">CRT ON</button>
          </div>
          <div class="card small">Tip: This is a UI prototype; it accepts a real model loader later (server-side blobs + wasm).</div>
        </div>
      </div>

      <div id="terminal" class="card" aria-live="polite"></div>

      <div id="inputbar">
        <input id="input" placeholder="Type — e.g. cast / explore / help / simulate download" autocomplete="off" />
        <button id="sendBtn">Send</button>
      </div>
    </div>
  </div>
</div>

<!-- CRT overlay -->
<div class="crt-overlay" id="crtOverlay">
  <div class="scanlines"></div>
  <div class="gridlines"></div>
  <div class="vignette"></div>
  <div class="sweep"></div>
</div>

<!-- consent modal -->
<div id="consentModal" role="dialog" aria-modal="true" aria-labelledby="consentTitle">
  <h3 id="consentTitle">Download large model?</h3>
  <p id="consentBody">The model is large and will be downloaded to your browser and stored locally (IndexedDB). This may use multiple gigabytes of storage and could cause a browser prompt. Estimated size: <strong id="consentSize">~3–6 GB</strong>.</p>
  <p class="small">Ensure you want this. The download will not start automatically — it only runs after you confirm and storage is available. You can delete the model later with "Delete Model".</p>
  <div class="row">
    <button id="consentCancel" class="btn-ghost">Cancel</button>
    <button id="consentOk" class="btn-primary">Download & Store</button>
  </div>
</div>

<!-- blob status modal -->
<div id="blobStatusModal" aria-hidden="true">
  <h4>Blob download failures — fix or upload replacements</h4>
  <div class="small" style="margin-bottom:8px">Some blob URLs failed (404 / network). You can retry, paste an alternate URL, or upload a local file to satisfy the missing blob.</div>
  <div class="blob-list" id="blobList"></div>
  <div style="display:flex;justify-content:flex-end;margin-top:12px;gap:8px">
    <button id="closeBlobModal" class="btn-ghost">Close</button>
  </div>
  <!-- hidden file input used for upload -->
  <input id="blobFileInput" class="file-input" type="file" multiple />
</div>

<!-- progress -->
<div id="progressWrap">
  <div style="font-size:13px;color:var(--muted)" id="progressTitle">Model download</div>
  <div id="progressBarOuter" style="margin-top:8px">
    <div id="progressBar"></div>
  </div>
  <div id="progressText" class="small" style="margin-top:6px;color:var(--muted)">0%</div>
</div>

<!-- toast -->
<div id="toast"></div>

<script>
/*
  Fixes:
   - improved readability in light mode
   - robust blob handling: detect failed downloads, present modal to retry/paste/upload replacements
   - preserves previous behavior: runtime and model only loaded after user clicks buttons
*/

/* ---------- constants and placeholders ---------- */
const CHATS_KEY = "chatgames_chats";
const SETTINGS_KEY = "chatgames_settings";
const DUMMY_MANIFEST = "https://registry.ollama.ai/v2/library/llama3.2/manifests/latest";
const DUMMY_BLOBS = [
  "https://registry.ollama.ai/v2/library/llama3.2/blobs/sha256:34bb5ab01051a11372a91f95f3fbbc51173eed8e7f13ec395b9ae9b8bd0e242b",
  "https://registry.ollama.ai/v2/library/llama3.2/blobs/sha256:dde5aa3fc5ffc17176b5e8bdc82f587b24b2678c6c66101bf7da77af9f7ccdff",
  "https://registry.ollama.ai/v2/library/llama3.2/blobs/sha256:966de95ca8a62200913e3f8bfbf84c8494536f1b94b49166851e76644e966396",
  "https://registry.ollama.ai/v2/library/llama3.2/blobs/sha256:fcc5a6bec9daf9b561a68827b67ab6088e1dba9d1fa2a50d7bbcc8384e0a265d",
  "https://registry.ollama.ai/v2/library/llama3.2/blobs/sha256:a70ff7e570d97baaf4e62ac6e6ad9975e04caa6d900d3742d37698494479e0cd",
  "https://registry.ollama.ai/v2/library/llama3.2/blobs/sha256:56bb8bd477a519ffa694fc449c2413c6f0e1d3b1c88fa7e3c9d88d3ae49d4dcb"
];

/* ---------- app state ---------- */
let chats = JSON.parse(localStorage.getItem(CHATS_KEY) || "null");
if(!Array.isArray(chats) || chats.length === 0){
  chats = [{
    name: "Chat 1",
    messages: [{ role:"system", msg:"Welcome. Use Free Chat or select a game. Simulated model download available.", ts: new Date().toISOString() }],
    gameState: null
  }];
  localStorage.setItem(CHATS_KEY, JSON.stringify(chats));
}
let active = 0;
let settings = JSON.parse(localStorage.getItem(SETTINGS_KEY) || "null");
if(!settings) settings = { theme: "hacker", crt: true, keystroke: true, ambientOn: false, ambientVol: 0.06 }, localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));

/* ---------- DOM refs ---------- */
const chatlistEl = document.getElementById("chatlist");
const menuEl = document.getElementById("menu");
const terminalEl = document.getElementById("terminal");
const inputEl = document.getElementById("input");
const sendBtn = document.getElementById("sendBtn");
const toastEl = document.getElementById("toast");
const progressWrap = document.getElementById("progressWrap");
const progressBar = document.getElementById("progressBar");
const progressText = document.getElementById("progressText");
const progressTitle = document.getElementById("progressTitle");
const runtimeLabel = document.getElementById("runtimeLabel");
const modelLabel = document.getElementById("modelLabel");
const btnInstall = document.getElementById("btnInstallRuntime");
const btnDownloadModel = document.getElementById("btnDownloadModel");
const btnLoadModel = document.getElementById("btnLoadModel");
const btnDeleteModel = document.getElementById("btnDeleteModel");
const consentModal = document.getElementById("consentModal");
const consentOk = document.getElementById("consentOk");
const consentCancel = document.getElementById("consentCancel");
const consentSize = document.getElementById("consentSize");
const blobStatusModal = document.getElementById("blobStatusModal");
const blobListEl = document.getElementById("blobList");
const closeBlobModalBtn = document.getElementById("closeBlobModal");
const blobFileInput = document.getElementById("blobFileInput");

/* ---------- IndexedDB helpers ---------- */
function openDB(){
  return new Promise((resolve, reject) => {
    const r = indexedDB.open("chatgames-models", 1);
    r.onupgradeneeded = ()=> {
      const db = r.result;
      if(!db.objectStoreNames.contains("blobs")) db.createObjectStore("blobs");
    };
    r.onsuccess = ()=> resolve(r.result);
    r.onerror = ()=> reject(r.error);
  });
}
async function idbPut(key, value){
  const db = await openDB();
  return new Promise((res, rej)=> {
    const tx = db.transaction("blobs", "readwrite");
    const s = tx.objectStore("blobs");
    const req = s.put(value, key);
    req.onsuccess = ()=> { res(true); db.close(); };
    req.onerror = ()=> { rej(req.error); db.close(); };
  });
}
async function idbGet(key){
  const db = await openDB();
  return new Promise((res, rej)=> {
    const tx = db.transaction("blobs", "readonly");
    const s = tx.objectStore("blobs");
    const req = s.get(key);
    req.onsuccess = ()=> { res(req.result); db.close(); };
    req.onerror = ()=> { rej(req.error); db.close(); };
  });
}
async function idbGetAllKeys(){
  const db = await openDB();
  return new Promise((res, rej) => {
    const tx = db.transaction("blobs", "readonly");
    const s = tx.objectStore("blobs");
    const req = s.getAllKeys();
    req.onsuccess = ()=> { res(req.result); db.close(); };
    req.onerror = ()=> { rej(req.error); db.close(); };
  });
}
async function idbDeleteDatabase(){
  return new Promise((res, rej) => {
    try {
      const req = indexedDB.deleteDatabase("chatgames-models");
      req.onsuccess = ()=> res(true);
      req.onerror = ()=> rej(req.error);
      req.onblocked = ()=> console.warn("delete blocked");
    } catch(e){ rej(e); }
  });
}

/* ---------- runtime placeholders ---------- */
let runtime = null;
let modelLoaded = false;

/* Try to import runtime only when requested */
async function installRuntime(){
  logToTerminal("System: attempting runtime import from ./vendor/ ...");
  runtimeLabel.textContent = "installing...";
  const candidates = [
    "./vendor/wllama.esm.min.js",
    "./vendor/wllama.mjs",
    "./vendor/llama-cpp-wasm.mjs",
    "./vendor/llama-cpp-wasm.js"
  ];
  for(const p of candidates){
    try {
      const mod = await import(p);
      runtime = mod;
      runtimeLabel.textContent = "runtime installed (" + p.split("/").pop() + ")";
      logToTerminal("System: runtime imported: " + p.split("/").pop());
      detectRuntimeAPI(mod);
      return true;
    } catch(e){
      console.warn("import failed", p, e);
    }
  }
  runtimeLabel.textContent = "not installed";
  logToTerminal("System: runtime import failed. Host a runtime bundle in ./vendor/ and try again.");
  return false;
}
function detectRuntimeAPI(mod){
  if(mod?.Wllama || mod?.default?.Wllama) runtime.clientType = "wllama";
  else if(mod?.LlamaCpp || mod?.default?.LlamaCpp || mod?.Llama) runtime.clientType = "llama-cpp-wasm";
  else runtime.clientType = "unknown";
  console.log("runtime.clientType", runtime.clientType, runtime);
}

/* ---------- consent + storage estimate ---------- */
function showConsentModal(sizeHintText = "~3–6 GB") {
  return new Promise((resolve) => {
    consentSize.textContent = sizeHintText;
    consentModal.style.display = "block";
    function cleanup(){ consentModal.style.display = "none"; consentOk.removeEventListener("click", okHandler); consentCancel.removeEventListener("click", cancelHandler); }
    function okHandler(){ cleanup(); resolve(true); }
    function cancelHandler(){ cleanup(); resolve(false); }
    consentOk.addEventListener("click", okHandler);
    consentCancel.addEventListener("click", cancelHandler);
  });
}
async function checkStorageEstimate(minBytesNeeded){
  if(!navigator.storage || !navigator.storage.estimate) return true;
  try {
    const estimate = await navigator.storage.estimate();
    const quota = estimate.quota || 0;
    const usage = estimate.usage || 0;
    const free = quota - usage;
    console.log('Storage estimate', {quota, usage, free});
    if(quota === 0) return true;
    return free >= minBytesNeeded;
  } catch(e){
    console.warn('Storage estimate failed', e);
    return true;
  }
}

/* ---------- robust streaming download with failure tracking ---------- */

/*
  downloadManifestAndBlobs now:
   - attempts to fetch each blob
   - if any blob fetch fails (non-ok), it records it to failed[] and shows blob-status modal
   - user can retry, paste alternative url, or upload a local file that will be stored under the expected key name
*/
async function downloadManifestAndBlobs(manifestUrl = null, blobUrls = []) {
  logToTerminal("System: starting manifest+blob download...");
  progressWrap.style.display = "block";
  progressBar.style.width = '0%';
  progressText.innerText = '0%';
  progressTitle.textContent = 'Model download (storing to browser)';
  const failed = []; // { url, name, reason }
  try {
    if(manifestUrl){
      try {
        const r = await fetch(manifestUrl);
        if(r.ok){
          const txt = await r.text();
          await idbPut('model:manifest', txt);
          logToTerminal("System: manifest saved");
        } else {
          logToTerminal("System: manifest fetch failed: " + r.status);
        }
      } catch(e){
        console.warn("manifest fetch error", e);
      }
    }

    const total = blobUrls.length;
    for(let i=0;i<blobUrls.length;i++){
      const url = blobUrls[i];
      const fname = url.split("/").pop();
      try {
        // Try a light HEAD first to detect obvious 404 quickly (some servers block HEAD; fallback to GET)
        let ok = false;
        try {
          const h = await fetch(url, { method: 'HEAD' });
          ok = h.ok;
        } catch(e){ ok = false; }
        if(!ok){
          // fallback to GET for checking; we'll stream-get below anyway
        }
        const resp = await fetch(url);
        if(!resp.ok){
          failed.push({ url, name: fname, reason: `HTTP ${resp.status}` });
          console.warn("blob fetch failed", fname, resp.status);
          continue;
        }
        // stream into IDB (like before)
        const contentLength = parseInt(resp.headers.get("content-length") || "0", 10);
        if(resp.body && resp.body.getReader){
          const reader = resp.body.getReader();
          const chunks = [];
          let received = 0;
          while(true){
            const { done, value } = await reader.read();
            if(done) break;
            chunks.push(value);
            received += value.byteLength || 0;
            let curFraction = total ? (i + (contentLength ? (received/contentLength) : 0)) / total : 0;
            curFraction = Math.min(1, Math.max(0, curFraction));
            const pct = Math.round(curFraction * 100);
            progressBar.style.width = pct + '%';
            progressText.innerText = `${pct}% - ${fname}`;
          }
          const size = chunks.reduce((s,c)=>s+(c.byteLength||0), 0);
          const buf = new Uint8Array(size);
          let off = 0;
          for(const c of chunks){ buf.set(new Uint8Array(c), off); off += c.byteLength || 0; }
          await idbPut('blob:' + fname, buf.buffer);
          logToTerminal(`System: saved ${fname}`);
        } else {
          const ab = await resp.arrayBuffer();
          await idbPut('blob:' + fname, ab);
          const pct = Math.round(((i+1)/total)*100);
          progressBar.style.width = pct + '%';
          progressText.innerText = `${pct}% - ${fname}`;
          logToTerminal(`System: saved ${fname} (non-stream)`);
        }
      } catch(e){
        console.error("download error for", url, e);
        failed.push({ url, name: fname, reason: e.message || 'network error' });
      }
    }

    progressWrap.style.display = "none";
    if(failed.length){
      modelLabel.textContent = "downloaded (partial, failed blobs)";
      // show modal listing failed blobs and give user options
      showBlobStatusModal(failed);
      logToTerminal("System: download finished with failures — see modal or console.");
      return { success: false, failed };
    } else {
      modelLabel.textContent = "downloaded (in IndexedDB)";
      logToTerminal("System: all blobs saved to IndexedDB.");
      return { success: true };
    }
  } catch(e){
    console.error("downloadManifestAndBlobs error", e);
    progressWrap.style.display = "none";
    logToTerminal("System: download process failed: " + (e.message || e));
    return { success: false, error: e };
  }
}

/* ---------- blob-status modal UI & actions ---------- */
function showBlobStatusModal(failed) {
  blobListEl.innerHTML = "";
  // Each failed blob row: name, reason, actions: Retry, Paste URL, Upload file
  failed.forEach((b, idx) => {
    const row = document.createElement("div");
    row.className = "blob-item";
    const left = document.createElement("div");
    const title = document.createElement("div"); title.textContent = b.name; title.style.fontWeight = 700;
    const meta = document.createElement("div"); meta.className = "meta"; meta.textContent = `${b.reason} — ${b.url}`;
    left.appendChild(title);
    left.appendChild(meta);

    const actions = document.createElement("div"); actions.className = "blob-actions";
    const retryBtn = document.createElement("button"); retryBtn.textContent = "Retry"; retryBtn.onclick = async ()=>{
      retryBtn.disabled = true; retryBtn.textContent = "Retrying...";
      const result = await attemptSingleBlobDownload(b.url);
      if(result.ok){
        showToast(`Downloaded ${b.name}`);
        row.remove();
      } else {
        showToast(`Retry failed: ${result.reason}`);
        retryBtn.disabled = false;
        retryBtn.textContent = "Retry";
      }
    };
    const pasteBtn = document.createElement("button"); pasteBtn.textContent = "Paste URL"; pasteBtn.onclick = async ()=>{
      const altUrl = prompt("Paste alternate URL for " + b.name, b.url);
      if(!altUrl) return;
      pasteBtn.disabled = true; pasteBtn.textContent = "Trying...";
      const r = await attemptSingleBlobDownload(altUrl, b.name);
      if(r.ok){
        showToast(`Downloaded ${b.name} from alternate URL`);
        row.remove();
      } else {
        showToast(`Alternate URL failed: ${r.reason}`);
        pasteBtn.disabled = false; pasteBtn.textContent = "Paste URL";
      }
    };
    const uploadBtn = document.createElement("button"); uploadBtn.textContent = "Upload File"; uploadBtn.onclick = async ()=>{
      // trigger hidden file input; when files chosen, store file bytes under blob:<name>
      blobFileInput.dataset.targetName = b.name;
      blobFileInput.click();
    };

    actions.appendChild(retryBtn);
    actions.appendChild(pasteBtn);
    actions.appendChild(uploadBtn);
    row.appendChild(left);
    row.appendChild(actions);
    blobListEl.appendChild(row);
  });

  // open modal
  blobStatusModal.style.display = "block";
}

/* file input handler: when user selects files to upload as replacement for failed blob(s) */
blobFileInput.addEventListener("change", async (ev) => {
  const files = Array.from(ev.target.files || []);
  const targetName = ev.target.dataset.targetName;
  if(files.length === 0) return;
  for(const f of files){
    const nameToUse = targetName || f.name;
    try {
      const ab = await f.arrayBuffer();
      await idbPut('blob:' + nameToUse, ab);
      showToast(`Uploaded ${nameToUse} and stored locally`);
      logToTerminal("System: user uploaded file saved as blob:" + nameToUse);
      // remove corresponding row from modal if exists
      const rows = Array.from(blobListEl.querySelectorAll(".blob-item"));
      rows.forEach(r=>{
        if(r.querySelector("div").textContent === nameToUse) r.remove();
      });
    } catch(e){
      console.error("file upload error", e);
      showToast("Upload failed");
    }
  }
  ev.target.value = ""; ev.target.dataset.targetName = "";
});

closeBlobModalBtn.addEventListener("click", ()=>{ blobStatusModal.style.display = "none"; });

/* attempt single blob download (returns { ok: boolean, reason? }) */
async function attemptSingleBlobDownload(url, overrideName){
  try {
    const fname = overrideName || url.split("/").pop();
    const resp = await fetch(url);
    if(!resp.ok) return { ok:false, reason: "HTTP " + resp.status };
    const ab = await resp.arrayBuffer();
    await idbPut('blob:' + fname, ab);
    return { ok:true };
  } catch(e){
    return { ok:false, reason: e.message || 'network error' };
  }
}

/* ---------- Load model from IndexedDB into runtime (improved) ---------- */
async function getStoredBlobFiles(){
  const keys = await idbGetAllKeys();
  const blobKeys = (keys || []).filter(k => typeof k === 'string' && k.startsWith('blob:'));
  blobKeys.sort();
  const files = [];
  for(const k of blobKeys){
    const data = await idbGet(k);
    if(!data) continue;
    const name = k.replace(/^blob:/, '');
    const blob = new Blob([data], { type: 'application/octet-stream' });
    try {
      const file = new File([blob], name, { type: 'application/octet-stream' });
      files.push(file);
    } catch(e){
      blob._fname = name;
      files.push(blob);
    }
  }
  return { files, keys: blobKeys };
}

async function loadModelFromIndexedDB(modelName = "llama3.2"){
  if(!runtime){ logToTerminal("System: runtime not installed. Press 'Install Runtime' first."); return false; }
  modelLabel.textContent = "loading...";
  logToTerminal("System: attempting to load model into runtime...");
  try {
    const { files } = await getStoredBlobFiles();
    if(files.length === 0){ logToTerminal("System: no blobs in IndexedDB. Download model first or upload files."); modelLabel.textContent = "no blobs"; return false; }

    if(runtime?.Wllama || runtime.clientType === "wllama"){
      const Wll = runtime.Wllama || runtime.default?.Wllama || runtime.default || runtime;
      if(typeof Wll.loadModelFromFiles === "function"){
        logToTerminal("System: calling Wllama.loadModelFromFiles...");
        const client = await Wll.loadModelFromFiles(files);
        runtime.client = client;
        modelLoaded = true;
        modelLabel.textContent = "loaded (wllama)";
        logToTerminal("System: model loaded into wllama runtime.");
        return true;
      }
    }

    if(typeof runtime.loadFiles === "function"){
      logToTerminal("System: calling runtime.loadFiles...");
      await runtime.loadFiles(files);
      runtime.client = runtime;
      modelLoaded = true;
      modelLabel.textContent = "loaded";
      logToTerminal("System: model loaded via runtime.loadFiles.");
      return true;
    }

    if(runtime.clientType === "llama-cpp-wasm" || runtime.LlamaCpp || runtime.default?.LlamaCpp){
      const LlamaConstructor = runtime.LlamaCpp || runtime.default?.LlamaCpp || runtime.Llama;
      if(typeof LlamaConstructor === "function"){
        if(files.length === 1){
          const blob = files[0];
          const url = URL.createObjectURL(blob);
          logToTerminal("System: invoking LlamaCpp with blob object URL (single file)...");
          const onLoad = ()=>{ modelLoaded = true; modelLabel.textContent = "loaded (llama-cpp-wasm)"; logToTerminal("System: model loaded."); };
          const onChunk = (txt)=>{ appendRuntimeChunk(txt); };
          const onComplete = ()=>{ logToTerminal("System: generation complete."); };
          try {
            const app = new LlamaConstructor(url, onLoad, onChunk, onComplete);
            runtime.client = app;
            return true;
          } catch(err){
            console.error("Llama constructor failed", err);
            logToTerminal("System: Llama constructor failed (see console).");
            modelLabel.textContent = "load failed";
            return false;
          }
        } else {
          logToTerminal("System: multiple blob files present; LlamaCpp usually expects a single .gguf file URL. Consider combining or hosting the model on your site.");
          modelLabel.textContent = "multiple blobs stored";
          return false;
        }
      }
    }

    logToTerminal("System: runtime API not recognized for loading files. See console.");
    console.log("Runtime exports:", runtime);
    modelLabel.textContent = "unknown runtime API";
    return false;

  } catch(e){
    console.error("loadModelFromIndexedDB error", e);
    logToTerminal("System: error while loading model: " + (e.message || e));
    modelLabel.textContent = "load error";
    return false;
  }
}

/* ---------- runtime text streaming hook ---------- */
function appendRuntimeChunk(text){
  chats[active].messages.push({ role: "ai", msg: text, ts: new Date().toISOString() });
  persist();
}
async function sendToRuntime(prompt){
  if(!runtime || !modelLoaded || !runtime.client){ logToTerminal("System: model/runtime not ready — fallback."); return null; }
  try {
    if(runtime.clientType === "wllama" && typeof runtime.client.generate === "function"){
      logToTerminal("System: generating via wllama.generate...");
      const out = await runtime.client.generate(prompt, { max_tokens: 256 });
      return out;
    }
    if(runtime.clientType === "llama-cpp-wasm" && typeof runtime.client.run === "function"){
      logToTerminal("System: generating via LlamaCpp.run (streaming)...");
      runtime.client.run({ prompt, n_predict: 128 });
      return ""; // streaming handled by callbacks
    }
    if(typeof runtime.client.generate === "function"){
      return await runtime.client.generate(prompt);
    }
    if(typeof runtime.client.complete === "function"){
      return await runtime.client.complete(prompt);
    }
    logToTerminal("System: runtime client lacks known generate API; see console.");
    console.log("runtime.client:", runtime.client);
    return null;
  } catch(e){
    console.error("sendToRuntime error", e);
    logToTerminal("System: runtime gen error: " + (e.message || e));
    return null;
  }
}

/* ---------- UI, chat, audio, themes, etc. ---------- */
function logToTerminal(msg){
  chats[active].messages.push({ role: "system", msg, ts: new Date().toISOString() });
  persist();
}
function appendTypingAndCommit(role, text){
  const typingEl = document.createElement("div"); typingEl.className = "message msg-ai ai-typing";
  terminalEl.appendChild(typingEl);
  terminalEl.scrollTo({ top: terminalEl.scrollHeight, behavior: 'smooth' });
  let i = 0;
  const speed = 12;
  return new Promise(res=>{
    const iv = setInterval(()=>{
      if(i < text.length){
        typingEl.textContent = (role === "ai" ? "AI: " : "") + text.slice(0, i+1);
        i++;
        if(settings.keystroke && Math.random() > 0.45) playTypeSound();
        terminalEl.scrollTo({ top: terminalEl.scrollHeight, behavior: 'smooth' });
      } else {
        clearInterval(iv);
        typingEl.classList.remove("ai-typing");
        typingEl.classList.add("enter");
        const ts = new Date().toISOString();
        chats[active].messages.push({ role, msg: text, ts });
        persist(true);
        res();
      }
    }, speed);
  });
}

function renderChatList(){
  chatlistEl.innerHTML = "";
  chats.forEach((c,i)=>{
    const item = document.createElement("div"); item.className = "chat-item" + (i === active ? " active" : "");
    item.onclick = ()=>{ active = i; persist(); };
    const left = document.createElement("div"); left.className = "chat-left";
    const name = document.createElement("div"); name.className = "chat-name"; name.textContent = c.name || `Chat ${i+1}`;
    const nameInput = document.createElement("input"); nameInput.className = "icon-input"; nameInput.style.display = "none"; nameInput.value = c.name || `Chat ${i+1}`;
    nameInput.addEventListener("keydown", (e)=>{ if(e.key === "Enter"){ finishRename(i, nameInput.value); } if(e.key === "Escape"){ nameInput.style.display = 'none'; name.style.display = 'block'; }});
    const meta = document.createElement("div"); meta.className = "chat-meta"; meta.textContent = (c.messages?.length || 0) + " msgs";
    left.appendChild(name); left.appendChild(nameInput); left.appendChild(meta);

    const actions = document.createElement("div"); actions.className = "chat-actions";
    const editBtn = document.createElement("button"); editBtn.className = "icon-btn"; editBtn.title = "Rename"; editBtn.textContent = "✏️";
    editBtn.onclick = (ev)=>{ ev.stopPropagation(); name.style.display='none'; nameInput.style.display='inline-block'; nameInput.focus(); nameInput.select(); };
    const delBtn = document.createElement("button"); delBtn.className = "icon-btn"; delBtn.title = "Delete"; delBtn.textContent = "🗑️";
    delBtn.onclick = (ev)=>{ ev.stopPropagation(); doDelete(i); };
    actions.appendChild(editBtn); actions.appendChild(delBtn);

    item.appendChild(left); item.appendChild(actions);
    chatlistEl.appendChild(item);
  });
}
function finishRename(idx, newName){ if(!newName || typeof newName !== "string") return; chats[idx].name = newName.trim(); persist(); }
function doDelete(idx){ const last = { idx, chat: chats[idx] }; chats.splice(idx,1); if(chats.length === 0) chats.push({ name:"Chat 1", messages:[{role:"system", msg:"Welcome", ts:new Date().toISOString()}], gameState:null }); persist(); showToast("Chat deleted", ()=>{ chats.splice(last.idx,0,last.chat); persist(); showToast("Undo successful"); }); }

const GAMES = [
  "Reel In - Fishing Simulator",
  "Space Explorer",
  "Maze Runner",
  "Treasure Hunt",
  "Farm Life",
  "Cooking Craze",
  "Monster Battle",
  "Puzzle Quest",
  "Word Wizard",
  "Race Track"
];
function renderMenu(){
  menuEl.innerHTML = "";
  GAMES.forEach((g,i)=>{
    const card = document.createElement("div"); card.className = "grid-card";
    card.innerHTML = `<div class="grid-title">${g}</div><div class="grid-sub">Play with AI narration</div>`;
    card.onclick = ()=> startGame(i);
    menuEl.appendChild(card);
  });
  const free = document.createElement("div"); free.className = "grid-card"; free.style.border="2px dashed rgba(255,255,255,0.03)";
  free.innerHTML = `<div class="grid-title">Free Chat</div><div class="grid-sub">Open an unscripted chat</div>`;
  free.onclick = ()=> openFreeChat();
  menuEl.appendChild(free);
}
function renderTerminal(scrollSmooth = true){
  terminalEl.innerHTML = "";
  const msgs = chats[active].messages || [];
  for(let i=0;i<msgs.length;i++){
    const m = msgs[i];
    const div = document.createElement("div"); div.className = "message";
    if(m.role === "system"){ div.classList.add("msg-system"); div.textContent = "System: " + m.msg; }
    else if(m.role === "ai"){ div.classList.add("msg-ai"); div.textContent = "AI: " + m.msg; }
    else { div.classList.add("msg-user"); const content = document.createElement("div"); content.textContent = m.msg; div.appendChild(content); const controls = document.createElement("div"); controls.className = "msg-controls"; const editBtn = document.createElement("button"); editBtn.className = "icon-btn"; editBtn.title = "Edit"; editBtn.innerText = "✏️"; editBtn.onclick = (ev)=>{ ev.stopPropagation(); startEditMessage(i, div, m.msg); }; controls.appendChild(editBtn); div.appendChild(controls); }
    const ts = document.createElement("div"); ts.className = "msg-ts small"; ts.textContent = formatTS(m.ts || new Date().toISOString()) + (m.edited ? " · edited" : "");
    div.appendChild(ts);
    terminalEl.appendChild(div);
    requestAnimationFrame(()=>{ div.classList.add("enter"); });
  }
  if(scrollSmooth) terminalEl.scrollTo({ top: terminalEl.scrollHeight, behavior: 'smooth' }); else terminalEl.scrollTop = terminalEl.scrollHeight;
}
function formatTS(iso){ try { const d = new Date(iso); return d.toLocaleString(); } catch(e){ return iso; } }
function startEditMessage(msgIndex, messageDiv, currentText){ messageDiv.innerHTML = ""; const input = document.createElement("input"); input.className = "edit-input"; input.value = currentText; const saveBtn = document.createElement("button"); saveBtn.className = "icon-btn"; saveBtn.textContent = "Save"; const cancelBtn = document.createElement("button"); cancelBtn.className = "icon-btn"; cancelBtn.textContent = "Cancel"; const row = document.createElement("div"); row.className = "edit-row"; row.appendChild(input); row.appendChild(saveBtn); row.appendChild(cancelBtn); messageDiv.appendChild(row); input.focus(); input.select(); saveBtn.onclick = ()=>{ const val = input.value.trim(); if(val.length === 0) { showToast("Cannot save empty message"); return; } chats[active].messages[msgIndex].msg = val; chats[active].messages[msgIndex].ts = new Date().toISOString(); chats[active].messages[msgIndex].edited = true; persist(); }; cancelBtn.onclick = ()=>{ persist(); }; input.addEventListener("keydown", (e)=>{ if(e.key === "Enter") saveBtn.click(); if(e.key === "Escape") cancelBtn.click(); }); }

/* audio */
let audioCtx = null;
let ambientNode = null;
let ambientRunning = false;
function ensureAudio(){ if(!audioCtx){ try{ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e){ audioCtx = null; } } }
function playKeystroke(volume = 0.06, type = "square", durationMs=18){ if(!settings.keystroke) return; ensureAudio(); if(!audioCtx) return; try { const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type = type; o.frequency.value = 1200 + Math.random()*300; g.gain.value = volume; o.connect(g); g.connect(audioCtx.destination); const now = audioCtx.currentTime; o.start(now); g.gain.setValueAtTime(volume, now); g.gain.exponentialRampToValueAtTime(0.0001, now + durationMs/1000); o.stop(now + durationMs/1000 + 0.02); } catch(e){} }
function playTypeSound(){ playKeystroke(0.04, "sine", 14); }
function startAmbient(vol = 0.06){ ensureAudio(); if(!audioCtx){ showToast("Audio unavailable"); return; } if(ambientRunning) return; if(audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{}); const gain = audioCtx.createGain(); gain.gain.value = vol; gain.connect(audioCtx.destination); const base = audioCtx.createOscillator(); base.type = "sine"; base.frequency.value = 70 + Math.random()*20; const baseGain = audioCtx.createGain(); baseGain.gain.value = 0.6; base.connect(baseGain); baseGain.connect(gain); const top = audioCtx.createOscillator(); top.type = "triangle"; top.frequency.value = 220 + Math.random()*40; const topGain = audioCtx.createGain(); topGain.gain.value = 0.12; top.connect(topGain); topGain.connect(gain); const bufferSize = 2 * audioCtx.sampleRate; const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate); const output = noiseBuffer.getChannelData(0); for (let i = 0; i < bufferSize; i++) output[i] = (Math.random() * 2 - 1) * 0.007; const noise = audioCtx.createBufferSource(); noise.buffer = noiseBuffer; noise.loop = true; const noiseGain = audioCtx.createGain(); noiseGain.gain.value = 0.05; noise.connect(noiseGain); noiseGain.connect(gain); const filter = audioCtx.createBiquadFilter(); filter.type = "bandpass"; filter.frequency.value = 800; filter.Q.value = 0.9; gain.disconnect(); gain.connect(filter); filter.connect(audioCtx.destination); base.start(); top.start(); noise.start(); ambientNode = { base, top, noise, filter, gain }; ambientRunning = true; }
function stopAmbient(){ if(!ambientRunning || !ambientNode) return; try { ambientNode.base.stop(); ambientNode.top.stop(); ambientNode.noise.stop(); } catch(e){} ambientNode = null; ambientRunning = false; }
function setAmbientVolume(v){ if(ambientNode && ambientNode.gain) ambientNode.gain.gain.value = v; }

/* toast */
let toastTimer = null;
function showToast(text, undoCallback){ toastEl.innerHTML = ""; const span = document.createElement("span"); span.textContent = text; toastEl.appendChild(span); if(typeof undoCallback === "function"){ const undo = document.createElement("span"); undo.textContent = "  Undo"; undo.className = "undo"; undo.onclick = ()=>{ undoCallback(); hideToast(); }; toastEl.appendChild(undo); } toastEl.style.display = "block"; if(toastTimer) clearTimeout(toastTimer); toastTimer = setTimeout(()=>{ hideToast(); }, 5000); }
function hideToast(){ toastEl.style.display = "none"; if(toastTimer) clearTimeout(toastTimer); }

/* input handling */
inputEl.addEventListener("keydown", (e)=>{ if(settings.keystroke) playKeystroke(0.06, "square", 14); if(e.key === "Enter"){ e.preventDefault(); sendBtn.click(); } });
sendBtn.addEventListener("click", async ()=>{
  const txt = inputEl.value.trim(); if(!txt) return; inputEl.value = ""; inputEl.focus();
  chats[active].messages.push({ role: "user", msg: txt, ts: new Date().toISOString() });
  persist();
  if(modelLoaded && runtime && runtime.client){
    logToTerminal("System: sending prompt to local model...");
    const result = await sendToRuntime(txt);
    if(typeof result === "string" && result.length){
      await appendTypingAndCommit("ai", result);
    } else {
      if(result === null){
        await appendTypingAndCommit("ai", "Model did not produce output. See console for runtime logs.");
      }
    }
  } else {
    await handleUserCommandFallback(txt);
  }
});

/* fallback commands */
async function handleUserCommandFallback(cmd){
  const lc = cmd.trim().toLowerCase();
  if(lc === "help"){
    chats[active].messages.push({ role:"ai", msg: "Help: click a game or use Free Chat. Type 'simulate download' to see progress UI or 'download model' to try download flow.", ts: new Date().toISOString() });
    persist();
    return;
  }
  if(lc === "simulate download" || lc === "download model"){
    simulateDownload();
    return;
  }
  const gs = chats[active].gameState;
  if(!gs){
    chats[active].messages.push({ role:"ai", msg: "No active game. Click a game to start or use Free Chat.", ts: new Date().toISOString() });
    persist();
    return;
  }
  let reply = "";
  switch(gs.id){
    case 0:
      if(lc === "cast"){ const r=Math.random(); reply = r<0.7 ? "You caught a small sardine (+10 coins)." : (r<0.95? "You caught a medium trout (+50)." : "You pulled a giant tuna (+200)!"); }
      else if(lc === "upgrade") reply = "You upgraded your rod. Catch rate improved.";
      else reply = "Fishing commands: 'cast','upgrade','move'.";
      break;
    default:
      reply = `Command '${cmd}' executed for ${gs.name} (UI fallback).`;
  }
  await appendTypingAndCommit("ai", reply);
}

/* actions and misc UI wiring */
function startGame(idx){ chats[active].gameState = { id: idx, name: GAMES[idx], state: {} }; persist(); menuEl.style.display = "none"; appendTypingAndCommit("ai", `You started "${GAMES[idx]}". ${gamePrompt(idx)}`); }
function gamePrompt(i){ switch(i){ case 0: return "You're on a pier. Commands: 'cast','upgrade','move'."; case 1: return "Pilot your scout: 'explore','scan','jump'."; case 2: return "Maze: 'up','down','left','right','look'."; case 3: return "Treasure: 'dig','scan','map'."; case 4: return "Farm: 'plant','water','harvest','sell'."; case 5: return "Kitchen: 'mix','cook','serve'."; case 6: return "Battle: 'attack','defend','item'."; case 7: return "Puzzle: 'solve','hint'."; case 8: return "Words: 'form [word]','shuffle','hint'."; case 9: return "Race: 'go','brake','boost'."; default: return "Ready."; } }
function openFreeChat(){ chats[active].gameState = null; persist(); appendTypingAndCommit("ai", "Free chat started. Ask me anything."); }

document.getElementById("btnNew").addEventListener("click", ()=>{ chats.push({ name: `Chat ${chats.length+1}`, messages: [{ role:"system", msg:"New chat created.", ts: new Date().toISOString() }], gameState:null }); active = chats.length-1; persist(); setTimeout(()=>inputEl.focus(),80); });
document.getElementById("btnExport").addEventListener("click", ()=>{ const blob = new Blob([JSON.stringify(chats)], { type: "application/json" }); const a = document.createElement("a"); a.href = URL.createObjectURL(blob); a.download = "chatgames_backup.json"; a.click(); showToast("Exported chats"); });
document.getElementById("btnExportLeft").addEventListener("click", ()=>{ const blob = new Blob([JSON.stringify(chats)], { type: "application/json" }); const a = document.createElement("a"); a.href = URL.createObjectURL(blob); a.download = "chatgames_backup.json"; a.click(); showToast("Exported chats"); });
document.getElementById("btnImport").addEventListener("click", importHandler);
document.getElementById("btnImport2").addEventListener("click", importHandler);
function importHandler(){ const fi = document.createElement("input"); fi.type = "file"; fi.accept = ".json"; fi.onchange = async ()=>{ const f = fi.files[0]; if(!f) return; const txt = await f.text(); try{ const imp = JSON.parse(txt); if(!Array.isArray(imp)) throw 0; chats = imp; active = 0; persist(); showToast("Imported chats"); } catch(e){ showToast("Import failed"); } }; fi.click(); }
document.getElementById("btnClearFlag").addEventListener("click", ()=>{ localStorage.removeItem("ollama_model_dummy_downloaded"); showToast("Model flag cleared"); });

document.getElementById("copyManifest").addEventListener("click", async ()=>{ try { await navigator.clipboard.writeText(DUMMY_MANIFEST); showToast("Manifest copied"); } catch(e){ showToast("Clipboard not available"); }});
document.getElementById("copyBlobs").addEventListener("click", async ()=>{ try { await navigator.clipboard.writeText(DUMMY_BLOBS.join("\n")); showToast("Blob URLs copied"); } catch(e){ showToast("Clipboard not available"); }});
document.getElementById("btnPlace").addEventListener("click", ()=>{ chats[active].messages.push({ role:"system", msg:"Placeholder manifest and blobs (copied if clipboard allowed).", ts: new Date().toISOString() }); persist(); showToast("Placeholders appended"); });

document.getElementById("btnDownload").addEventListener("click", simulateDownload);
function simulateDownload(){ progressWrap.style.display = "block"; let p = 0; progressBar.style.width = '0%'; progressText.innerText = '0%'; const iv = setInterval(()=>{ p += Math.random()*0.14; if(p>1)p=1; progressBar.style.width = Math.floor(p*100) + '%'; progressText.innerText = Math.floor(p*100) + '%'; if(p>=1){ clearInterval(iv); setTimeout(()=>{ progressWrap.style.display='none'; localStorage.setItem("ollama_model_dummy_downloaded", "1"); showToast("Simulated model downloaded"); chats[active].messages.push({ role:"system", msg:"Simulated model downloaded (UI-only).", ts: new Date().toISOString() }); persist(); }, 450); } }, 160); }

const THEMES = ["hacker","dark","light"];
function applyTheme(name){ document.body.classList.remove(...THEMES); document.body.classList.add(name); themeBtn.textContent = name === "hacker" ? "🧑‍💻" : (name === "dark" ? "🌕" : "☀️"); settings.theme = name; localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings)); }
themeBtn.addEventListener("click", ()=>{ const cur = settings.theme || "hacker"; const i = THEMES.indexOf(cur); const next = THEMES[(i+1)%THEMES.length]; applyTheme(next); showToast("Theme: "+next); });
function applyCRT(on){ document.getElementById("crtOverlay").style.display = on ? "block" : "none"; document.getElementById("crtToggle").textContent = on ? "CRT ON" : "CRT OFF"; settings.crt = !!on; localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings)); }
document.getElementById("crtToggle").addEventListener("click", ()=>{ settings.crt = !settings.crt; applyCRT(settings.crt); showToast("CRT "+(settings.crt ? "enabled" : "disabled")); });

document.getElementById("ambientToggle").addEventListener("click", ()=>{ ensureAudio(); if(!audioCtx){ showToast("Audio not available"); return; } if(!ambientRunning){ if(audioCtx.state === 'suspended'){ audioCtx.resume().catch(()=>{}); } startAmbient(parseFloat(document.getElementById("ambientVol").value)); document.getElementById("ambientToggle").textContent = "Pause"; settings.ambientOn = true; localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings)); } else { stopAmbient(); document.getElementById("ambientToggle").textContent = "Play"; settings.ambientOn = false; localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings)); }});
document.getElementById("ambientVol").addEventListener("input", ()=>{ const v = parseFloat(document.getElementById("ambientVol").value); settings.ambientVol = v; localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings)); setAmbientVolume(v); });

/* Install runtime / Load model / Delete model handlers */
btnInstall.addEventListener("click", async ()=>{ await installRuntime(); });
btnLoadModel.addEventListener("click", async ()=>{ await loadModelFromIndexedDB("llama3.2"); });
btnDeleteModel.addEventListener("click", async ()=>{ const ok = confirm("Delete stored model data from this browser? This permanently removes locally stored model files."); if(ok){ await idbDeleteDatabase(); modelLabel.textContent = "not loaded"; logToTerminal("System: model storage cleared"); showToast("Model storage cleared"); } });

/* Download Model (consent -> storage check -> streaming download) */
btnDownloadModel.addEventListener("click", async ()=>{
  const consent = await showConsentModal("~3–6 GB (estimate)");
  if(!consent){ showToast("Download cancelled"); return; }
  const okSpace = await checkStorageEstimate(3 * 1024 * 1024 * 1024);
  if(!okSpace){
    const proceed = confirm("Your browser reports limited free storage. Downloading a large model may fail or prompt you. Continue?");
    if(!proceed){ showToast("Download cancelled due to storage"); return; }
  }
  const result = await downloadManifestAndBlobs(DUMMY_MANIFEST, DUMMY_BLOBS);
  if(result.success) showToast("Model downloaded to browser (IndexedDB). Press Load Model.");
  else if(result.failed) showToast("Some blobs failed — please check the modal to retry or upload replacements.");
});

/* Ctrl+F -> Free Chat */
window.addEventListener("keydown", (e)=>{ if(e.ctrlKey && e.key.toLowerCase() === 'f'){ e.preventDefault(); openFreeChat(); showToast("Free Chat opened (Ctrl+F)"); } });
document.getElementById("headerFreeChat").addEventListener("click", ()=>{ openFreeChat(); });

window.addEventListener("keydown", (e)=>{ if(e.key === 'k'){ settings.keystroke = !settings.keystroke; localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings)); showToast("Keystroke sound " + (settings.keystroke ? "on" : "off")); } });

/* persist/render */
function persist(scroll=true){ localStorage.setItem(CHATS_KEY, JSON.stringify(chats)); renderChatList(); renderMenu(); renderTerminal(scroll); }
function init(){ applyTheme(settings.theme || "hacker"); applyCRT(settings.crt !== false); document.getElementById("ambientVol").value = settings.ambientVol || 0.06; document.getElementById("ambientToggle").textContent = settings.ambientOn ? "Pause" : "Play"; renderChatList(); renderMenu(); renderTerminal(false); setTimeout(()=> inputEl.focus(), 140); if(!localStorage.getItem("ollama_model_dummy_downloaded")){ chats[active].messages.push({ role:"system", msg:"Model placeholder not downloaded. Use 'Simulate DL' or Download Model to exercise Model UI.", ts: new Date().toISOString() }); persist(); } }
init();

/* debug helpers */
window._chatgames_runtime = { installRuntime, downloadManifestAndBlobs, loadModelFromIndexedDB, getStoredBlobFiles, idbGetAllKeys, idbGet, idbDeleteDatabase, runtime, chats };

</script>
</body>
</html>
