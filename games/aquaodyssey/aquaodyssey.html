<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Aqua Odyssey</title>
<style>
  :root{--glass:rgba(255,255,255,0.08);--glass-2:rgba(255,255,255,0.06);--accent:#ffd166;--accent-2:#06c8ff;--bg-top:#7ee8fa;--bg-bottom:#123a63;--panel-radius:14px}
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%;width:100%;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;color:#fff;overflow:hidden}
  body{background:linear-gradient(180deg,var(--bg-top),var(--bg-bottom));touch-action:none}
  canvas{display:block;position:fixed;inset:0;width:100vw;height:100vh}
  .hud{position:absolute;left:12px;right:12px;top:12px;display:flex;align-items:center;justify-content:space-between;gap:12px;z-index:60}
  .panel{backdrop-filter:blur(6px);background:var(--glass);padding:10px 12px;border-radius:var(--panel-radius);box-shadow:0 6px 18px rgba(0,0,0,0.25)}
  .title{display:flex;align-items:center;gap:12px}
  .logo{width:44px;height:44px;border-radius:10px;background:linear-gradient(135deg,var(--accent),#ff9a66);display:flex;align-items:center;justify-content:center}
  .app-title{font-weight:700;font-size:18px}
  .username-display{font-size:12px;opacity:0.95}
  .stats{display:flex;gap:10px;align-items:center}
  .stat{font-size:14px;min-width:68px;text-align:center}
  .controls{display:flex;gap:8px;align-items:center}
  .btn{background:var(--glass-2);border-radius:10px;padding:8px 10px;font-weight:600;border:1px solid rgba(255,255,255,0.06);cursor:pointer}
  .side{position:absolute;left:14px;bottom:14px;display:flex;gap:12px;align-items:flex-end;z-index:50}
  .joy{width:120px;height:120px;border-radius:999px;background:linear-gradient(180deg,rgba(255,255,255,0.03),rgba(255,255,255,0.01));display:flex;align-items:center;justify-content:center;position:fixed;left:14px;bottom:14px}
  .stick{width:56px;height:56px;border-radius:999px;background:rgba(255,255,255,0.12);transform:translate(0,0)}
  /* ensure touch controls are usable on devices with safe-area insets */
  .joy{touch-action:none;z-index:120}
  .stick{touch-action:none}
  .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:9999;pointer-events:auto}
  .overlay.hidden{display:none}
  .card{width:100%;max-width:820px;pointer-events:all;position:relative;z-index:10000;background:linear-gradient(180deg,rgba(255,255,255,0.06),rgba(255,255,255,0.03));padding:22px;border-radius:16px;backdrop-filter:blur(6px);text-align:center}
  .card h2{font-size:20px;margin-bottom:8px}
  .primary{background:linear-gradient(90deg,var(--accent),#ff9a66);border-radius:12px;padding:10px 14px;color:#1a1a1a;font-weight:800;cursor:pointer;border:none}
  .secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 12px;border-radius:10px;margin-left:8px}
  .info{max-height:320px;overflow:auto;padding-top:8px;font-size:13px;text-align:left}
  .shop{display:flex;flex-direction:column;gap:8px}
  .shop-row{display:flex;justify-content:space-between;align-items:center;padding:10px;border-radius:10px;background:rgba(255,255,255,0.02)}
  /* responsive shop: stack rows on small screens for larger tap areas */
  @media (max-width:480px){ .shop-row{flex-direction:column;align-items:flex-start;padding:12px} .shop-row .btn{width:100%;margin-top:8px} .shop-row > div:first-child{width:100%} }
  .controls-bottom{position:absolute;right:12px;bottom:12px;z-index:60;display:flex;flex-direction:column;gap:8px;align-items:flex-end}
  .chip{padding:8px 10px;border-radius:999px;background:var(--glass-2);font-weight:700}
  .bar{height:10px;border-radius:999px;background:rgba(255,255,255,0.06);overflow:hidden}
  .bar > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),var(--accent-2));width:40%}
  .depth-gauge{width:28px;height:86px;border-radius:12px;background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.04);display:flex;align-items:flex-end;padding:4px}
  .depth-fill{width:100%;background:linear-gradient(180deg,#06c8ff,#004f7a);border-radius:8px;transition:height 260ms linear}
  .hidden{display:none}
  .mode-select{display:flex;gap:6px;align-items:center}
  .boost-btn{background:linear-gradient(90deg,#ffd766,#ff8a66);padding:8px 10px;border-radius:10px;font-weight:800}
  input[type=text]{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:white}
  .err{color:#ffb3b3;font-size:12px;margin-top:6px}
  .toast{position:fixed;left:50%;transform:translateX(-50%);top:22px;padding:10px 14px;background:rgba(0,0,0,0.6);border-radius:10px;z-index:200;font-weight:700}
  @media (max-width:900px){ .hud{left:8px;right:8px;top:8px} .card{max-width:92vw} }
  @media (max-width:600px){.app-title{font-size:16px}.stat{font-size:13px}.joy{width:96px;height:96px}.stick{width:44px;height:44px}.hud{flex-direction:column;gap:6px;align-items:flex-start}}
  /* small screens adjustments */
  @media (max-width:480px){
    .app-title{font-size:15px}
    .stat{font-size:12px}
    .joy{width:88px;height:88px}
    .stick{width:40px;height:40px}
    .hud{gap:8px}
  }
  /* extra small screens adjustments */
  @media (max-width:420px){
    .stat{font-size:12px;min-width:56px}
    .joy{width:84px;height:84px}
    .stick{width:36px;height:36px}
    .hud{padding:6px}
  }
  /* very small screens: reduce clutter and make overlays scrollable */
  @media (max-width:360px){
    /* hide depth and coords to free space */
    .stats .stat:nth-child(5), .stats .stat:nth-child(6){ display:none }
    .card{max-width:94vw;padding:14px}
    .overlay .card{max-height:84vh;overflow:auto}
    #miniLeaderboard{left:auto;right:8px;top:68px;min-width:140px;max-width:200px}
    .joy{left:10px;bottom:calc(12px + env(safe-area-inset-bottom, 0px));}
  }
    /* landscape adjustments: center HUD, ensure leaderboard visible and card fits */
    @media (orientation: landscape){
      .hud{left:50%;right:auto;transform:translateX(-50%);width:calc(100% - 24px);max-width:1200px}
      #miniLeaderboard{left:12px;right:auto;top:12px}
      .overlay .card{max-height:calc(100vh - 24px);max-width:92vw;overflow:auto}
      /* nudge the central menu slightly left in landscape on narrower screens to avoid covering HUD on the right */
      @media (max-width:1100px){ .overlay .card{transform: translateX(-14vw);} }
      #leaderboardPanel{max-height:70vh;overflow:auto}
    }
    /* further landscape tweaks: shrink HUD slightly and move it down to avoid notch/status overlaps */
    @media (orientation: landscape) and (max-height:420px){
      .hud{transform:translateX(-50%) scale(0.86); top:calc(22px + env(safe-area-inset-top, 0px));}
      .hud .stats .stat{font-size:12px}
      .bar{transform-origin:top left;transform:scaleY(0.92)}
    }
    /* portrait overlays: when an overlay is open, push the modal down so HUD isn't covered */
    @media (orientation: portrait){
      /* push overlays further down in portrait so the HUD (hunger/mini leaderboard) remains visible */
      body.overlay-open .overlay{align-items:flex-start;padding-top:22vh;padding-bottom:6vh}
      body.overlay-open .overlay .card{margin-top:4vh;max-height:72vh;overflow:auto}
      /* on narrow portrait devices nudge card left slightly and lower the mini leaderboard */
      /* handled by separate media rules below */
    }
    @media (max-width:720px){ body.overlay-open .overlay .card{ transform: translateX(-6vw); } }
    @media (max-width:420px){ body.overlay-open #miniLeaderboard{ top:120px } }
  /* make overlay card text slightly larger on mobile for readability */
  @media (max-width:480px){ .card, .overlay .card { font-size:15px } }
  /* mini leaderboard (top-left, compact) */
  #miniLeaderboard{position:fixed;left:12px;top:72px;z-index:120;min-width:180px;max-width:260px;border-radius:12px;padding:8px;backdrop-filter:blur(6px);background:rgba(0,0,0,0.16);font-size:13px}
  #miniLeaderboard h4{margin:0 0 6px 0;font-size:13px}
  #miniLeaderboard .lb-row{display:flex;justify-content:space-between;gap:8px;padding:6px;border-radius:8px;background:rgba(255,255,255,0.02);margin-bottom:6px}
  #miniLeaderboard .controls{display:flex;gap:6px;align-items:center}
  #miniLeaderboard .toggle{cursor:pointer;padding:6px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent}
  #miniLeaderboard .search{flex:1;padding:6px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:white}
  #miniLeaderboard.small{min-width:160px}

  /* toggle switch */
  .switch { position: relative; display: inline-block; width: 58px; height: 32px; }
  .switch input { opacity: 0; width: 0; height: 0; }
  .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #2c2c2c; transition: .3s; border-radius: 10px; border: 1px solid rgba(255,255,255,0.04)}
  .slider:before { position: absolute; content: ""; height: 24px; width: 24px; left: 4px; bottom: 4px; background-color: white; transition: .3s; border-radius: 6px; }
  input:checked + .slider { background-color: #2196F3; box-shadow: 0 4px 14px rgba(33,150,243,0.18);}
  input:focus + .slider { box-shadow: 0 0 1px #2196F3; }
  input:checked + .slider:before { transform: translateX(26px); }
  .slider.round { border-radius: 34px; }
  .slider.round:before { border-radius: 50%; }
  /* PIN input (apple-like boxes) */
  .pin-modal .pin-row{display:flex;gap:10px;justify-content:center;margin:12px 0}
  .pin-box{width:46px;height:56px;border-radius:10px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.08);display:flex;align-items:center;justify-content:center;font-weight:800;font-size:22px;letter-spacing:6px}
  .pin-box.selected{border:2.5px solid var(--accent);background:rgba(255,255,255,0.13);box-shadow:0 0 0 2px #ffd16699;}
  .pin-modal .pin-actions{display:flex;gap:8px;justify-content:center;margin-top:8px}
  /* compact hud for mobile: hide less important stats and shrink spacing */
  .compact-hud .stats .stat:nth-child(3), .compact-hud .stats .stat:nth-child(5), .compact-hud .stats .stat:nth-child(6){ display:none }
  .compact-hud .stats{gap:6px}

  /* when an overlay (home/shop/leaderboard) is visible, keep HUD visible but non-interactive; on small screens lower the mini leaderboard */
  body.overlay-open .hud{opacity:1;pointer-events:none}
  body.overlay-open .overlay .card{background:linear-gradient(180deg,rgba(0,0,0,0.86),rgba(0,0,0,0.8));backdrop-filter:blur(8px)}
  @media (max-width:900px){ body.overlay-open #miniLeaderboard{display:block !important; top:120px} }
</style>

<!-- Firebase compat SDKs (required so `firebase` exists) -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
<!-- H5 Games Ads (AdSense) -->
<script async
  data-ad-client="ca-pub-369539584"
  data-ad-frequency-hint="180s"
  src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js">
</script>

</head>
<body>
<canvas id="gameCanvas"></canvas>
<div class="hud">
  <div class="title panel">
    <div class="logo" aria-hidden><svg viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6 32c8-12 24-16 36-10 12 6 12 18 0 24C30 54 14 48 6 32z" fill="#fff" opacity="0.18"/><path d="M8 32c8-10 22-14 34-9 9 4 9 12 0 17C30 51 14 44 8 32z" fill="#fff"/></svg></div>
    <div style="display:flex;flex-direction:column"><div class="app-title">Aqua Odyssey</div><div id="usernameDisplay" class="username-display">Guest</div></div>
  </div>
  <div class="panel stats"><div class="stat">Size<br><strong id="size">1.0</strong></div><div class="stat">Score<br><strong id="score">0</strong></div><div class="stat">High<br><strong id="highscore">0</strong></div><div class="stat">Coins<br><strong id="coins">0</strong></div><div class="stat">Depth<br><strong id="depthVal">0 m</strong></div><div class="stat">Coords<br><strong id="coords">0,0</strong></div></div>
  <div class="controls"><div class="panel"><div style="font-size:12px;opacity:0.85">Hunger</div><div class="bar" style="width:120px;margin-top:6px"><i id="hungerBar" style="width:100%"></i></div></div>
    <div class="mode-select panel" style="align-items:center">Control: <select id="controlMode" style="margin-left:8px;padding:6px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.06)"><option value="mouse">Mouse</option><option value="keyboard">Keyboard</option><option value="mobile">Mobile</option></select></div>
    <button id="btnPause" class="btn panel">Pause</button>
    <button id="btnLeave" class="btn panel">Exit</button>
  </div>
</div>

<!-- compact in-game leaderboard (top-left) -->
<div id="miniLeaderboard" class="panel small">
  <div style="display:flex;align-items:center;justify-content:space-between;gap:8px">
    <h4 style="margin:0">Leaderboard</h4>
    <div style="display:flex;gap:6px;align-items:center">
      <input id="miniSearch" class="search" placeholder="search" />
      <button id="miniToggle" class="toggle">‚ñº</button>
    </div>
  </div>
  <div id="miniList" style="margin-top:8px;max-height:220px;overflow:auto"></div>
  <div id="miniFooter" style="margin-top:6px;font-size:12px;opacity:0.9;display:flex;justify-content:space-between"><div id="miniYou">You: -</div><div id="miniCount">0</div></div>
</div>

<div class="side">
  <div class="joy panel" id="joystick"><div class="stick" id="stick"></div></div>
</div>
<div class="controls-bottom">
  <div style="display:flex;align-items:center;gap:10px"><div class="chip panel">FPS: <span id="fps">0</span></div><div style="text-align:center" class="panel" aria-hidden><div style="font-size:12px;opacity:0.85">Depth</div><div class="depth-gauge" id="depthGauge"><div class="depth-fill" id="depthFill" style="height:4%"></div></div></div></div>
  <button id="boostMobile" class="boost-btn panel">BOOST</button>
</div>
<!-- mobile settings button (visible on small screens) -->
<button id="mobileSettingsBtn" class="secondary" style="position:fixed;right:12px;bottom:86px;z-index:130;display:none;padding:8px 10px;border-radius:10px">‚öô</button>

<!-- mobile settings modal -->
<div class="overlay hidden" id="mobileSettingsModal" style="pointer-events:auto;z-index:13000">
  <div class="card" style="max-width:360px;text-align:left">
    <h3>Mobile Settings</h3>
    <div style="display:flex;flex-direction:column;gap:10px;margin-top:6px">
      <label><input type="checkbox" id="compactHudChk"> Compact HUD (less clutter)</label>
      <label>Joystick style: <select id="joystickStyleSel"><option value="floating">Floating</option><option value="fixed">Fixed</option></select></label>
      <label>Camera zoom: <input id="zoomRange" type="range" min="0.6" max="1.6" step="0.05" value="1" style="width:100%"/></label>
      <div style="display:flex;gap:8px;justify-content:flex-end"><button id="mobileSettingsClose" class="primary">Done</button></div>
    </div>
  </div>
</div>
<!-- debug bot panel (visible on desktop/mobile when needed) -->
<div id="botDebugPanel" style="position:fixed;left:8px;bottom:120px;z-index:140;background:rgba(0,0,0,0.5);padding:8px;border-radius:10px;color:#fff;font-size:13px;display:none;min-width:160px">
  <div id="botDebugCounts">Bots: 0 (local 0 / remote 0)</div>
  <div style="margin-top:6px;display:flex;gap:6px">
    <button id="forceSpawnBots" class="secondary" style="flex:1">Force +</button>
    <button id="boostBotsToggle" class="secondary" style="flex:1">Boost</button>
  </div>
</div>
<div id="toastArea"></div>
<div class="overlay" id="overlay">
  <div class="card" id="homeCard">
    <h2>Aqua Odyssey</h2>
    <p>Survive as long as possible ‚Äî larger fish eat smaller fish. You get hungrier the bigger you are. New things keep spawning: the sea is endless.</p>

    <!-- Play / room controls -->
    <div style="display:flex;gap:8px;margin-bottom:8px;align-items:center;justify-content:center;flex-wrap:wrap">
      <button id="startOfflineBtn" class="primary">Play Offline</button>
      <button id="startOnlineBtn" class="primary" style="margin-left:8px">Play Online (with bots)</button>
      <button id="startOnlineNoBots" class="primary" style="margin-left:8px;background:linear-gradient(90deg,#9ae66a,#66d9ff);font-size:12px;padding:8px 10px">Online (no bots)</button>
      <button id="fbSetupBtn" class="secondary" style="margin-left:8px">Connect Firebase</button>
      <button id="infoBtn" class="secondary" style="margin-left:8px">Info</button>
      <button id="leaderboardBtn" class="secondary" style="margin-left:8px">Leaderboard</button>
      <button id="shopBtn" class="secondary" style="margin-left:8px">Shop</button>
      <div style="margin-left:12px;display:flex;align-items:center;gap:8px">
        <div id="connIndicator" style="width:12px;height:12px;border-radius:999px;background:#999;border:2px solid rgba(0,0,0,0.3)"></div>
        <div id="connText" style="font-size:12px;opacity:0.9">Offline</div>
        <div id="connMs" style="font-size:12px;opacity:0.9;margin-left:6px"></div>
      </div>
    </div>

    <!-- Room creation / join -->
    <div style="display:flex;gap:8px;margin-bottom:8px;align-items:center;justify-content:center;flex-wrap:wrap">
      <input id="roomCodeInput" placeholder="Room code (6 chars)" style="padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:white;min-width:160px"/>
      <button id="generateRoomBtn" class="secondary">Generate</button>

      <!-- Allow bots toggle -->
      <label style="display:flex;align-items:center;gap:6px">
        <span style="font-size:13px;opacity:0.9">Allow bots</span>
        <label class="switch" title="Allow bots in this room">
          <input id="allowBotsSwitch" type="checkbox" checked>
          <span class="slider round"></span>
        </label>
      </label>

      <button id="createRoomBtn" class="primary">Create Room</button>
      <button id="joinRoomBtn" class="primary" style="background:linear-gradient(90deg,#9ae66a,#66d9ff)">Join Room</button>
    </div>

    <div style="display:flex;gap:8px;margin-bottom:8px;align-items:center;justify-content:center;flex-wrap:wrap">
      <button id="spectateToggleBtn" class="secondary">Spectate Mode</button>
    </div>

    <div style="display:flex;gap:8px;margin-bottom:8px;align-items:center;justify-content:center;flex-wrap:wrap">
      <input id="usernameInput" type="text" placeholder="Enter username" style="margin-left:8px;min-width:180px"/>
      <button id="setNameBtn" class="secondary">Set</button>
      <button id="setPinBtn" class="secondary">Set PIN</button>
      <button id="loginPinBtn" class="secondary">Login with PIN</button>
      <button id="deleteAccountBtn" class="secondary" style="background:linear-gradient(90deg,#ff6b6b,#ff3b3b);display:none">Delete Account</button>
      <button id="signOutBtn" class="secondary" style="display:none">Sign Out</button>
    </div>
    <div style="font-size:12px;opacity:0.7;margin-top:4px;text-align:center">
      ‚ö†Ô∏è Accounts not logged in for 90+ days will be automatically deleted. Please login regularly to keep your account.
    </div>
    <div id="nameErr" class="err"></div>
    <div id="homeInfo" class="info">
      <strong>History &amp; Lore</strong>
      <div id="loreList">
        <!-- Long lore added below in JS rendering -->
      </div>
      <strong>Controls</strong>
      <ul>
        <li>Mouse: move with cursor</li>
        <li>Keyboard: WASD / Arrow keys, Hold Shift to boost (loses size)</li>
        <li>Mobile: tap anywhere and drag to move (Floating Joystick available)</li>
      </ul>
    </div>

    <div id="shopPanel" class="info hidden"><strong>Shop</strong>
      <div style="margin:8px 0;display:flex;gap:8px"><input id="shopSearch" placeholder="Search" style="flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:white"/><select id="shopSort" style="padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:white"><option value="price-asc">Price ‚Üë</option><option value="price-desc">Price ‚Üì</option><option value="name">Name</option></select></div>
    <div id="leaderboardPanel" class="info hidden"><strong>Leaderboard</strong>
      <div style="display:flex;gap:8px;margin-top:8px;align-items:center;margin-bottom:8px">
        <input id="leaderboardSearch" placeholder="Search players" style="flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:white"/>
        <select id="leaderboardFilter" style="padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:white"><option value="all">All-time (Best)</option><option value="online">Currently Online</option><option value="room">Same Room</option></select>
        <button id="findMeBtn" class="secondary">Find Me</button>
      </div>
      <div id="leaderboardList" style="margin-top:8px"></div>
    </div>
      <div id="shopItems" class="shop"></div>
    </div>
  </div>
</div>

  <!-- PIN modal -->
  <div class="overlay hidden pin-modal" id="pinModal" style="pointer-events:auto;z-index:12000">
    <div class="card" style="max-width:420px">
      <h3>Set a 4‚Äì6 digit PIN</h3>
      <p style="font-size:13px;opacity:0.9">Click the boxes to enter digits (0-9). It will be hashed locally and saved to Firebase. There is no reset ‚Äî you must remember it.</p>
      <div class="pin-row" id="pinBoxes"></div>
      <div class="pin-actions">
        <button id="pinSaveBtn" class="primary">Save PIN</button>
        <button id="pinCancelBtn" class="secondary">Cancel</button>
      </div>
      <div id="pinMsg" class="err" style="text-align:center;margin-top:8px"></div>
    </div>
  </div>

  <!-- Username Login modal -->
  <div class="overlay hidden pin-modal" id="usernameLoginModal" style="pointer-events:auto;z-index:12000">
    <div class="card" style="max-width:420px">
      <h3>Login or Create Account</h3>
      <p style="font-size:13px;opacity:0.9">Enter your username. If it exists, you'll need your PIN. If new, an account will be created.</p>
      <div style="font-size:12px;opacity:0.8;margin-bottom:8px;padding:8px;background:rgba(255,107,107,0.1);border-radius:6px">
        ‚ö†Ô∏è Important: Accounts inactive for 90+ days will be automatically deleted. Login regularly to keep your data.
      </div>
      <input id="loginUsernameInput" type="text" placeholder="Enter username" style="width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.1);background:rgba(255,255,255,0.05);color:white;margin:12px 0;font-size:14px" />
      <div class="pin-actions">
        <button id="usernameLoginBtn" class="primary">Continue</button>
        <button id="usernameLoginCancelBtn" class="secondary">Cancel</button>
      </div>
      <div id="usernameLoginMsg" class="err" style="text-align:center;margin-top:8px"></div>
    </div>
  </div>

  <!-- PIN Login modal (shown after username verification) -->
  <div class="overlay hidden pin-modal" id="pinLoginModal" style="pointer-events:auto;z-index:12000">
    <div class="card" style="max-width:420px">
      <h3>Enter Your PIN</h3>
      <p style="font-size:13px;opacity:0.9" id="pinLoginSubtitle">Enter your PIN to login.</p>
      <div class="pin-row" id="pinLoginBoxes"></div>
      <div class="pin-actions">
        <button id="pinLoginBtn" class="primary">Login</button>
        <button id="pinLoginCancelBtn" class="secondary">Cancel</button>
      </div>
      <div id="pinLoginMsg" class="err" style="text-align:center;margin-top:8px"></div>
    </div>
  </div>

<!-- Hidden fallback elements -->
<select id="homeControlMode" class="hidden" style="display:none;">
  <option value="mouse">Mouse</option>
  <option value="keyboard">Keyboard</option>
  <option value="mobile">Mobile</option>
</select>

<!-- Hidden numeric input for keyboard PIN entry -->
<input id="pinHiddenInput" type="text" inputmode="numeric" autocomplete="one-time-code" maxlength="6" style="position:absolute;left:-9999px;width:1px;height:1px;opacity:0;" />
<script>
// ---------- setup & globals ----------
const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d'); let DPR = Math.max(1, window.devicePixelRatio || 1);

// detect device performance to apply client-side throttling (rendering/workload only)
function detectDevicePerformance(){
  const perf = { multiplier: 1, dprCap: Math.max(1, Math.min(2, window.devicePixelRatio || 1)), entityDrawLimit: 300 };
  try{
    const mem = navigator.deviceMemory || 4;
    const hc = navigator.hardwareConcurrency || 4;
    const ua = (navigator.userAgent||'').toLowerCase();
    const isMobile = /mobi|android|iphone|ipad/.test(ua);
    // conservative defaults
    if(isMobile){ perf.multiplier = 0.7; perf.dprCap = Math.min(perf.dprCap, 1.5); perf.entityDrawLimit = 160; }
    if(mem <= 1.5 || hc <= 2){ perf.multiplier = Math.min(perf.multiplier, 0.45); perf.dprCap = Math.min(perf.dprCap, 1); perf.entityDrawLimit = Math.min(perf.entityDrawLimit, 90); }
    else if(mem <= 3 || hc <= 4){ perf.multiplier = Math.min(perf.multiplier, 0.7); perf.dprCap = Math.min(perf.dprCap, 1.5); perf.entityDrawLimit = Math.min(perf.entityDrawLimit, 160); }
    else { perf.multiplier = 1; perf.dprCap = Math.max(perf.dprCap, 1.5); perf.entityDrawLimit = 320; }
  }catch(e){ }
  // clamp ranges
  perf.multiplier = Math.max(0.35, Math.min(1, perf.multiplier));
  perf.dprCap = Math.max(1, Math.min(2.5, perf.dprCap));
  perf.entityDrawLimit = Math.max(40, Math.min(800, perf.entityDrawLimit));
  return perf;
}
const devicePerf = detectDevicePerformance(); window.__devicePerf = devicePerf;
function resize(){
  // cap DPR based on device performance to reduce GPU/CPU load on weaker devices
  try{ DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, devicePerf.dprCap || (window.devicePixelRatio || 1))); }catch(e){ DPR = Math.max(1, window.devicePixelRatio || 1); }
  canvas.width = Math.floor(window.innerWidth * DPR);
  canvas.height = Math.floor(window.innerHeight * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
  // ensure CSS size matches viewport so canvas covers entire screen (fixes partial viewport on some mobiles)
  try{ canvas.style.width = '100%'; canvas.style.height = '100%'; }catch(e){}
}
window.addEventListener('resize', resize); window.addEventListener('orientationchange', resize); resize();
// adjust HUD / control sizing for small screens
function updateUIScaling(){ try{ const w = window.innerWidth; const hud = document.querySelector('.hud'); const joy = document.getElementById('joystick'); if(hud){ if(w < 420){ hud.style.transform = 'scale(0.86)'; hud.style.transformOrigin = 'left top'; } else { hud.style.transform = ''; } }
  if(joy){ // ensure joystick respects safe-area-bottom on mobile
    const safeBottom = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--safe-bottom')||'0') || 0;
    if(window.CSS && window.CSS.supports && window.CSS.supports('padding-bottom: env(safe-area-inset-bottom)')){
      joy.style.bottom = 'calc(14px + env(safe-area-inset-bottom))';
    } else {
      joy.style.bottom = '14px';
    }
  }
}catch(e){} }
window.addEventListener('resize', updateUIScaling); window.addEventListener('orientationchange', updateUIScaling); setTimeout(updateUIScaling,50);
// on orientation change, also ensure overlays (leaderboard) stay visible and camera updates immediately
window.addEventListener('orientationchange', ()=>{
  try{
    resize(); updateUIScaling(); updateCamera(16); render();
    const lb = document.getElementById('leaderboardPanel');
    if(lb && !lb.classList.contains('hidden')){ lb.scrollTop = 0; lb.scrollIntoView({behavior:'auto', block:'center'}); }
    const mini = document.getElementById('miniLeaderboard'); if(mini){ mini.style.display = window.innerWidth > window.innerHeight ? 'block' : ''; }
  }catch(e){}
});

// Firebase-related variables
let firebaseApp = null, firebaseDB = null, firebaseAuth = null;
let firebaseConnected = false, firebaseUid = null;
let bestScoresCache = null;
let isOnlineMode = false; // whether the current play session is online

// other global basics
function overlayVisible(){ const o = document.getElementById('overlay'); return o && !o.classList.contains('hidden'); }

canvas.addEventListener('contextmenu', (e)=>{ e.preventDefault(); }); // right-click used for boost

function showToast(msg, ms=2200){ const t = document.createElement('div'); t.className='toast'; t.textContent = msg; document.getElementById('toastArea').appendChild(t); setTimeout(()=>{ t.style.transition='opacity 400ms'; t.style.opacity='0'; setTimeout(()=>t.remove(),420); }, ms); }

document.body.addEventListener('touchmove', (e)=>{ if(overlayVisible()) return; e.preventDefault(); }, {passive:false});

// world & camera
const camera = { x: 0, y: 0, scale: 1, userZoomFactor: 1 };
let cameraFrozen = false;
function screenToWorld(sx, sy){ return { x: camera.x + sx / camera.scale, y: camera.y + sy / camera.scale }; }

// timing & UI refs
let running = false, lastTime = performance.now(), fpsCounter = 0, fpsTimer = 0;
let __botIntervalId = null;
// runtime bot density multiplier for quick tuning/debugging
let botDensityMultiplier = 1;
const ui = { sizeEl: document.getElementById('size'), scoreEl: document.getElementById('score'), highEl: document.getElementById('highscore'), coinsEl: document.getElementById('coins'), hungerEl: document.getElementById('hungerBar'), fpsEl: document.getElementById('fps'), depthEl: document.getElementById('depthVal'), depthFill: document.getElementById('depthFill'), usernameDisplay: document.getElementById('usernameDisplay'), coordsDisplay: document.getElementById('coords') };

// player object
const player = { x: 0, y: 0, size: 12, baseSpeed: 140, angle: 0, skin: 'classic', color: '#ff9a66', eyeColor: '#0b1b2b', hunger: 100, coins: 0, score: 0, alive: true, vx:0, vy:0, speed:0 };

// entities
let foods = [], enemies = [], bubbles = [];
const MAX_FOOD = 480;  // Increased from 250 for better spread
const WORLD_BOUND = 4200;
let enemyIdCounter = 1;
let deathHandled = false;

// default allow bots true
let allowBots = true;

// UI tiny helpers
function setRunning(v){ const was = running; running = !!v; const btn = document.getElementById('btnPause'); if(btn) btn.textContent = running ? 'Pause' : 'Resume'; if(running && !was){ lastTime = performance.now(); requestAnimationFrame(mainLoop); // start periodic bot top-up when running and bots allowed
    try{ if(__botIntervalId) clearInterval(__botIntervalId);
      if(allowBots){
        // when online, keep logic spawning unchanged; client-only throttling applies only offline for consistency
        const perfMult = (!isOnlineMode) ? devicePerf.multiplier : 1;
        const minCount = Math.max(60, Math.round(120 * botDensityMultiplier * perfMult));
        const intervalMs = Math.max(300, Math.round(1200 / Math.max(1, botDensityMultiplier * perfMult)));
        __botIntervalId = setInterval(()=>{ try{ ensureBotPopulation(minCount); }catch(e){} }, intervalMs);
      }
    }catch(e){}
  } else if(!running && was){ // stopped: clear bot interval
    try{ if(__botIntervalId){ clearInterval(__botIntervalId); __botIntervalId = null; } }catch(e){}
  } }
  

// ---------- content & shop ----------
const LORE = [
  {id:1,title:'The Great Deluge', text: `They called it the Deluge ‚Äî glaciers shifted and the seas rose with a slow, unstoppable patience. Cities dissolved into reefs; towers became kelp-strewn monuments. The creatures that survived adapted: long, patient mouths changed to snap and gape, fins learned the art of chasing, and tiny scavengers turned into hunters.`},
  {id:2,title:'The Shoals of Memory', text: `On nights when the water is still and phosphorescence hangs like distant stars, you can see fragments of what was. A lamppost, a rooftop garden, a child's bicycle encrusted with barnacles ‚Äî relics of a time when people shaped the world. Those memories feed the deep, and the deep remembers.`},
  {id:3,title:'The New Orders', text: `Territories formed. The smallest fish formed cooperative hunting packs, while the big ones ruled like old lords. The wise learned to avoid the brash, and those that learned fastest to feed - thrived.`},
  {id:4,title:'Merchant Shoals', text: `Where currents converge there is bounty. Carcasses drift, and with them come trades‚Äîpredators trading time for food, small fish offering distraction while a friend steals a meal. This is where you will learn the rules, and how not to become someone else‚Äôs meal.`},
  {id:5,title:'Echoes', text: `There is an uneasy peace on the ocean floor. The songs are different now ‚Äî low hums and clicks that guide schools. Listen and you may find a path or a rival. Ignore them and you might not wake.`},
  {id:6,title:'Your Tale', text: `This world will not forgive arrogance; it will not rescue the careless. Swim careful, grow steady, and remember: every small bite is a promise to survive another tide.`}
];

function renderLore(){ const el = document.getElementById('loreList'); if(!el) return; el.innerHTML = ''; for(const entry of LORE){ const d=document.createElement('div'); d.style.marginBottom='12px'; d.innerHTML = `<strong style="display:block;margin-bottom:6px">${entry.title}</strong><div style="font-size:13px;opacity:0.95">${entry.text}</div>`; el.appendChild(d); } }
renderLore();

const SKINS = [
  {id:'classic',name:'Classic',color:'#ff9a66',emoji:'üêü',price:0},
  {id:'azure',name:'Azure',color:'#66d9ff',emoji:'üê†',price:250},
  {id:'neon',name:'Neon',color:'#b8ff6a',emoji:'üê°',price:420},
  {id:'shadow',name:'Shadow',color:'#3a3a4a',emoji:'ü¶à',price:700},
  {id:'sunburst',name:'Sunburst',color:'#ffd166',emoji:'üêü',price:1200},
  {id:'royal',name:'Royal',color:'#a56cff',emoji:'üê†',price:2000},
  {id:'emerald',name:'Emerald',color:'#39d98a',emoji:'üê°',price:3200},
  {id:'coral',name:'Coral',color:'#ff6b9a',emoji:'üê†',price:800}
];

const SHOP_ITEMS = [
  {id:'coin_small',name:'Coin Pack: 500',type:'consumable',desc:'Instant +500 coins',price:1200,effect:()=>{ player.coins += 500 }},
  {id:'coin_med',name:'Coin Pack: 2000',type:'consumable',desc:'Instant +2,000 coins',price:4200,effect:()=>{ player.coins += 2000 }},
  {id:'speed_up',name:'Engine Upgrade',type:'upgrade',desc:'Permanent +40 base speed',price:2500,effect:()=>{ player.baseSpeed += 40 }},
  {id:'size_boost',name:'Size Booster',type:'consumable',desc:'Instant +8 size',price:1800,effect:()=>{ player.size += 8 }},
  {id:'hunger_pack',name:'Sustenance Pack',type:'consumable',desc:'Refills hunger',price:500,effect:()=>{ player.hunger = Math.min(100, player.hunger + 60) }},
  {id:'spawn_beacon',name:'Spawn Beacon',type:'utility',desc:'Place a beacon visible on map (temporary)',price:3200,effect:()=>{ showToast('Beacon placed (client-only)',1800) }},
  {id:'skin_bundle',name:'Skin Bundle',type:'bundle',desc:'Unlock 3 random skins',price:2800,effect:()=>{ SKINS.slice(1,4).forEach(s=>owned.add(s.id)); saveOwned(); }}
];

const owned = new Set(JSON.parse(localStorage.getItem('ownedSkins')||'["classic"]'));
let equipped = localStorage.getItem('equippedSkin') || 'classic';
function saveOwned(){ localStorage.setItem('ownedSkins', JSON.stringify(Array.from(owned))); localStorage.setItem('equippedSkin', equipped); }
function renderShop(filter='',sortBy='price-asc'){ const shopItemsEl = document.getElementById('shopItems'); if(!shopItemsEl) return; shopItemsEl.innerHTML=''; let list = SHOP_ITEMS.concat(SKINS.map(s=>Object.assign({type:'skin'},s))).filter(i=>i.name.toLowerCase().includes((filter||'').toLowerCase())); if(sortBy==='price-asc') list.sort((a,b)=>a.price-b.price); if(sortBy==='price-desc') list.sort((a,b)=>b.price-a.price); if(sortBy==='name') list.sort((a,b)=>a.name.localeCompare(b.name));
 for(const it of list){ const row = document.createElement('div'); row.className='shop-row'; const left = document.createElement('div'); let thumb = ''; if(it.type==='skin' || it.color){ thumb = `<div style="width:56px;height:40px;border-radius:8px;background:${it.color||'#999'};display:inline-block;margin-right:8px;vertical-align:middle;border:2px solid rgba(255,255,255,0.06)"></div>`; } left.innerHTML = `${thumb}<div style="display:inline-block;vertical-align:middle"><div style=\"font-weight:800\">${it.name}</div><div style=\"font-size:12px;opacity:0.9\">${it.desc||''}</div></div>`; const right = document.createElement('div'); const price = document.createElement('div'); price.style.fontWeight='800'; price.style.marginRight='8px'; price.textContent = it.price + ' c'; const btn = document.createElement('button'); btn.className='btn'; const affordable = player.coins >= it.price;
    if(it.type==='skin'){ btn.textContent = owned.has(it.id)?(equipped===it.id?'Equipped':'Equip'):'Buy'; if(!owned.has(it.id) && !affordable) btn.disabled=true; btn.onclick=()=>{ if(owned.has(it.id)){ equipped = it.id; player.color = it.color; saveOwned(); showToast(it.name + ' equipped'); console.log('shop: equipped', it.id, it.name); renderShop(document.getElementById('shopSearch')?document.getElementById('shopSearch').value:'', document.getElementById('shopSort')?document.getElementById('shopSort').value:'price-asc'); } else { if(player.coins >= it.price){ player.coins -= it.price; owned.add(it.id); equipped = it.id; player.color = it.color; saveOwned(); showToast('Purchased and equipped ' + it.name); console.log('shop: purchased skin', it.id, it.name, 'coinsLeft', player.coins); renderShop(document.getElementById('shopSearch')?document.getElementById('shopSearch').value:'', document.getElementById('shopSort')?document.getElementById('shopSort').value:'price-asc'); ui.coinsEl.textContent = player.coins; } else showToast('Not enough coins'); } };
    } else { btn.textContent = 'Buy'; if(!affordable) btn.disabled=true; btn.onclick = ()=>{ if(player.coins >= it.price){ player.coins -= it.price; try{ if(it.effect) it.effect(); }catch(e){} showToast('Purchased ' + it.name); ui.coinsEl.textContent = player.coins; } else showToast('Not enough coins'); } }
    // log purchases for analytics/debug
    if(it.type !== 'skin'){ const orig = btn.onclick; btn.onclick = ()=>{ const before = player.coins + it.price; if(player.coins >= it.price){ console.log('shop: purchasing', it.id, it.name); orig(); console.log('shop: purchased', it.id, it.name, 'coinsNow', player.coins); } else { console.log('shop: purchase failed (insufficient coins)', it.id, it.name); orig(); } }; }
    right.style.display='flex'; right.style.alignItems='center'; right.appendChild(price); right.appendChild(btn); row.appendChild(left); row.appendChild(right); shopItemsEl.appendChild(row); }
}
if(document.getElementById('shopSearch')) document.getElementById('shopSearch').addEventListener('input',(e)=>renderShop(e.target.value, document.getElementById('shopSort')?document.getElementById('shopSort').value:'price-asc'));
if(document.getElementById('shopSort')) document.getElementById('shopSort').addEventListener('change',(e)=>renderShop(document.getElementById('shopSearch')?document.getElementById('shopSearch').value:'', e.target.value));
renderShop();

// ---------- spawn & world ----------
function randBetween(a,b){ return a + Math.random()*(b-a); }
function spawnFoodAround(cx,cy){ if(foods.length>MAX_FOOD) return; const angle = Math.random()*Math.PI*2; const dist = 800 + Math.random()*5200;  // Wider spread to reduce clustering
  const f={ x: cx + Math.cos(angle)*dist, y: cy + Math.sin(angle)*dist, size: 3 + Math.random()*6, wobble: Math.random()*Math.PI*2, color:'#fff59d' }; foods.push(f); }

// spawn an enemy at a variable distance; if created larger than player it will be less aggressive initially
function spawnEnemyRelative(cx,cy, forcedSize){
  // Respect per-room bot policy: do not create AI enemies when bots are disabled
  if(!allowBots){ return null; }
  const base = 10 + Math.random()*48;
  const rel = Math.random()*player.size*1.1;
  const size = typeof forcedSize === 'number' ? forcedSize : Math.max(8, Math.min(player.size*2.8, base + rel));
  const angle = Math.random()*Math.PI*2;
  const dist = 900 + Math.random()*5200; // wider spread so bots populate far from player
  const x = cx + Math.cos(angle)*dist;
  const y = cy + Math.sin(angle)*dist;
  let speed = 20 + Math.random()*80; // slightly slower so large predators are less immediate
  if(size > player.size * 1.4) speed *= 0.45; // give the player a chance
  const e = { id: enemyIdCounter++, x, y, size, speed, angle: angle, color: (typeof randomColor === 'function' ? randomColor() : '#ff6b6b'), state:'wander', target:null, hunger:100, name: 'AI_'+Math.floor(Math.random()*99999), isRemote:false };
  enemies.push(e);
  return e;
}

function spawnBubbleAround(cx,cy){ bubbles.push({ x: cx + (Math.random()-0.5)*800, y: cy + (Math.random()-0.5)*800, r: 3+Math.random()*8, vy: 20+Math.random()*60, alpha: 0.08+Math.random()*0.18 }); }

// Ensure there is occasionally a predator larger than the player, but place it far away and make it less aggressive
function ensureLargerPredatorMaybe(cx, cy){ if(!allowBots) return; if(enemies.length > 400) return; const maxOther = enemies.reduce((m,e)=>Math.max(m, e.size||0), 0); if(player.size <= maxOther * 0.95) return; // already not the biggest
  // allow larger predator checks even with many enemies when we increased density
  // (threshold bumped earlier in edits)
  // spawn a slightly larger predator placed far from the player
  const largerSize = Math.max(player.size * (1.08 + Math.random()*0.22), player.size + 6); spawnEnemyRelative(cx, cy, largerSize);
  // make the newest enemy less aggressive initially (so it's a threat but not an instant death)
  const ne = enemies[enemies.length-1]; if(ne){ ne.state = 'wander'; ne.hunger = 100; ne.speed *= 0.55; }
}

// Ensure a minimum number of local (non-remote) bot enemies exist nearby
function ensureBotPopulation(minCount){ if(!allowBots) return; const localBots = enemies.filter(e=>!e.isRemote); const need = Math.max(0, minCount - localBots.length); for(let i=0;i<need;i++){ // spawn nearer to player but spread out
  const angle = Math.random()*Math.PI*2; const dist = 900 + Math.random()*5200; const x = player.x + Math.cos(angle)*dist; const y = player.y + Math.sin(angle)*dist; // spawnEnemyRelative will pick an additional offset.
  // pass the computed coordinates so bots appear spread around the player (not always centered)
  spawnEnemyRelative(x, y);
  } }

// spawn bots distributed across the world (not just near player) to fill map
function spawnBotsAcrossMap(count){ if(!allowBots) return; for(let i=0;i<count;i++){ const rx = (Math.random()*2 - 1) * WORLD_BOUND * 0.9; const ry = (Math.random()*2 - 1) * WORLD_BOUND * 0.9; spawnEnemyRelative(rx, ry); } }

  // initial world population is created when the player starts the game (startGame)
  // avoid creating bots/food at global script load so rooms with no-bots remain clean

// ---------- input ----------
let controlMode = localStorage.getItem('controlMode') || 'mouse';
const controlModeSelect = document.getElementById('controlMode');
if(controlModeSelect){ controlModeSelect.value = controlMode; controlModeSelect.addEventListener('change', e=>{ controlMode = e.target.value; const homeControl = document.getElementById('homeControlMode'); if(homeControl) homeControl.value = controlMode; localStorage.setItem('controlMode', controlMode); updateControlUI(); }); }
const homeControl = document.getElementById('homeControlMode'); if(homeControl){ homeControl.value = controlMode; homeControl.addEventListener('change', e=>{ controlMode = e.target.value; if(controlModeSelect) controlModeSelect.value = controlMode; localStorage.setItem('controlMode', controlMode); updateControlUI(); }); }

let pointerX=null,pointerY=null; let keys = {};
function updateControlUI(){ const joy = document.getElementById('joystick'); const boost = document.getElementById('boostMobile'); if(!joy || !boost) return; const mobileStyle = localStorage.getItem('mobileStyle') || 'floating'; if(controlMode === 'mobile' && mobileStyle === 'floating'){ joy.style.display = 'flex'; boost.style.display = 'block'; } else if(controlMode === 'mobile' && mobileStyle === 'touch'){ joy.style.display = 'none'; boost.style.display = 'block'; } else { joy.style.display = 'none'; boost.style.display = 'none'; } }
setTimeout(()=>{ updateControlUI(); }, 10);

// apply saved mobile settings (compact HUD, joystick style, camera zoom)
function applyMobileSettings(){ try{ const compact = localStorage.getItem('compactHud') === '1'; const hud = document.querySelector('.hud'); if(hud){ if(compact) hud.classList.add('compact-hud'); else hud.classList.remove('compact-hud'); }
  const js = localStorage.getItem('mobileStyle') || 'floating'; const sel = document.getElementById('joystickStyleSel'); if(sel) sel.value = js; const zoom = parseFloat(localStorage.getItem('cameraZoom') || '1'); camera.userZoomFactor = zoom || 1; const zr = document.getElementById('zoomRange'); if(zr) zr.value = (camera.userZoomFactor||1);
  // show/hide mobile settings button based on screen width
  const mb = document.getElementById('mobileSettingsBtn'); if(mb){ mb.style.display = window.innerWidth <= 720 ? 'block' : 'none'; }
  // if on a very small screen and user hasn't set preferences, enable compact HUD and slightly zoom out
  try{ const seen = localStorage.getItem('mobilePrefsSeen'); if(!seen && window.innerWidth <= 360){ localStorage.setItem('compactHud','1'); camera.userZoomFactor = Math.max(1.05, camera.userZoomFactor||1.05); localStorage.setItem('cameraZoom', camera.userZoomFactor.toString()); localStorage.setItem('mobilePrefsSeen','1'); if(hud) hud.classList.add('compact-hud'); if(zr) zr.value = camera.userZoomFactor; } }catch(e){}
}catch(e){}
}
window.addEventListener('resize', ()=>{ try{ const mb = document.getElementById('mobileSettingsBtn'); if(mb) mb.style.display = window.innerWidth <= 720 ? 'block' : 'none'; }catch(e){} });
setTimeout(applyMobileSettings, 30);
// show debug panel toggle in console if needed
function updateBotDebugPanel(){ try{ const panel = document.getElementById('botDebugPanel'); if(!panel) return; const total = (typeof enemies !== 'undefined') ? enemies.length : 0; const local = (typeof enemies !== 'undefined') ? enemies.filter(e=>!e.isRemote).length : 0; const remote = total - local; const el = document.getElementById('botDebugCounts'); if(el) el.textContent = `Bots: ${total} (local ${local} / remote ${remote})`; }catch(e){} }
setInterval(()=>{ try{ updateBotDebugPanel(); }catch(e){} }, 1400);

// wire debug buttons
setTimeout(()=>{
  try{
    const panel = document.getElementById('botDebugPanel'); const forceBtn = document.getElementById('forceSpawnBots'); const boostBtn = document.getElementById('boostBotsToggle');
    if(forceBtn){ forceBtn.addEventListener('click', ()=>{ try{ ensureBotPopulation(40); showToast('Forced bots spawn'); updateBotDebugPanel(); }catch(e){ console.warn(e); } }); }
    if(boostBtn){ let boosted=false; boostBtn.addEventListener('click', ()=>{ boosted = !boosted; botDensityMultiplier = boosted ? 6 : 1; boostBtn.textContent = boosted ? 'Boosted' : 'Boost'; showToast('Bot spawn ' + (boosted ? 'boosted' : 'normal'));
      try{ if(__botIntervalId) clearInterval(__botIntervalId); if(allowBots){ const perfMult = (!isOnlineMode) ? devicePerf.multiplier : 1; const minCount = Math.max(80, Math.round(160 * botDensityMultiplier * perfMult)); const intervalMs = Math.max(200, Math.round(1000 / Math.max(1, botDensityMultiplier * perfMult))); __botIntervalId = setInterval(()=>{ try{ ensureBotPopulation(minCount); }catch(e){} }, intervalMs); } }catch(e){} updateBotDebugPanel(); }); }
    // expose quick console toggle
    window.showBotDebug = function(v){ const p = document.getElementById('botDebugPanel'); if(!p) return; p.style.display = v ? 'block' : 'none'; };
  }catch(e){}
}, 120);

window.addEventListener('mousemove', e=>{ if(overlayVisible()) return; if(controlMode==='mouse'){ pointerX = e.clientX; pointerY = e.clientY; } });
window.addEventListener('mousedown', e=>{ if(overlayVisible()) return; if(e.button===2){ boosting = true; } });
window.addEventListener('mouseup', e=>{ if(overlayVisible()) return; if(e.button===2){ boosting = false; } });

let touchAnywhereStart = null;
window.addEventListener('touchmove', (e)=>{ if(overlayVisible()) return; const t = e.touches[0]; if(!t) return; pointerX = t.clientX; pointerY = t.clientY; e.preventDefault(); }, {passive:false});
window.addEventListener('touchend', (e)=>{ if(overlayVisible()) return; pointerX = null; pointerY = null; touchAnywhereStart = null; });
window.addEventListener('touchcancel', (e)=>{ pointerX = null; pointerY = null; touchAnywhereStart = null; }, {passive:false});

window.addEventListener('keydown', e=>{ if(overlayVisible()) return; keys[e.key.toLowerCase()] = true; if(e.key===' '){ e.preventDefault(); boosting=true; } if(e.key==='Shift'){ boosting=true; } }); window.addEventListener('keyup', e=>{ if(overlayVisible()) return; keys[e.key.toLowerCase()] = false; if(e.key===' '){ boosting=false; } if(e.key==='Shift'){ boosting=false; } });

const boostBtn = document.getElementById('boostMobile'); if(boostBtn){ boostBtn.addEventListener('pointerdown', (e)=>{ if(overlayVisible()) return; boosting=true; e.preventDefault(); }); boostBtn.addEventListener('pointerup', ()=>{ boosting=false; }); boostBtn.addEventListener('pointercancel', ()=>{ boosting=false; }); boostBtn.addEventListener('touchstart', (e)=>{ if(overlayVisible()) return; boosting=true; e.preventDefault(); }, {passive:false}); boostBtn.addEventListener('touchend', ()=>{ boosting=false; }); boostBtn.addEventListener('touchcancel', ()=>{ boosting=false; }); }
let boosting=false;

// joystick handling
const joystick = document.getElementById('joystick'); const stick = document.getElementById('stick'); let usingJoy=false; let joyCenter = null; let joyPointerId = null; let lastJoyStrength = 0;
function joyPointerDown(e){ if(overlayVisible()) return; if(controlMode !== 'mobile') return; usingJoy=true; joyPointerId = e.pointerId; e.preventDefault(); const rect = joystick.getBoundingClientRect(); const mobileStyle = localStorage.getItem('mobileStyle') || 'floating';
  if(mobileStyle === 'floating'){
    // move the joystick to the touch point (center it)
    const w = rect.width, h = rect.height;
    const left = Math.max(8, Math.min(window.innerWidth - w - 8, e.clientX - w/2));
    const top = Math.max(8, Math.min(window.innerHeight - h - 8, e.clientY - h/2));
    joystick.style.left = left + 'px'; joystick.style.top = top + 'px'; joystick.style.bottom = 'auto'; joystick.style.position = 'fixed';
    joyCenter = { x: left + w/2, y: top + h/2 };
  } else {
    joyCenter = {x: rect.left+rect.width/2, y: rect.top+rect.height/2};
  }
}
function joyPointerMove(e){ if(!usingJoy) return; if(joyPointerId!=null && e.pointerId !== joyPointerId) return; e.preventDefault(); const cx = joyCenter.x, cy = joyCenter.y; const dx = Math.max(-36, Math.min(36, e.clientX - cx)); const dy = Math.max(-36, Math.min(36, e.clientY - cy)); stick.style.transform = `translate(${dx}px,${dy}px)`; pointerX = cx + dx*1.6; pointerY = cy + dy*1.6; lastJoyStrength = Math.min(1, Math.hypot(dx,dy)/36); }
function joyPointerUp(e){ if(joyPointerId!=null && e.pointerId !== joyPointerId) return; usingJoy=false; joyPointerId = null; stick.style.transform='translate(0,0)'; pointerX=null; pointerY=null; lastJoyStrength = 0; }
if(joystick){ joystick.addEventListener('pointerdown', joyPointerDown); window.addEventListener('pointermove', joyPointerMove); window.addEventListener('pointerup', joyPointerUp); }

// Gamepad connect/disconnect logs
window.addEventListener('gamepadconnected', (e)=>{ console.log('gamepad connected', e.gamepad.id); });
window.addEventListener('gamepaddisconnected', (e)=>{ console.log('gamepad disconnected', e.gamepad && e.gamepad.id); });

// Mobile settings interactions
const mobileSettingsBtn = document.getElementById('mobileSettingsBtn'); const mobileSettingsModal = document.getElementById('mobileSettingsModal');
if(mobileSettingsBtn){ mobileSettingsBtn.addEventListener('click', ()=>{ if(mobileSettingsModal) mobileSettingsModal.classList.remove('hidden'); }); }
const mobileSettingsClose = document.getElementById('mobileSettingsClose'); if(mobileSettingsClose){ mobileSettingsClose.addEventListener('click', ()=>{ if(mobileSettingsModal) mobileSettingsModal.classList.add('hidden'); // save selections
  try{ const compact = document.getElementById('compactHudChk').checked; localStorage.setItem('compactHud', compact ? '1' : '0'); const js = document.getElementById('joystickStyleSel').value; localStorage.setItem('mobileStyle', js); const z = parseFloat(document.getElementById('zoomRange').value||'1'); localStorage.setItem('cameraZoom', (z||1).toString()); // apply
  applyMobileSettings(); updateControlUI(); }catch(e){} }); }
// initialize controls in modal once DOM ready
setTimeout(()=>{ try{ const compact = localStorage.getItem('compactHud') === '1'; const chk = document.getElementById('compactHudChk'); if(chk) chk.checked = compact; const js = localStorage.getItem('mobileStyle') || 'floating'; const sel = document.getElementById('joystickStyleSel'); if(sel) sel.value = js; const zr = document.getElementById('zoomRange'); if(zr) zr.value = localStorage.getItem('cameraZoom') || '1'; }catch(e){} }, 80);

// ---------- audio ----------
const AudioContext = window.AudioContext || window.webkitAudioContext; let audioCtx=null, masterGain=null, ambGain=null;
function ensureAudio(){ if(!audioCtx){ audioCtx = new AudioContext(); masterGain = audioCtx.createGain(); masterGain.gain.value = 0.07; masterGain.connect(audioCtx.destination); ambGain = audioCtx.createGain(); ambGain.gain.value = 0.02; ambGain.connect(masterGain); const pad = audioCtx.createOscillator(); pad.type = 'sine'; pad.frequency.value = 80; const padFilter = audioCtx.createBiquadFilter(); padFilter.type = 'lowpass'; padFilter.frequency.value = 600; pad.connect(padFilter); padFilter.connect(ambGain); pad.start(); const bufferSize = 2*audioCtx.sampleRate; const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate); const data = noiseBuffer.getChannelData(0); for(let i=0;i<bufferSize;i++){ data[i] = (Math.random()*2-1)*0.02; } const nb = audioCtx.createBufferSource(); nb.buffer = noiseBuffer; nb.loop=true; const nGain = audioCtx.createGain(); nGain.gain.value = 0.01; nb.connect(nGain); nGain.connect(masterGain); nb.start(); } }
function playEat(){ if(!audioCtx) return; const now = audioCtx.currentTime; const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type='triangle'; o.frequency.setValueAtTime(700, now); o.frequency.exponentialRampToValueAtTime(330, now+0.12); g.gain.setValueAtTime(0.12, now); g.gain.exponentialRampToValueAtTime(0.001, now+0.12); o.connect(g); g.connect(masterGain); o.start(now); o.stop(now+0.14); }
function playBoost(){ if(!audioCtx) return; const now = audioCtx.currentTime; const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type='sawtooth'; o.frequency.setValueAtTime(240, now); o.frequency.exponentialRampToValueAtTime(720, now+0.12); g.gain.setValueAtTime(0.06, now); g.gain.exponentialRampToValueAtTime(0.001, now+0.12); o.connect(g); g.connect(masterGain); o.start(now); o.stop(now+0.16); }
function playDeath(){ if(!audioCtx) return; const now = audioCtx.currentTime; const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type='sawtooth'; o.frequency.setValueAtTime(240, now); o.frequency.exponentialRampToValueAtTime(40, now+0.9); g.gain.setValueAtTime(0.28, now); g.gain.exponentialRampToValueAtTime(0.001, now+0.9); o.connect(g); g.connect(masterGain); o.start(now); o.stop(now+0.95); }
function ensureAudioStarted(){ try{ ensureAudio(); } catch(e){} }

// Safe wrapper for adBreak calls (if H5 Games Ads is available)
let __adBreakWarned = false;
let __adLoading = false;
// Set to true if you want a harmless stub instead of real ads (useful for testing)
window.__enableAdStub = window.__enableAdStub || false;

// Enhanced ad debugging function
function tryAdBreak(opts){ 
  const timestamp = new Date().toISOString();
  console.log(`üéØ [${timestamp}] AD REQUEST:`, opts || {});
  
  try{
    // if the current session is offline, suppress ad calls and logs unless forced
    if(!isOnlineMode && !(opts && opts.force)){ 
      console.log(`üö´ [${timestamp}] AD BLOCKED: Offline mode - ads suppressed`); 
      if(!__adBreakWarned){ __adBreakWarned = true; }
      return; 
    }
    
    console.log(`üì° [${timestamp}] AD CHECK: H5 Games Ads availability...`);
    
    if(typeof adBreak === 'function'){
      console.log(`‚úÖ [${timestamp}] AD BREAK FUNCTION FOUND: Preparing to show ad...`);
      __adLoading = true;
      
      try{ 
        // mute audio briefly if available
        if(masterGain) {
          console.log(`üîá [${timestamp}] AUDIO: Muting for ad playback...`);
          masterGain.gain.value = 0; 
        }
      }catch(e){
        console.warn(`‚ö†Ô∏è [${timestamp}] AUDIO: Failed to mute -`, e);
      }
      
      console.log(`üé¨ [${timestamp}] AD BREAK: Calling adBreak with options:`, opts);
      
      // Set up ad completion tracking
      const originalAdBreak = window.adBreak;
      window.adBreak = function(adOpts) {
        console.log(`üé• [${timestamp}] AD STARTED: Ad break initiated`);
        console.log(`üìã [${timestamp}] AD OPTIONS:`, adOpts);
        
        return originalAdBreak.call(this, Object.assign({}, adOpts, {
          beforeAd: () => {
            console.log(`‚è≥ [${timestamp}] AD BEFORE: Ad about to show`);
            if(adOpts.beforeAd) adOpts.beforeAd();
          },
          afterAd: () => {
            console.log(`‚úÖ [${timestamp}] AD AFTER: Ad completed successfully`);
            __adLoading = false;
            if(adOpts.afterAd) adOpts.afterAd();
          },
          adBreakDone: (breakStatus) => {
            console.log(`üèÅ [${timestamp}] AD DONE: Break finished with status:`, breakStatus);
            __adLoading = false;
            // Unmute after ad completes
            setTimeout(()=>{ 
              try{ 
                if(masterGain) {
                  console.log(`üîä [${timestamp}] AUDIO: Unmuting after ad completion`);
                  masterGain.gain.value = 0.07; 
                }
              }catch(e){ 
                console.warn(`‚ö†Ô∏è [${timestamp}] AUDIO: Failed to unmute -`, e);
              } 
            }, 500);
            if(adOpts.adBreakDone) adOpts.adBreakDone(breakStatus);
          }
        }));
      };
      
      try{ adBreak(opts); }catch(e){ 
        console.error(`‚ùå [${timestamp}] AD ERROR: adBreak call failed -`, e); 
        __adLoading = false;
      }
      
      // Fallback unmute after longer delay
      setTimeout(()=>{ 
        if(__adLoading) {
          console.log(`‚è∞ [${timestamp}] AD TIMEOUT: Forcing unmute after delay`);
          __adLoading = false;
        }
        try{ 
          if(masterGain) {
            console.log(`üîä [${timestamp}] AUDIO: Fallback unmute completed`);
            masterGain.gain.value = 0.07; 
          }
        }catch(e){ 
          console.warn(`‚ö†Ô∏è [${timestamp}] AUDIO: Fallback unmute failed -`, e);
        } 
      }, 5000);
      
    } else {
      console.log(`‚ùå [${timestamp}] AD UNAVAILABLE: adBreak function not found on window`);
      // avoid spamming the console if adBreak is not present
      if(!__adBreakWarned){ 
        console.log(`üì¢ [${timestamp}] AD INFO: No H5 Games Ads available - Publisher ID may not be verified yet`); 
        __adBreakWarned = true; 
      }
      if(window.__enableAdStub){ 
        try{ console.log(`üé≠ [${timestamp}] AD STUB: Simulating ad break -`, opts||{}); }catch(e){} 
      }
    }
  }catch(e){ 
    console.error(`üí• [${timestamp}] AD CRITICAL: adBreak wrapper crashed -`, e); 
    __adLoading = false;
  } 
}

// Helper function to check ad status
function checkAdStatus(){
  const timestamp = new Date().toISOString();
  console.log(`üîç [${timestamp}] AD STATUS CHECK:`);
  console.log(`   - isOnlineMode: ${isOnlineMode}`);
  console.log(`   - adBreak function exists: ${typeof adBreak === 'function'}`);
  console.log(`   - __adBreakWarned: ${__adBreakWarned}`);
  console.log(`   - __adLoading: ${__adLoading}`);
  console.log(`   - Publisher ID: ca-pub-369539584`);
  console.log(`   - Domain: ${window.location.hostname}`);
  console.log(`   - Protocol: ${window.location.protocol}`);
  return {
    isOnlineMode,
    adBreakAvailable: typeof adBreak === 'function',
    warned: __adBreakWarned,
    loading: __adLoading
  };
}

// ---------- Firebase (compat) ----------
const firebaseConfig = {
  apiKey: "AIzaSyCK2mIqOVp1d0VV3C6dycHTvnVtaE4CspQ",
  authDomain: "aqua-odyssey.firebaseapp.com",
  databaseURL: "https://aqua-odyssey-default-rtdb.firebaseio.com",
  projectId: "aqua-odyssey",
  storageBucket: "aqua-odyssey.firebasestorage.app",
  messagingSenderId: "54640172756",
  appId: "1:54640172756:web:608837b0b971f896812541",
  measurementId: "G-ZZBZERRPCH"
};

let onlinePlayers = {}; // snapshot of /players
let remotePlayers = {}; // for mapping online players to world entities
let currentRoom = { code: null, friendsOnly: false, owner: null, center: null };

function updateConnUI(connected, pingMs=null){
  const dot = document.getElementById('connIndicator'); const text = document.getElementById('connText'); const msEl = document.getElementById('connMs');
  if(dot && text){
    if(connected){ dot.style.background='#4caf50'; text.textContent='Online'; if(msEl) msEl.textContent = pingMs ? `${Math.round(pingMs)} ms` : ''; }
    else { dot.style.background='#999'; text.textContent='Offline'; if(msEl) msEl.textContent = ''; }
  }
}

function loadBestScores(){
  if(!firebaseDB) return Promise.resolve(null);
  return firebaseDB.ref('/bestScores').once('value').then(snap=>{
    const val = snap.val() || {};
    bestScoresCache = [];
    for(const uid in val){
      const obj = val[uid];
      bestScoresCache.push({ uid, username: obj.username || 'Unknown', best: obj.best || 0, ts: obj.ts || 0 });
    }
    bestScoresCache.sort((a,b)=>b.best - a.best);
    return bestScoresCache;
  }).catch(err=>{
    console.warn('Could not load bestScores', err);
    bestScoresCache = null;
    return null;
  });
}

function ensureFirebaseConnected(){
  if(firebaseConnected) return Promise.resolve(true);
  try{
    if(typeof firebase === 'undefined') throw new Error('firebase SDK is not loaded');
    if(!firebaseApp) firebaseApp = firebase.initializeApp(firebaseConfig);
    firebaseAuth = firebase.auth();
    firebaseDB = firebase.database();
    return firebaseAuth.signInAnonymously().then(cred=>{
      firebaseUid = cred.user.uid;
      console.log('Signed into Firebase as', firebaseUid);
      const pingPath = '/ping_test/'+firebaseUid;
      const start = performance.now();
      return firebaseDB.ref(pingPath).set({ts:Date.now()}).then(()=>{
        const pingMs = performance.now() - start;
        firebaseConnected = true;
        updateConnUI(true, pingMs);
        // subscribe to players but guard against permission errors
        firebaseDB.ref('/players').on('value', snap=>{
          try{
            const val = snap.val() || {};
            onlinePlayers = val;
            syncRemotePlayers(onlinePlayers);
            rebuildLeaderboards();
          }catch(err){
            console.error('players.on error', err);
          }
        }, err=>{
          console.error('players.on error', err);
        });
        // load best scores cache
        loadBestScores();
        return true;
      }).catch(err=>{
        console.error('ping failed', err);
        firebaseConnected = false;
        updateConnUI(false);
        showToast('Could not fully connect to Firebase ‚Äî continuing in offline mode.',3800);
        return false;
      });
    }).catch(err=>{
      console.error('auth failed', err);
      firebaseConnected = false;
      updateConnUI(false);
      showToast('Firebase auth failed ‚Äî offline mode.',2200);
      return false;
    });
  } catch(e){
    console.error('firebase init error', e);
    firebaseConnected = false;
    updateConnUI(false);
    showToast('Firebase not available ‚Äî offline mode.',2000);
    return Promise.resolve(false);
  }
}

// upload player state only if username set (no Guest uploads)
function uploadPlayerState(){
  if(!firebaseConnected || !firebaseDB || !firebaseUid) return;
  if(!username || username.trim() === '' || username === 'Guest') return; // do not upload Guest or empty
  const p = { username: username || 'Guest', score: player.score||0, ts: Date.now(), size: player.size||0, x: player.x||0, y: player.y||0, room: currentRoom.code || null };
  firebaseDB.ref('/players/' + firebaseUid).set(p).catch(err=>{
    console.error('upload player failed', err);
    if(err && err.code === 'PERMISSION_DENIED'){
      updateConnUI(false);
      firebaseConnected = false;
      showToast('Firebase permission denied ‚Äî offline mode.',2200);
    }
  });
  try{
    firebaseDB.ref('/bestScores/' + firebaseUid).transaction(curr=>{
      if(!curr || (player.score || 0) > (curr.best || 0)){
        return { best: player.score || 0, username: username || 'Guest', uid: firebaseUid, ts: Date.now() };
      }
      return;
    }).catch(err=>{ console.warn('bestScores transaction failed', err); });
  }catch(e){}
}

function removePlayerOnLeave(){
  if(firebaseConnected && firebaseDB && firebaseUid){
    try{ firebaseDB.ref('/players/'+firebaseUid).remove(); }catch(e){}
  }
}
window.addEventListener('beforeunload', ()=>{ removePlayerOnLeave(); });

// also remove PIN on leave/delete
function removePinOnLeave(){
  if(firebaseConnected && firebaseDB && firebaseUid){
    try{ firebaseDB.ref('/pins/'+firebaseUid).remove(); }catch(e){}
  }
}
// call both when leaving
window.addEventListener('beforeunload', ()=>{ removePinOnLeave(); });

// ---------- remote players sync (per-room + active-only) ----------
function isSameRoomForClient(playerObj){
  const theirRoom = playerObj && (playerObj.room===undefined ? null : playerObj.room);
  const myRoom = currentRoom.code || null;
  if(myRoom === null || myRoom === undefined) {
    return (theirRoom === null || theirRoom === undefined || theirRoom === '');
  }
  return theirRoom === myRoom;
}
function syncRemotePlayers(playersObj){
  const seen = new Set();
  for(const uid in playersObj){
    if(uid === firebaseUid) continue;
    const p = playersObj[uid];
    if(!p || !p.username) continue;
    if(!isSameRoomForClient(p)) continue;
    // ensure only active players are considered (last seen threshold)
    const lastTs = p.ts || 0; const now = Date.now(); const activeThreshold = 30000; // 30s
    if(now - lastTs > activeThreshold) continue;
    seen.add(uid);
    if(remotePlayers[uid]){
      const ent = remotePlayers[uid]; ent.x = p.x !== undefined ? p.x : ent.x; ent.y = p.y !== undefined ? p.y : ent.y; ent.size = p.size || ent.size; ent.name = p.username || ent.name;
    } else {
      const ent = { id: 'rp_' + uid, x: (p.x!==undefined? p.x : player.x + (Math.random()-0.5)*300), y: (p.y!==undefined? p.y : player.y + (Math.random()-0.5)*300), size: p.size || 12, speed: 40 + Math.random()*80, angle: Math.random()*Math.PI*2, color: '#66ccff', state:'wander', name: p.username || 'Player', remoteUid: uid, isRemote:true };
      enemies.push(ent); remotePlayers[uid] = ent;
    }
  }
  for(const uid in remotePlayers){ if(!seen.has(uid)){ const ent = remotePlayers[uid]; const idx = enemies.indexOf(ent); if(idx>=0) enemies.splice(idx,1); delete remotePlayers[uid]; } }
}

// ---------- leaderboards (NO BOTS) ----------
function rebuildLeaderboards(){
  const now = Date.now();
  const activeThreshold = 30000;
  // aggregated by username (username is unique now) or include local player
  const list = [];
  for(const uid in onlinePlayers){
    const p = onlinePlayers[uid];
    if(!p || !p.username) continue;
    if(p.username === 'Guest') continue;
    if(now - (p.ts || 0) > activeThreshold) continue;
    if(!isSameRoomForClient(p)) continue;
    list.push({ username: p.username, score: p.score || 0, uid });
  }
  // include local player
  if(username && username !== 'Guest'){
    const found = list.find(x=>x.username === username);
    if(found) found.score = Math.max(found.score, player.score || 0);
    else list.push({ username, score: player.score || 0, uid: firebaseUid || '__local' });
  }
  list.sort((a,b)=>b.score - a.score);
  renderMiniLeader(list.slice(0,10));
  renderFullLeaderFullHistoric(); // keep main list updated
}

function renderMiniLeader(list){
  const miniList = document.getElementById('miniList'); if(!miniList) return;
  miniList.innerHTML = '';
  const deduped = new Map();  // Deduplicate by username
  list.forEach((p)=>{
    const key = (p.username || '').toLowerCase();
    if(!deduped.has(key) || (deduped.get(key).score || 0) < (p.score || 0)){
      deduped.set(key, p);
    }
  });
  const dedupedArray = Array.from(deduped.values()).sort((a,b)=>(b.score||0)-(a.score||0)).slice(0,10);
  dedupedArray.forEach((p, idx)=>{
    const row = document.createElement('div'); row.className='lb-row';
    const left = document.createElement('div'); left.style.fontWeight = (p.username === username) ? '800' : '600'; left.style.fontSize='13px';
    left.textContent = `${idx+1}. ${p.username}`;
    const right = document.createElement('div'); right.style.opacity=0.95; right.textContent = p.score;
    row.appendChild(left); row.appendChild(right); miniList.appendChild(row);
  });
  const myEntry = dedupedArray.find(i=>i.username === username);
  const miniYou = document.getElementById('miniYou'); if(miniYou) miniYou.textContent = myEntry ? `You: ${myEntry.score}` : `You: ${player.score||0}`;
  const miniCount = document.getElementById('miniCount'); if(miniCount) miniCount.textContent = `${dedupedArray.length}`;
}

// Full leaderboard render (uses bestScores for all)
function renderFullLeaderFullHistoric(){
  const el = document.getElementById('leaderboardList'); if(!el) return;
  el.innerHTML = '';
  const search = (document.getElementById('leaderboardSearch') && document.getElementById('leaderboardSearch').value) || '';
  const filter = (document.getElementById('leaderboardFilter') && document.getElementById('leaderboardFilter').value) || 'all';
  if(filter === 'all'){
    const showBest = (bestScoresCache && Array.isArray(bestScoresCache));
    if(!showBest){
      el.innerHTML = '<div style="padding:10px">Loading all-time best scores...</div>';
      if(firebaseConnected && firebaseDB) loadBestScores().then(()=>renderFullLeaderFullHistoric());
      return;
    }
    const deduped = new Map();  // Deduplicate by username for all-time
    bestScoresCache.forEach((p)=>{
      const key = (p.username || '').toLowerCase();
      if(!deduped.has(key) || (deduped.get(key).best || 0) < (p.best || 0)){
        deduped.set(key, p);
      }
    });
    const list = Array.from(deduped.values()).sort((a,b)=>(b.best||0)-(a.best||0)).slice(0,200).filter(x=> !search || x.username.toLowerCase().includes(search.toLowerCase()));
    for(let i=0;i<list.length;i++){
      const p = list[i];
      const r = document.createElement('div'); r.style.display='flex'; r.style.justifyContent='space-between'; r.style.padding='6px 0'; r.style.borderBottom='1px solid rgba(255,255,255,0.03)';
      const left = document.createElement('div'); left.style.fontWeight='700'; left.innerHTML = `${i+1}. ${p.username}`;
      const right = document.createElement('div'); right.style.opacity=0.95; right.textContent = p.best;
      r.appendChild(left); r.appendChild(right); el.appendChild(r);
    }
    return;
  }
  const now = Date.now();
  const activeThreshold = 30000;
  const deduped = new Map();  // Deduplicate online players by username
  for(const uid in onlinePlayers){
    const p = onlinePlayers[uid];
    if(!p || !p.username) continue;
    if(p.username === 'Guest') continue;
    if(now - (p.ts || 0) > activeThreshold) continue;
    if(filter === 'room' && !isSameRoomForClient(p)) continue;
    const key = (p.username || '').toLowerCase();
    if(!deduped.has(key) || (deduped.get(key).score || 0) < (p.score || 0)){
      deduped.set(key, { username: p.username, score: p.score || 0, uid });
    }
  }
  if(username && username !== 'Guest'){
    const key = (username || '').toLowerCase();
    const ex = deduped.get(key);
    if(ex) ex.score = Math.max(ex.score, player.score || 0);
    else deduped.set(key, { username: username, score: player.score || 0, uid: firebaseUid || '__local' });
  }
  const arr = Array.from(deduped.values()).sort((a,b)=>b.score - a.score);
  arr.slice(0,200).forEach((p,idx)=>{
    const r = document.createElement('div'); r.style.display='flex'; r.style.justifyContent='space-between'; r.style.padding='6px 0'; r.style.borderBottom='1px solid rgba(255,255,255,0.03)';
    const leftWrap = document.createElement('div'); leftWrap.style.display='flex'; leftWrap.style.alignItems='center'; leftWrap.style.gap='8px';
    const nameDiv = document.createElement('div'); nameDiv.style.fontWeight = p.username === username ? '800' : '600'; nameDiv.innerHTML = `${idx+1}. ${p.username}`;
    leftWrap.appendChild(nameDiv);
    const rightDiv = document.createElement('div'); rightDiv.style.opacity=0.95; rightDiv.textContent = p.score;
    const btnWrap = document.createElement('div'); btnWrap.style.display='flex'; btnWrap.style.gap='6px'; btnWrap.style.alignItems='center';
    if(p.username !== username){
      const specBtn = document.createElement('button'); specBtn.className='btn'; specBtn.textContent = 'Spectate'; specBtn.style.padding='6px 8px';
      specBtn.onclick = ()=>{ if(!firebaseConnected){ showToast('Connect Firebase to spectate players.'); return; }
        let targetUid = null;
        for(const uid in onlinePlayers){ const op = onlinePlayers[uid]; if(op && op.username && op.username.toLowerCase() === p.username.toLowerCase()){ targetUid = uid; break; } }
        if(!targetUid){ showToast('Player not available to spectate'); return; }
        spectatePlayer(targetUid);
      };
      btnWrap.appendChild(specBtn);
    }
    r.appendChild(leftWrap);
    const rightArea = document.createElement('div'); rightArea.style.display='flex'; rightArea.style.alignItems='center'; rightArea.style.gap='8px';
    rightArea.appendChild(rightDiv); rightArea.appendChild(btnWrap); r.appendChild(rightArea); el.appendChild(r);
  });
}

// mini search
const miniSearchEl = document.getElementById('miniSearch'); if(miniSearchEl) miniSearchEl.addEventListener('input',(e)=>{
  const q = e.target.value.toLowerCase();
  const now = Date.now(); const activeThreshold = 30000;
  const mapByName = new Map();
  for(const uid in onlinePlayers){
    const p = onlinePlayers[uid];
    if(!p || !p.username) continue;
    if(p.username === 'Guest') continue;
    if(now - (p.ts||0) > activeThreshold) continue;
    if(!isSameRoomForClient(p)) continue;
    const key = (p.username||'').toLowerCase().trim();
    const ex = mapByName.get(key);
    if(!ex) mapByName.set(key, { username: p.username, score: p.score || 0 });
    else ex.score = Math.max(ex.score, p.score||0);
  }
  if(username && username !== 'Guest') mapByName.set((username||'').toLowerCase().trim(), { username: username, score: player.score||0 });
  const merged = Array.from(mapByName.values()).filter(x=>x.username.toLowerCase().includes(q)).sort((a,b)=>b.score - a.score).slice(0,10);
  renderMiniLeader(merged);
});

// mini toggle
const miniToggle = document.getElementById('miniToggle'); if(miniToggle){ miniToggle.addEventListener('click', ()=>{
  const mini = document.getElementById('miniLeaderboard');
  if(!mini) return;
  mini.classList.toggle('small');
  const t = document.getElementById('miniToggle');
  t.textContent = mini.classList.contains('small') ? '‚ñº' : '‚ñ≤';
}); }

// find me
const findMeBtn = document.getElementById('findMeBtn'); if(findMeBtn) findMeBtn.addEventListener('click', ()=>{ const panel = document.getElementById('leaderboardPanel'); if(!panel) return; panel.classList.remove('hidden'); const homeInfoE = document.getElementById('homeInfo'); if(homeInfoE) homeInfoE.classList.add('hidden'); renderFullLeaderFullHistoric(); });

// ---------- spawning tweaks ----------
function setRandomSpawn(){ player.x = (Math.random()*2 - 1) * (WORLD_BOUND * 0.5); player.y = (Math.random()*2 - 1) * (WORLD_BOUND * 0.5); }

// ---------- update & AI ----------
function handleBounds(){ let clamped=false; if(player.x < -WORLD_BOUND){ player.x = -WORLD_BOUND; clamped=true; } if(player.x > WORLD_BOUND){ player.x = WORLD_BOUND; clamped=true; } if(player.y < -WORLD_BOUND){ player.y = -WORLD_BOUND; clamped=true; } if(player.y > WORLD_BOUND){ player.y = WORLD_BOUND; clamped=true; } if(clamped){ if(allowBots){ for(let i=0;i<2;i++) spawnEnemyRelative(player.x + randBetween(-200,200), player.y + randBetween(-200,200)); } player.hunger = Math.max(0, player.hunger - 8); } }

function update(dt){ if(!running) return;
  const nearbyCount = enemies.filter(e=>Math.hypot(e.x-player.x,e.y-player.y) < 1600).length;
  const densityFactor = Math.max(0.08, 1 - nearbyCount/80);
  const spawnSpeedFactor = player.speed < 3 ? 0.32 : 1;
  const spawnFactor = player.alive ? spawnSpeedFactor : 0.06;
  const allowSpawnBots = allowBots;
  // client-side performance multiplier (only applied to local/offline spawning and rendering)
  const clientPerfMult = (!isOnlineMode) ? (devicePerf.multiplier || 1) : 1;

  if(Math.random() < 0.18 * spawnFactor * densityFactor * clientPerfMult) spawnFoodAround(player.x, player.y);  // Increased spawn rate
  // increase enemy spawn chance moderately so maps have more bots
  // significantly increase spontaneous enemy spawns (scaled by botDensityMultiplier)
  // raise spontaneous spawn chance so maps refill faster (scaled by botDensityMultiplier)
  if(allowBots && allowSpawnBots && Math.random() < 0.24 * spawnFactor * densityFactor * botDensityMultiplier * clientPerfMult) spawnEnemyRelative(player.x, player.y);
  if(Math.random() < 0.08 * spawnFactor * densityFactor * clientPerfMult) spawnBubbleAround(player.x, player.y);
  // occasionally ensure a slightly larger predator exists so player is rarely the biggest
  // more frequently ensure a larger predator exists so player is seldom the biggest
  if(Math.random() < 0.12 * Math.max(1, botDensityMultiplier) * clientPerfMult) ensureLargerPredatorMaybe(player.x, player.y);

  let vx=0, vy=0;
  // Gamepad support: if a gamepad is connected, use left stick for movement and a button for boost
  try{
    const gp = navigator.getGamepads && navigator.getGamepads()[0];
    if(gp){
      const ax0 = gp.axes && gp.axes.length>0 ? gp.axes[0] : 0;
      const ax1 = gp.axes && gp.axes.length>1 ? gp.axes[1] : 0;
      // deadzone
      const dz = 0.12;
      if(Math.abs(ax0) > dz || Math.abs(ax1) > dz){ vx = ax0; vy = ax1; }
      // map a common button (0 or 1) to boosting
      const b0 = gp.buttons && gp.buttons[0] ? gp.buttons[0].pressed : false;
      const b1 = gp.buttons && gp.buttons[1] ? gp.buttons[1].pressed : false;
      boosting = boosting || b0 || b1;
    }
  }catch(e){ /* gamepad read failed */ }
  if(player.alive){
    if(((controlMode==='mouse') || (controlMode==='mobile')) && pointerX!=null && pointerY!=null){ const w = screenToWorld(pointerX, pointerY); vx = w.x - player.x; vy = w.y - player.y; }
    if(controlMode==='keyboard'){ if(keys['w']||keys['arrowup']) vy-=1; if(keys['s']||keys['arrowdown']) vy+=1; if(keys['a']||keys['arrowleft']) vx-=1; if(keys['d']||keys['arrowright']) vx+=1; }
    const mag = Math.hypot(vx,vy);
    if(mag>0.01){ player.angle = Math.atan2(vy, vx); const speedFactor = player.baseSpeed * (1 - Math.min(0.75, (player.size-8)/300)); let sp = speedFactor * (1 + (boosting?1.2:0)); if(controlMode==='keyboard' && boosting) sp *= 1.4; if(lastJoyStrength) sp *= Math.max(0.18, Math.min(1, lastJoyStrength)); const dx = Math.cos(player.angle) * sp * dt/1000; const dy = Math.sin(player.angle) * sp * dt/1000; player.x += dx; player.y += dy; player.speed = Math.hypot(dx,dy)/(dt/1000); if(boosting){ player.size = Math.max(8, player.size - 0.05 * dt/1000); player.hunger = Math.max(0, player.hunger - 0.12 * dt/1000); playBoost(); } } else { const dx = Math.cos(player.angle) * 8 * dt/1000; const dy = Math.sin(player.angle) * 8 * dt/1000; player.x += dx; player.y += dy; player.speed = Math.hypot(dx,dy)/(dt/1000); }
  } else { player.vx = 0; player.vy = 0; player.speed = 0; }

  handleBounds();

  const baseDecay = dt/5000 * Math.max(0.6, player.size/24);
  const movementDecay = (player.speed/80) * (dt/1000) * Math.max(0.8, player.size/24);
  // apply a slight reduction to initial hunger drain for the first seconds after spawn
  const nowTs = Date.now();
  const spawnGrace = (player.spawnInvulnerableUntil && nowTs < player.spawnInvulnerableUntil) ? 0.45 : 1;
  player.hunger -= (baseDecay + movementDecay) * spawnGrace;
  if(ui.hungerEl) ui.hungerEl.style.width = Math.max(0, player.hunger) + '%';
  if(player.hunger <= 0 && player.alive){ if(!player.spawnInvulnerableUntil || nowTs > player.spawnInvulnerableUntil){ player.alive=false; if(!deathHandled){ deathHandled=true; cameraFrozen = true; deathSequence(); playDeath(); } } else { player.hunger = 2; } }

  for(const f of foods) f.wobble += 0.02 * dt/16;
  for(let i=bubbles.length-1;i>=0;i--){ const b=bubbles[i]; b.y -= b.vy * dt/1000; if(Math.hypot(b.x-player.x,b.y-player.y)>8000) bubbles.splice(i,1); }

  for(const e of enemies){
    if(e.isRemote){
      e.x += Math.cos(e.angle) * (e.speed*0.05) * dt/1000; e.y += Math.sin(e.angle) * (e.speed*0.05) * dt/1000; if(Math.random()<0.008) e.angle += (Math.random()-0.5)*1.2; continue;
    }
    e.hunger = (e.hunger||100) - dt/12000 * (e.size/24);
    let prey=null; let preyDist=1e9;
    let threat=null; let threatDist=1e9;
    const dToPlayer = Math.hypot(player.x-e.x,player.y-e.y);
    if(player.alive){ if(player.size <= e.size * 1.05 && dToPlayer < preyDist){ prey = {type:'player',ref:player,x:player.x,y:player.y,size:player.size}; preyDist = dToPlayer; } if(player.size > e.size * 1.05 && dToPlayer < threatDist){ threat = {type:'player',ref:player,x:player.x,y:player.y,size:player.size}; threatDist = dToPlayer; } }
    for(const other of enemies){ if(other===e) continue; const d = Math.hypot(other.x-e.x, other.y-e.y); if(other.size <= e.size * 1.05 && d < preyDist){ prey = {type:'enemy',ref:other,x:other.x,y:other.y,size:other.size}; preyDist = d; } if(other.size > e.size * 1.05 && d < threatDist){ threat = {type:'enemy',ref:other,x:other.x,y:other.y,size:other.size}; threatDist = d; } }
    if(threat && threatDist < 420){ e.state='flee'; const ang = Math.atan2(e.y - threat.y, e.x - threat.x); e.x += Math.cos(ang) * (e.speed*0.9) * dt/1000; e.y += Math.sin(ang) * (e.speed*0.9) * dt/1000; e.angle = ang;
    } else if(prey){ e.state='hunt'; const ang = Math.atan2(prey.y - e.y, prey.x - e.x); e.x += Math.cos(ang) * e.speed * dt/1000; e.y += Math.sin(ang) * e.speed * dt/1000; e.angle = ang; for(const ally of enemies){ if(ally!==e && Math.hypot(ally.x-e.x, ally.y-e.y) < 450 && (!ally.target || ally.target.size < prey.size)) ally.target = prey; }
    } else { e.state='wander'; e.x += Math.cos(e.angle) * (e.speed*0.18) * dt/1000; e.y += Math.sin(e.angle) * (e.speed*0.18) * dt/1000; if(Math.random()<0.01) e.angle += (Math.random()-0.5)*1.2; }
  }

  for(let i=foods.length-1;i>=0;i--){ const f=foods[i]; const d=Math.hypot(player.x-f.x,player.y-f.y); if(d < player.size + f.size*0.7){ foods.splice(i,1); player.size += f.size*0.08; player.score += 1; player.coins += 1; player.hunger = Math.min(100, player.hunger + 6); playEat(); } }
  for(let i=enemies.length-1;i>=0;i--){ const e=enemies[i]; const d=Math.hypot(player.x-e.x,player.y-e.y); if(d < player.size + e.size*0.6){ if(e.size > player.size * 1.05){ // enemy would eat player
      const nowTs = Date.now();
      if(!player.spawnInvulnerableUntil || nowTs > player.spawnInvulnerableUntil){ if(player.alive){ player.alive=false; if(!deathHandled){ deathHandled=true; cameraFrozen = true; deathSequence(); playDeath(); } } } else {
        // during spawn grace, nudge player away slightly instead of instant death
        const ang = Math.atan2(player.y - e.y, player.x - e.x);
        player.x += Math.cos(ang) * 18; player.y += Math.sin(ang) * 18;
      }
    } else if(player.size > e.size * 1.05){ player.size += e.size*0.18; player.score += Math.round(e.size/6); player.coins += Math.round(e.size/8); enemies.splice(i,1); playEat(); } } }
  // Prevent being instantly eaten by nearby enemies immediately after spawning
  // (apply spawn invulnerability check when comparing sizes for death)

  for(let i=enemies.length-1;i>=0;i--){ for(let j=enemies.length-1;j>=0;j--){ if(i===j) continue; const a=enemies[i], b=enemies[j]; const d=Math.hypot(a.x-b.x,a.y-b.y); if(d < a.size + b.size){ if(a.size > b.size * 1.05){ a.size += b.size*0.14; enemies.splice(j,1); if(j<i) i--; break; } } } }

  // keep world manageable
  const R = Math.max(window.innerWidth, window.innerHeight) * 4; foods = foods.filter(f=>Math.hypot(f.x-player.x,f.y-player.y) < R); enemies = enemies.filter(e=>Math.hypot(e.x-player.x,e.y-player.y) < R*1.5); bubbles = bubbles.filter(b=>Math.hypot(b.x-player.x,b.y-player.y) < R);

  const depthSigned = -Math.round(player.y);
  const sign = depthSigned >= 0 ? '+' : '-';
  if(ui.depthEl) ui.depthEl.textContent = `${sign}${Math.abs(depthSigned)} m`;
  const maxDepth = 3000; const pct = Math.min(1, Math.max(0, depthSigned) / maxDepth);
  if(ui.depthFill) ui.depthFill.style.height = `${Math.max(4, pct*100)}%`;

  if(ui.sizeEl) ui.sizeEl.textContent = player.size.toFixed(1);
  if(ui.scoreEl) ui.scoreEl.textContent = player.score;
  const highKey = 'aqua_highscore_' + (localStorage.getItem('playerName')||'Guest');
  let high = parseInt(localStorage.getItem(highKey) || '0',10); if(player.score > high){ high = player.score; localStorage.setItem(highKey, high); }
  if(ui.highEl) ui.highEl.textContent = high;
  if(ui.coinsEl) ui.coinsEl.textContent = player.coins;

  // update coords/spectate display
  if(spectatingUid && spectateModeEnabled && remotePlayers[spectatingUid]){
    const target = remotePlayers[spectatingUid];
    if(target) ui.coordsDisplay.textContent = `${Math.round(target.x||0)}, ${Math.round(target.y||0)} (${target.name||spectatingUid})`;
  } else { ui.coordsDisplay.textContent = `${Math.round(player.x)}, ${Math.round(player.y)}`; }

  // occasional uploads & rebuild leaderboard (increased sync frequency for account data)
  if(firebaseConnected && Math.random() < 0.15) uploadPlayerState();
  if(Math.random() < 0.06) rebuildLeaderboards();
}

// ---------- rendering ----------
function updateCamera(dt){
  // base scale depends on player size (bigger = zoom out)
  const baseScale = (28) / (player.size + 6);
  // Use canvas actual size (CSS pixels) so the view fills the available canvas area in any orientation
  const cssW = (canvas.width || window.innerWidth * DPR) / DPR;
  const cssH = (canvas.height || window.innerHeight * DPR) / DPR;
  // use the smaller screen dimension so portrait devices see enough horizontal world too
  const minDim = Math.min(cssW, cssH);
  const screenFactor = Math.min(1, minDim / 720);
  const targetRaw = Math.max(0.14, Math.min(1.6, baseScale * screenFactor));
  const target = targetRaw * (camera.userZoomFactor || 1);
  camera.scale += (target - camera.scale) * 0.14;
  const vw = cssW / camera.scale, vh = cssH / camera.scale;
  if(cameraFrozen){
    camera.x = player.x - vw/2; camera.y = player.y - vh/2;
  } else if(spectatingUid && spectateModeEnabled){
    const remote = remotePlayers[spectatingUid] || onlinePlayers[spectatingUid];
    if(remote && typeof remote.x === 'number'){
      camera.x += ((remote.x - vw/2) - camera.x) * 0.12; camera.y += ((remote.y - vh/2) - camera.y) * 0.12; return;
    }
    camera.x = player.x - vw/2; camera.y = player.y - vh/2;
  } else {
    camera.x = player.x - vw/2; camera.y = player.y - vh/2;
  }
}
function clear(){ ctx.clearRect(0,0,canvas.width/ DPR, canvas.height/ DPR); }
function worldToScreen(wx,wy){ return { x: (wx - camera.x) * camera.scale, y: (wy - camera.y) * camera.scale }; }
function hexToRgb(hex){ hex = hex.replace('#',''); const num = parseInt(hex,16); return { r:(num>>16)&255, g:(num>>8)&255, b:num&255 }; }
function rgbToHex(r,g,b){ return '#'+((1<<24)+(Math.round(r)<<16)+(Math.round(g)<<8)+Math.round(b)).toString(16).slice(1); }
function mixColors(c1,c2,t){ const a=hexToRgb(c1); const b=hexToRgb(c2); const r=a.r + (b.r-a.r)*t; const g=a.g + (b.g-a.g)*t; const bl=a.b + (b.b-a.b)*t; return rgbToHex(r,g,bl); }
function displayColorForFish(f){ const base = f.color || '#ff9a66'; const yellow = '#fff59d'; const red = '#ff6b6b'; const ratio = (f.size - player.size) / Math.max(1, player.size); const t = Math.min(1, Math.abs(ratio) ); if(f === player) return base; if(f.size < player.size){ return mixColors(base, yellow, Math.min(1, t*1.1)); } else { return mixColors(base, red, Math.min(1, t*1.1)); } }
function drawFish(x,y,r,angle,opts={color:'#ff9a66',eye:'#0b1b2b'}, entityRef=null){ ctx.save(); const s = worldToScreen(x,y); ctx.translate(s.x, s.y); ctx.rotate(angle); const rr = r * camera.scale; ctx.beginPath(); ctx.ellipse(0,0,rr*1.25, rr, 0,0,Math.PI*2); const fillC = entityRef ? displayColorForFish(entityRef) : opts.color; ctx.fillStyle = fillC; ctx.fill(); ctx.beginPath(); ctx.moveTo(-rr*0.9,0); ctx.lineTo(-rr*1.7,-rr*0.7); ctx.lineTo(-rr*1.7,rr*0.7); ctx.closePath(); ctx.fillStyle = shade(fillC,-12); ctx.fill(); ctx.beginPath(); ctx.moveTo(rr*0.2,-rr*0.7); ctx.quadraticCurveTo(rr*0.6,-rr*1.4,rr*1.1,-rr*0.6); ctx.closePath(); ctx.fillStyle = shade(fillC,6); ctx.fill(); ctx.beginPath(); ctx.arc(rr*0.6,-rr*0.15, Math.max(2, rr*0.18),0,Math.PI*2); ctx.fillStyle = opts.eye; ctx.fill(); ctx.beginPath(); ctx.arc(rr*0.68,-rr*0.15, Math.max(1.2, rr*0.08),0,Math.PI*2); ctx.fillStyle = '#fff'; ctx.fill(); ctx.restore();
  const screen = worldToScreen(x,y);
  ctx.save(); ctx.font = `${Math.max(10,12*camera.scale)}px system-ui`; ctx.textAlign='center'; ctx.textBaseline='bottom'; ctx.lineWidth=3; if(entityRef === player){ if(player.speed < 8){ ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.fillStyle = '#ffffff'; ctx.strokeText(username, screen.x, screen.y - (rr*1.2)); ctx.fillText(username, screen.x, screen.y - (rr*1.2)); } } else if(entityRef && entityRef.name){ ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.fillStyle = '#fff'; ctx.strokeText(entityRef.name, screen.x, screen.y - (rr*1.2)); ctx.fillText(entityRef.name, screen.x, screen.y - (rr*1.2)); } ctx.restore(); }
function drawFood(f){ const t = performance.now()/600 + f.wobble; const wig = Math.sin(t)*2; drawFish(f.x, f.y + wig, f.size, Math.sin(t)*0.6 + Math.PI/6, {color:f.color, eye:'#222'}, f); }
function drawEnemy(e){ drawFish(e.x, e.y, e.size, e.angle, {color:e.color, eye:'#000'}, e); }
function drawBubble(b){ const s = worldToScreen(b.x,b.y); ctx.beginPath(); ctx.arc(s.x, s.y, b.r * camera.scale, 0, Math.PI*2); ctx.fillStyle = `rgba(255,255,255,${b.alpha})`; ctx.fill(); ctx.strokeStyle = `rgba(255,255,255,${Math.min(0.4,b.alpha)})`; ctx.stroke(); }
function shade(hex,percent){ const c = hex.replace('#',''); const num = parseInt(c,16); let r=(num>>16)+Math.round(255*percent/100); let g=((num>>8)&0x00FF)+Math.round(255*percent/100); let b=(num&0x0000FF)+Math.round(255*percent/100); r=Math.max(0,Math.min(255,r)); g=Math.max(0,Math.min(255,g)); b=Math.max(0,Math.min(255,b)); return '#'+((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1); }

function renderBackground(){ const w = canvas.width/DPR, h = canvas.height/DPR; const g = ctx.createLinearGradient(0,0,0,h); g.addColorStop(0,getComputedStyle(document.documentElement).getPropertyValue('--bg-top').trim()||'#7ee8fa'); g.addColorStop(1,getComputedStyle(document.documentElement).getPropertyValue('--bg-bottom').trim()||'#0b2f55'); ctx.fillStyle = g; ctx.fillRect(0,0,w,h); }

function render(){ clear(); renderBackground(); updateCamera(16);
  // limit drawn entities on low-end devices: prioritize those closest to player
  try{
    const perfMult = devicePerf.multiplier || 1;
    const enemyLimit = Math.max(40, Math.round((devicePerf.entityDrawLimit || 200) * perfMult));
    const foodLimit = Math.max(60, Math.round(200 * perfMult));
    const bubbleLimit = Math.max(40, Math.round(120 * perfMult));
    const sortedEnemies = enemies.slice().sort((a,b)=>Math.hypot(a.x-player.x,a.y-player.y)-Math.hypot(b.x-player.x,b.y-player.y));
    const drawEnemies = sortedEnemies.slice(0, enemyLimit);
    const sortedFoods = foods.slice().sort((a,b)=>Math.hypot(a.x-player.x,a.y-player.y)-Math.hypot(b.x-player.x,b.y-player.y));
    const drawFoods = sortedFoods.slice(0, foodLimit);
    const drawBubbles = bubbles.slice(0, bubbleLimit);
    for(const f of drawFoods) drawFood(f);
    for(const e of drawEnemies) drawEnemy(e);
    for(const b of drawBubbles) drawBubble(b);
  }catch(e){ // fallback: draw all
    for(const f of foods) drawFood(f);
    for(const e of enemies) drawEnemy(e);
    for(const b of bubbles) drawBubble(b);
  }
  drawFish(player.x, player.y, player.size, player.angle, {color:player.color, eye:player.eyeColor}, player);
}

// ---------- death ----------
function deathSequence(){
  const startSize = player.size; const dur = 1200; const t0 = performance.now();
  function anim(){
    const t = performance.now() - t0; const p = Math.min(1, t/dur); player.size = startSize * (1 - p);
    clear(); render(); ctx.save(); ctx.globalAlpha = p*0.9; ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.fillRect(0,0,canvas.width/DPR,canvas.height/DPR); ctx.restore();
    if(p < 1) requestAnimationFrame(anim);
    else {
      console.log(`üíÄ [${new Date().toISOString()}] GAME OVER: Triggering ad for game over`);
      try{ tryAdBreak({ 
        type: 'start', 
        name: 'game-over',
        beforeAd: () => {
          console.log(`üì∫ [${new Date().toISOString()}] GAMEOVER AD: Starting ad on game over`);
          showToast('Watch this ad to continue...', 3000);
        },
        afterAd: () => {
          console.log(`‚úÖ [${new Date().toISOString()}] GAMEOVER AD: Completed`);
        }
      }); }catch(e){ 
        console.error(`üí• [${new Date().toISOString()}] GAMEOVER AD ERROR: Failed to show game over ad -`, e); 
      }
      const overlayE = document.getElementById('overlay'); if(overlayE) overlayE.classList.remove('hidden');
      const hi = document.getElementById('homeInfo'); if(hi) hi.innerHTML = `<h3>You Died</h3><p>Score: ${player.score} ‚Äî press Start to reset.</p>`;
      const shopPanel = document.getElementById('shopPanel'); if(shopPanel) shopPanel.classList.add('hidden');
        // ensure the player's last state (including username) is uploaded and leaderboards refreshed
        try{ uploadPlayerState(); }catch(e){}
        try{ rebuildLeaderboards(); }catch(e){}
        try{ if(ui.usernameDisplay) ui.usernameDisplay.textContent = username || 'Guest'; }catch(e){}
    }
  }
  requestAnimationFrame(anim);
}

// ---------- main loop ----------
function mainLoop(now){ if(!running) return; const dt = Math.min(60, now - lastTime); update(dt); render(); lastTime = now; fpsTimer += dt; fpsCounter++; if(fpsTimer >= 500){ if(ui.fpsEl) ui.fpsEl.textContent = Math.round(fpsCounter / (fpsTimer/1000)); fpsTimer = 0; fpsCounter = 0; } requestAnimationFrame(mainLoop); }

// ---------- rooms ----------
function generateRoomCode(){ const chars='ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; let out=''; for(let i=0;i<6;i++) out += chars.charAt(Math.floor(Math.random()*chars.length)); return out; }
const generateRoomBtn = document.getElementById('generateRoomBtn'); if(generateRoomBtn) generateRoomBtn.addEventListener('click', ()=>{ const roomInput = document.getElementById('roomCodeInput'); if(roomInput) roomInput.value = generateRoomCode(); });

function createRoom(code, allowBotsFlag){
  code = (code||'').trim().toUpperCase();
  if(!firebaseConnected || !firebaseDB || !firebaseUid){ showToast('Connect to Firebase first to create a room.'); return Promise.resolve(false); }
  if(!code || code.length < 3){ showToast('Room code must be at least 3 characters.'); return Promise.resolve(false); }
  const ref = firebaseDB.ref('/rooms/' + code);
  return ref.once('value').then(snap=>{
    if(snap.exists()){ showToast('Room code already exists, generate another.'); return false; }
    const center = { x: player.x, y: player.y };
    // set an expiry timestamp 2 minutes from now; clients will attempt cleanup if empty
    const expiry = Date.now() + 120000;
    const roomData = { owner: firebaseUid, created: Date.now(), friendsOnly: !allowBotsFlag, center: center, allowBots: !!allowBotsFlag, expiresAt: expiry };
    return ref.set(roomData).then(()=>{
      showToast('Room created: ' + code, 2200);
      currentRoom = { code, friendsOnly: !allowBotsFlag, owner: firebaseUid, center: center };
      allowBots = !!allowBotsFlag;
        // ensure some bots when a room is created with bots allowed
        if(allowBots){ setTimeout(()=>{ ensureBotPopulation(60); }, 120); }
      // upload player with new room and coords so they are visible immediately
      if(firebaseConnected && firebaseDB){
        try{ firebaseDB.ref('/players/' + firebaseUid).update({ room: code, x: player.x, y: player.y, ts: Date.now(), username: username || 'Guest', score: player.score || 0 }); }catch(e){ console.warn('failed to upload after createRoom', e); }
      }
      uploadPlayerState();
      // Creator reward: offer a rewarded ad immediately (only online)
      console.log(`üè† [${new Date().toISOString()}] ROOM CREATED: Triggering rewarded ad for room creator`);
      try{ tryAdBreak({ 
        type: 'reward', 
        name: 'create-room-reward',
        beforeAd: () => {
          console.log(`üéÅ [${new Date().toISOString()}] REWARD AD: Starting - User must watch to continue`);
          showToast('Watch the ad to get your room creation reward!', 3000);
        },
        afterAd: () => {
          console.log(`üéâ [${new Date().toISOString()}] REWARD AD: Completed - Reward granted`);
          showToast('Thank you! Room creation reward granted!', 2000);
        }
      }); }catch(e){ 
        console.error(`üí• [${new Date().toISOString()}] ROOM AD ERROR: Failed to show reward ad -`, e); 
      }
      // show a simple countdown in the home info so creator sees expiry and a Join button
      try{
        const hi = document.getElementById('homeInfo'); if(hi){
          let remaining = Math.max(0, Math.floor((expiry - Date.now())/1000));
          hi.innerHTML = `<div><strong>Room ${code} created.</strong><div id="roomCountdown">Expires in ${Math.floor(remaining/60)}:${('0'+(remaining%60)).slice(-2)}</div><div style="margin-top:8px"><button id="joinCreatedRoomBtn" class="primary">Join Room Now</button></div></div>`;
          const btn = document.getElementById('joinCreatedRoomBtn'); if(btn){ btn.addEventListener('click', ()=>{ joinRoom(code).then(ok=>{ if(ok){ const overlayE = document.getElementById('overlay'); if(overlayE) overlayE.classList.add('hidden'); startGame(true, allowBotsFlag); } }); }); }
          const timerId = setInterval(()=>{ remaining = Math.max(0, Math.floor((expiry - Date.now())/1000)); const el = document.getElementById('roomCountdown'); if(el) el.textContent = `Expires in ${Math.floor(remaining/60)}:${('0'+(remaining%60)).slice(-2)}`; if(remaining<=0){ clearInterval(timerId); const el2 = document.getElementById('roomCountdown'); if(el2) el2.textContent = 'Expired'; }
          }, 1000);
          // store timer so we can clear later if needed
          window.__roomExpiryTimers = window.__roomExpiryTimers || {}; window.__roomExpiryTimers[code] = timerId;
        }
      }catch(e){}
      // schedule cleanup: after 2 minutes, if no players in the room, remove it
      try{ setTimeout(()=>{ try{ firebaseDB.ref('/players').orderByChild('room').equalTo(code).once('value').then(snap=>{ const players = snap.val() || {}; if(Object.keys(players).length === 0){ try{ ref.remove(); showToast('Room ' + code + ' expired (no players).'); }catch(e){ console.warn('failed to remove expired room', e); } } else { try{ ref.update({ expiresAt: null }); }catch(e){} } }); }catch(e){ console.warn('room expiry check failed', e); } }, 120000); }catch(e){}
      return true;
    }).catch(err=>{
      console.error('createRoom failed', err);
      showToast('Could not create room: ' + (err && err.message ? err.message : 'unknown'));
      return false;
    });
  }).catch(err=>{
    console.error('createRoom check failed', err);
    showToast('Could not check room: ' + (err && err.message ? err.message : 'unknown'));
    return false;
  });
}

function joinRoom(code){
  code = (code||'').trim().toUpperCase();
  if(!firebaseConnected || !firebaseDB || !firebaseUid){ showToast('Connect to Firebase first to join a room.'); return Promise.resolve(false); }
  if(!code){ showToast('Enter a valid room code.'); return Promise.resolve(false); }
  const ref = firebaseDB.ref('/rooms/' + code);
  return ref.once('value').then(snap=>{
    if(!snap.exists()){ showToast('Room not found: ' + code, 2200); return false; }
    const obj = snap.val();
    currentRoom = { code, friendsOnly: !!obj.friendsOnly, owner: obj.owner||null, center: obj.center || null };
    allowBots = (obj.allowBots !== undefined) ? !!obj.allowBots : !currentRoom.friendsOnly;  // Use explicit allowBots field
    if(currentRoom.center && typeof currentRoom.center.x === 'number' && typeof currentRoom.center.y === 'number'){
      // Spawn near room center
      const offset = 150 + Math.random()*100;
      const angle = Math.random() * Math.PI * 2;
      player.x = currentRoom.center.x + Math.cos(angle) * offset;
      player.y = currentRoom.center.y + Math.sin(angle) * offset;
    } else {
      setRandomSpawn();
    }
    // Clear existing enemies when joining a room with no bots
    if(!allowBots){
      enemies = enemies.filter(e => e.isRemote); // Keep only remote players
    } else {
      // bring up a small bot population when joining a room that allows bots
      setTimeout(()=>{ ensureBotPopulation(8); }, 120);
    }
    // upload immediately so others see you
    if(firebaseConnected && firebaseDB){
      try{ firebaseDB.ref('/players/' + firebaseUid).update({ room: code, x: player.x, y: player.y, ts: Date.now(), username: username || 'Guest', score: player.score || 0 }); }catch(e){ console.warn('failed to upload after joinRoom', e); }
    }
    uploadPlayerState();
    
    // Show ad when joining a room
    console.log(`üö™ [${new Date().toISOString()}] ROOM JOINED: Triggering ad for room join`);
    try{ tryAdBreak({ 
      type: 'start', 
      name: 'join-room',
      beforeAd: () => {
        console.log(`üì∫ [${new Date().toISOString()}] JOIN AD: Starting ad before room entry`);
        showToast('Please watch this ad to join the room...', 3000);
      },
      afterAd: () => {
        console.log(`‚úÖ [${new Date().toISOString()}] JOIN AD: Completed - Room joined successfully`);
        showToast('Welcome to the room!', 2000);
      }
    }); }catch(e){ 
      console.error(`üí• [${new Date().toISOString()}] JOIN AD ERROR: Failed to show join ad -`, e); 
    }
    
    showToast('Joined room: ' + code + (allowBots ? ' (with bots)' : ' (no bots)'), 1800);
    return true;
  }).catch(err=>{
    console.error('joinRoom failed', err);
    showToast('Could not join room: ' + (err && err.message ? err.message : 'unknown'));
    return false;
  });
}

const createRoomBtn = document.getElementById('createRoomBtn'); if(createRoomBtn) createRoomBtn.addEventListener('click', ()=>{
  const input = document.getElementById('roomCodeInput'); const code = (input && input.value || '').trim().toUpperCase();
  if(!code || code.length < 3){ showToast('Enter a room code (3-6 chars) or generate one.'); return; }
  const allowBotsFlag = !!document.getElementById('allowBotsSwitch').checked;
  ensureFirebaseConnected().then(ok=>{
    if(ok) createRoom(code, allowBotsFlag).then(ok2=>{ if(ok2) { showToast('Room created ‚Äî you can join it from the UI when ready.', 3200); /* do NOT auto-join: creator may join later via Join Room */ } });
  });
});
const joinRoomBtn = document.getElementById('joinRoomBtn'); if(joinRoomBtn) joinRoomBtn.addEventListener('click', ()=>{
  const input = document.getElementById('roomCodeInput'); const code = (input && input.value || '').trim().toUpperCase();
  if(!code){ showToast('Enter a room code to join.'); return; }
  ensureFirebaseConnected().then(ok=>{ if(ok) joinRoom(code).then(ok2=>{ if(ok2){ const overlayE = document.getElementById('overlay'); if(overlayE) overlayE.classList.add('hidden'); startGame(true, allowBots); } }); });
});

// ---------- UI & start ----------
const startOfflineBtn = document.getElementById('startOfflineBtn'); if(startOfflineBtn) startOfflineBtn.addEventListener('click', ()=>{ startGame(false, true); });
const startOnlineBtn = document.getElementById('startOnlineBtn'); if(startOnlineBtn) startOnlineBtn.addEventListener('click', ()=>{ startGame(true, true); });
const startOnlineNoBotsBtn = document.getElementById('startOnlineNoBots'); if(startOnlineNoBotsBtn) startOnlineNoBots.addEventListener('click', ()=>{ startGame(true, false); });
const fbSetupBtn = document.getElementById('fbSetupBtn'); if(fbSetupBtn) fbSetupBtn.addEventListener('click', ()=>{ ensureFirebaseConnected().then(ok=>{ if(ok){ showToast('Firebase connected'); } else showToast('Failed to connect to Firebase'); }); });
const infoBtn = document.getElementById('infoBtn'); if(infoBtn) infoBtn.addEventListener('click', ()=>{ const hi = document.getElementById('homeInfo'); if(hi) hi.classList.remove('hidden'); const shopPanel = document.getElementById('shopPanel'); if(shopPanel) shopPanel.classList.add('hidden'); const lbPanel = document.getElementById('leaderboardPanel'); if(lbPanel) lbPanel.classList.add('hidden'); });
const shopBtn = document.getElementById('shopBtn'); if(shopBtn) shopBtn.addEventListener('click', ()=>{ const hi = document.getElementById('homeInfo'); if(hi) hi.classList.add('hidden'); const shopPanel = document.getElementById('shopPanel'); if(shopPanel) shopPanel.classList.remove('hidden'); renderShop(document.getElementById('shopSearch')?document.getElementById('shopSearch').value:'', document.getElementById('shopSort')?document.getElementById('shopSort').value:'price-asc'); });
const leaderboardBtn = document.getElementById('leaderboardBtn'); if(leaderboardBtn) leaderboardBtn.addEventListener('click', ()=>{ const hi = document.getElementById('homeInfo'); if(hi) hi.classList.add('hidden'); const lbPanel = document.getElementById('leaderboardPanel'); if(lbPanel) lbPanel.classList.remove('hidden'); renderFullLeaderFullHistoric(); });

// spectate
let spectatingUid = null; let spectateModeEnabled = false;
const spectateToggleBtn = document.getElementById('spectateToggleBtn'); if(spectateToggleBtn) spectateToggleBtn.addEventListener('click', ()=>{ spectateModeEnabled = !spectateModeEnabled; if(spectateToggleBtn) spectateToggleBtn.textContent = spectateModeEnabled ? 'Spectate: ON' : 'Spectate Mode'; if(!spectateModeEnabled){ spectatingUid = null; showToast('Spectate mode disabled'); } });
function spectatePlayer(uid){ if(!firebaseConnected){ showToast('Connect to Firebase to spectate'); return; } if(uid === firebaseUid){ showToast('Cannot spectate yourself'); return; } const target = onlinePlayers[uid]; if(!target){ showToast('Player not available to spectate'); return; } if(!isSameRoomForClient(target)){ showToast('Player is not in your room / public area'); return; } spectatingUid = uid; spectateModeEnabled = true; if(spectateToggleBtn) spectateToggleBtn.textContent = 'Spectate: ON'; showToast('Now spectating ' + (target.username || uid), 2200); }

// username handling
const usernameInput = document.getElementById('usernameInput'); const setNameBtn = document.getElementById('setNameBtn'); const nameErr = document.getElementById('nameErr');
let username = localStorage.getItem('playerName') || 'Guest'; if(ui.usernameDisplay) ui.usernameDisplay.textContent = username; if(usernameInput) usernameInput.value = (username==='Guest' ? '' : username);

// Disable set pin button if no username
function updateSetPinButton(){
  const setPinBtn = document.getElementById('setPinBtn');
  if(setPinBtn){
    if(!username || username === 'Guest'){
      setPinBtn.disabled = true;
      setPinBtn.style.opacity = '0.5';
      setPinBtn.style.pointerEvents = 'none';
      setPinBtn.title = 'Set a username first';
    } else {
      setPinBtn.disabled = false;
      setPinBtn.style.opacity = '';
      setPinBtn.style.pointerEvents = '';
      setPinBtn.title = '';
    }
  }
}
updateSetPinButton();
const BANNED = ['fuck','shit','bitch','cunt','asshole','dick','bastard','damn','whore','motherfucker','nigger','faggot'];
function normalizeName(s){ s = s.toLowerCase(); const map = { '0':'o','1':'i','3':'e','4':'a','5':'s','7':'t','@':'a','$':'s' }; let out=''; for(const ch of s){ if(map[ch]) out += map[ch]; else if(/[a-z0-9]/.test(ch)) out += ch; } return out; }
function levenshtein(a,b){ if(a===b) return 0; const m=a.length, n=b.length; const dp = Array.from({length:m+1},(_,i)=>Array(n+1).fill(0)); for(let i=0;i<=m;i++) dp[i][0]=i; for(let j=0;j<=n;j++) dp[0][j]=j; for(let i=1;i<=m;i++){ for(let j=1;j<=n;j++){ const cost = a[i-1]===b[j-1]?0:1; dp[i][j] = Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+cost); } } return dp[m][n]; }
function isNameAllowed(raw){ if(!raw || raw.trim().length<2) return {ok:false,reason:'Name too short'}; if(raw.length>20) return {ok:false,reason:'Name too long'}; if(/[!@#\$%\^&*\(\)\+={}\[\]|\;:'"<>,\?~`]/.test(raw)) return {ok:false,reason:'Name contains invalid symbols'}; const norm = normalizeName(raw); for(const bad of BANNED){ if(norm.includes(bad)) return {ok:false,reason:'Name contains disallowed word'}; const dist = levenshtein(norm, bad); if(dist <= 1) return {ok:false,reason:'Name contains disallowed or obfuscated word'}; } return {ok:true}; }

async function checkUsernameUnique(val){
  if(!firebaseConnected || !firebaseDB) return { ok: true, warning: 'Firebase offline ‚Äî cannot verify username uniqueness' };
  // query players where username == val
  try{
    const snap = await firebaseDB.ref('/players').orderByChild('username').equalTo(val).once('value');
    const found = snap.val() || {};
    for(const uid in found){
      if(uid === firebaseUid) continue; // same user is fine
      return { ok:false, reason:'Username already taken by another player' };
    }
    return { ok:true };
  }catch(e){
    console.warn('username uniqueness check failed', e);
    return { ok:true, warning: 'Could not verify uniqueness (server error)' };
  }
}

if(setNameBtn){ setNameBtn.addEventListener('click', async ()=>{ const val = (usernameInput && usernameInput.value || '').trim(); const ok = isNameAllowed(val); if(!ok.ok){ if(nameErr) nameErr.textContent = ok.reason; return; } if(!firebaseConnected){ // attempt to connect but allow if fail
    const connected = await ensureFirebaseConnected().catch(()=>false);
    if(!connected){
      // fallback: accept name locally but warn user
      username = val; localStorage.setItem('playerName', username); if(ui.usernameDisplay) ui.usernameDisplay.textContent = username; if(nameErr) nameErr.textContent=''; showToast('Name set locally (not verified). Connect Firebase to reserve it.',4000); uploadPlayerState(); return;
    }
  }
  const unique = await checkUsernameUnique(val);
  if(!unique.ok){ if(nameErr) nameErr.textContent = unique.reason; return; }
  username = val; localStorage.setItem('playerName', username); if(ui.usernameDisplay) ui.usernameDisplay.textContent = username; if(nameErr) nameErr.textContent=''; showToast('Username accepted: ' + username, 1800);
  updateSetPinButton();
  // upload state right away (so others see your name)
  if(firebaseConnected && firebaseDB && firebaseUid){
    try{ await firebaseDB.ref('/players/' + firebaseUid).update({ username: username, ts: Date.now() }); }catch(e){ console.warn('failed to update username in firebase', e); }
  }
  uploadPlayerState();
}); }

// ---------- PIN modal & persistence (4-6 digit PIN) ----------
const PIN_MIN = 4, PIN_MAX = 6;
let pinValue = '';
let pinKeyboardMode = null; // 'pin' or 'login'
let pinActiveIndex = 0;
function openPinModal(){ const modal = document.getElementById('pinModal'); if(!modal) return; pinValue=''; pinKeyboardMode = 'pin'; pinActiveIndex = 0; renderPinBoxes(); document.getElementById('pinMsg').textContent=''; modal.classList.remove('hidden'); const hidden = document.getElementById('pinHiddenInput'); if(hidden){ hidden.value=''; setTimeout(()=>{ hidden.focus(); },50); } document.addEventListener('keydown', handlePinKeydown); }
function closePinModal(){ const modal = document.getElementById('pinModal'); if(modal) modal.classList.add('hidden'); pinKeyboardMode = null; document.removeEventListener('keydown', handlePinKeydown); }
function renderPinBoxes(){
  const container = document.getElementById('pinBoxes');
  if(!container) return;
  container.innerHTML='';
  for(let i=0;i<PIN_MAX;i++){
    const d = document.createElement('div');
    d.className = 'pin-box';
    d.dataset.idx = i;
    d.textContent = pinValue[i] ? pinValue[i] : '\u00A0';
    d.style.cursor = 'pointer';
    if(pinKeyboardMode === 'pin' && i === pinActiveIndex) d.classList.add('selected');
    d.addEventListener('click', ()=>{
      pinKeyboardMode = 'pin';
      pinActiveIndex = i;
      const hidden = document.getElementById('pinHiddenInput');
      if(hidden){ hidden.focus(); setTimeout(()=>hidden.focus(),50); }
      renderPinBoxes();
    });
    container.appendChild(d);
  }
  // Disable Save PIN button if not valid
  const saveBtn = document.getElementById('pinSaveBtn');
  if(saveBtn) {
    if(pinValue.length < PIN_MIN || pinValue.length > PIN_MAX || !/^[0-9]+$/.test(pinValue)) {
      saveBtn.disabled = true;
      saveBtn.classList.add('disabled');
      saveBtn.style.opacity = '0.5';
      saveBtn.style.pointerEvents = 'none';
    } else {
      saveBtn.disabled = false;
      saveBtn.classList.remove('disabled');
      saveBtn.style.opacity = '1';
      saveBtn.style.pointerEvents = '';
    }
  }
}
function showDigitKeypad(idx, mode){ const digits = ['0','1','2','3','4','5','6','7','8','9','‚å´']; const targetArr = mode === 'pin' ? pinValue : pinLoginValue; const arr = targetArr.split(''); const modal = document.createElement('div'); modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.7);z-index:15000;display:flex;align-items:center;justify-content:center'; const card = document.createElement('div'); card.style.cssText = 'background:linear-gradient(180deg,rgba(255,255,255,0.06),rgba(255,255,255,0.03));padding:20px;border-radius:16px;backdrop-filter:blur(6px);max-width:320px'; const label = document.createElement('h4'); label.textContent = 'Enter Digit'; label.style.cssText = 'margin:0 0 12px 0;font-size:16px;color:white'; card.appendChild(label); const grid = document.createElement('div'); grid.style.cssText = 'display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px'; digits.forEach(d=>{ const btn = document.createElement('button'); btn.textContent = d; btn.style.cssText = 'padding:16px;border-radius:8px;border:1px solid rgba(255,255,255,0.1);background:rgba(255,255,255,0.05);color:white;font-weight:700;cursor:pointer;font-size:16px;transition:background 200ms'; btn.addEventListener('mouseenter', ()=>{ btn.style.background = 'rgba(255,255,255,0.15)'; }); btn.addEventListener('mouseleave', ()=>{ btn.style.background = 'rgba(255,255,255,0.05)'; }); btn.addEventListener('click', ()=>{ if(d === '‚å´'){ arr[idx] = ''; } else { arr[idx] = d; } if(mode === 'pin'){ pinValue = arr.join('').slice(0,PIN_MAX); renderPinBoxes(); } else { pinLoginValue = arr.join('').slice(0,PIN_MAX); renderPinLoginBoxes(); } document.body.removeChild(modal); }); grid.appendChild(btn); }); card.appendChild(grid); const closeBtn = document.createElement('button'); closeBtn.textContent = 'Done'; closeBtn.style.cssText = 'width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.1);background:linear-gradient(90deg,#ffd166,#ff9a66);color:#1a1a1a;font-weight:700;cursor:pointer'; closeBtn.addEventListener('click', ()=>{ document.body.removeChild(modal); }); card.appendChild(closeBtn); modal.appendChild(card); document.body.appendChild(modal); }
async function hashPin(pin){ try{ const enc = new TextEncoder(); const data = enc.encode(pin); const hashBuf = await crypto.subtle.digest('SHA-256', data); const hashArr = Array.from(new Uint8Array(hashBuf)); return hashArr.map(b=>b.toString(16).padStart(2,'0')).join(''); }catch(e){ console.error('hash failed', e); return null; } }
async function savePinToFirebase(pin){ const msgEl = document.getElementById('pinMsg'); if(msgEl) msgEl.textContent='Saving...'; const ok = await ensureFirebaseConnected(); if(!ok){ if(msgEl) msgEl.textContent = 'Could not connect to Firebase.'; showToast('Connect to Firebase to save PIN.'); return false; }
  if(!firebaseUid){ if(msgEl) msgEl.textContent='No firebase user.'; return false; }
  const hash = await hashPin(pin);
  if(!hash){ if(msgEl) msgEl.textContent='Hash failed.'; return false; }
  try{
    await firebaseDB.ref('/pins/' + firebaseUid).set({ hash, created: Date.now() });
    if(msgEl) msgEl.textContent='Saved.'; showToast('PIN saved. Remember it ‚Äî no reset is available.',3600); closePinModal();
    localStorage.setItem('pinSet', '1'); window.pinSet = true; isLoggedIn = true; updatePinMenuButtons();
    return true;
  }catch(e){ console.error('savePin failed', e); if(msgEl) msgEl.textContent='Could not save PIN.'; showToast('Failed to save PIN.'); return false; }
}
async function deletePinFromFirebase(){ if(!confirm('Delete saved PIN for your account? This cannot be undone if you rely on it.')) return; const ok = await ensureFirebaseConnected(); if(!ok){ showToast('Connect to Firebase to delete PIN.'); return; } try{ await firebaseDB.ref('/pins/' + firebaseUid).remove(); showToast('PIN deleted.'); }catch(e){ console.error('delete pin failed', e); showToast('Could not delete PIN.'); } }

// Account state tracking
let isLoggedIn = false;

function updatePinMenuButtons(){
  const setPinBtn = document.getElementById('setPinBtn');
  const loginPinBtn = document.getElementById('loginPinBtn');
  const deleteAccountBtn = document.getElementById('deleteAccountBtn');
  const signOutBtn = document.getElementById('signOutBtn');
  
  if(isLoggedIn){
    if(setPinBtn) setPinBtn.style.display = 'none';
    if(loginPinBtn) loginPinBtn.style.display = 'none';
    if(deleteAccountBtn) deleteAccountBtn.style.display = '';
    if(signOutBtn) signOutBtn.style.display = '';
  } else {
    if(setPinBtn) setPinBtn.style.display = '';
    if(loginPinBtn) loginPinBtn.style.display = '';
    if(deleteAccountBtn) deleteAccountBtn.style.display = 'none';
    if(signOutBtn) signOutBtn.style.display = 'none';
  }
}

function signOut(){
  if(!confirm('Sign out and return to guest mode?')) return;
  isLoggedIn = false;
  username = 'Guest';
  localStorage.removeItem('playerName');
  localStorage.removeItem('linkedAccountUid');
  localStorage.removeItem('pinSet');
  window.pinSet = false;
  if(ui.usernameDisplay) ui.usernameDisplay.textContent = 'Guest';
  updatePinMenuButtons();
  showToast('Signed out. You are now guest.', 2000);
}

async function deleteAccountFromFirebase(){
  // Check if user has a PIN set
  if(!window.pinSet && !localStorage.getItem('pinSet')){
    showToast('You must have a PIN set to delete your account.', 3000);
    return;
  }
  
  // Ask for PIN confirmation before deletion
  const pin = prompt('Enter your PIN to confirm account deletion:');
  if(!pin) return;
  
  const ok = await ensureFirebaseConnected();
  if(!ok){ showToast('Connect to Firebase to delete account.'); return; }
  
  // Verify PIN
  const hashedPin = await hashPin(pin);
  try{
    const pinSnap = await firebaseDB.ref('/pins/' + firebaseUid).once('value');
    const pinData = pinSnap.val();
    if(!pinData || pinData.hash !== hashedPin){
      showToast('Incorrect PIN. Account deletion cancelled.', 3000);
      return;
    }
  }catch(e){
    showToast('Could not verify PIN.', 2000);
    return;
  }
  
  if(!confirm('‚úã FINAL WARNING: This will permanently delete your account, PIN, and all scores. This CANNOT be undone. Continue?')) return;
  
  try{
    await Promise.all([
      firebaseDB.ref('/pins/' + firebaseUid).remove(),
      firebaseDB.ref('/players/' + firebaseUid).remove(),
      firebaseDB.ref('/bestScores/' + firebaseUid).remove()
    ]);
    showToast('Account deleted successfully.');
    isLoggedIn = false;
    username = 'Guest';
    localStorage.removeItem('playerName');
    localStorage.removeItem('linkedAccountUid');
    localStorage.removeItem('pinSet');
    window.pinSet = false;
    if(ui.usernameDisplay) ui.usernameDisplay.textContent = 'Guest';
    updatePinMenuButtons();
    updateSetPinButton();
  }catch(e){
    console.error('delete account failed', e);
    showToast('Could not delete account.');
  }
}

// Clean up inactive accounts (90+ days)
async function cleanupInactiveAccounts(){
  if(!firebaseConnected || !firebaseDB) return;
  try{
    const cutoff = Date.now() - (91 * 24 * 60 * 60 * 1000); // 91 days ago
    const playersSnap = await firebaseDB.ref('/players').once('value');
    const players = playersSnap.val() || {};
    
    let cleanedCount = 0;
    for(const uid in players){
      const player = players[uid];
      const lastSeen = player.ts || 0;
      if(lastSeen < cutoff && player.username !== 'Guest'){
        console.log('Cleaning up inactive account:', player.username, uid);
        await Promise.all([
          firebaseDB.ref('/pins/' + uid).remove(),
          firebaseDB.ref('/players/' + uid).remove(),
          firebaseDB.ref('/bestScores/' + uid).remove()
        ]);
        cleanedCount++;
      }
    }
    if(cleanedCount > 0){
      console.log(`Cleaned up ${cleanedCount} inactive accounts`);
    }
  }catch(e){
    console.warn('Account cleanup failed:', e);
  }
}

// wire modal controls
const setPinBtn = document.getElementById('setPinBtn'); if(setPinBtn) setPinBtn.addEventListener('click', ()=>{
  if(!username || username === 'Guest'){
    showToast('You must set a username before creating a PIN.', 3000);
    return;
  }
  if(!firebaseConnected){
    showToast('Please connect to Firebase first.', 2000);
    ensureFirebaseConnected().then(ok => {
      if(ok) openPinModal();
    });
    return;
  }
  openPinModal();
});

const signOutBtn = document.getElementById('signOutBtn');
if(signOutBtn) signOutBtn.addEventListener('click', ()=>{ signOut(); });

const deleteAccountBtn = document.getElementById('deleteAccountBtn');
if(deleteAccountBtn) deleteAccountBtn.addEventListener('click', ()=>{ deleteAccountFromFirebase(); });

const pinSaveBtn = document.getElementById('pinSaveBtn'); if(pinSaveBtn) pinSaveBtn.addEventListener('click', async ()=>{
  const msgEl = document.getElementById('pinMsg'); if(pinValue.length < PIN_MIN){ if(msgEl) msgEl.textContent = 'PIN must be 4 to 6 digits'; return; }
  await savePinToFirebase(pinValue);
});
const pinCancelBtn = document.getElementById('pinCancelBtn'); if(pinCancelBtn) pinCancelBtn.addEventListener('click', ()=>{ closePinModal(); });

// ---------- PIN login (lookup by PIN hash - clickable boxes) ----------
let pinLoginValue = '';
let loginAttemptUsername = '';
let loginAttemptUid = null;
function openUsernameLoginModal(){ const m = document.getElementById('usernameLoginModal'); if(!m) return; const inp = document.getElementById('loginUsernameInput'); if(inp) inp.value=''; const msg = document.getElementById('usernameLoginMsg'); if(msg) msg.textContent=''; m.classList.remove('hidden'); if(inp) setTimeout(()=>inp.focus(),50); }
function closeUsernameLoginModal(){ const m = document.getElementById('usernameLoginModal'); if(m) m.classList.add('hidden'); }
function openPinLoginModal(){ const m = document.getElementById('pinLoginModal'); if(!m) return; pinLoginValue=''; pinKeyboardMode = 'login'; pinActiveIndex = 0; renderPinLoginBoxes(); const msg = document.getElementById('pinLoginMsg'); if(msg) msg.textContent=''; m.classList.remove('hidden'); const hidden = document.getElementById('pinHiddenInput'); if(hidden){ hidden.value=''; setTimeout(()=>{ hidden.focus(); },50); } document.addEventListener('keydown', handlePinKeydown); }
function closePinLoginModal(){ const m = document.getElementById('pinLoginModal'); if(m) m.classList.add('hidden'); pinKeyboardMode = null; document.removeEventListener('keydown', handlePinKeydown); }
function renderPinLoginBoxes(){ const c=document.getElementById('pinLoginBoxes'); if(!c) return; c.innerHTML=''; for(let i=0;i<PIN_MAX;i++){ const d=document.createElement('div'); d.className='pin-box'; d.dataset.idx = i; d.textContent = pinLoginValue[i] ? pinLoginValue[i] : '\u00A0'; d.style.cursor = 'pointer'; d.addEventListener('click', ()=>{ pinKeyboardMode = 'login'; pinActiveIndex = i; const hidden = document.getElementById('pinHiddenInput'); if(hidden){ hidden.focus(); setTimeout(()=>hidden.focus(),50); } renderPinLoginBoxes(); }); c.appendChild(d); } }
// keyboard handler for PIN entry (works for both set & login modals)
function handlePinKeydown(e){ if(!pinKeyboardMode) return; const k = e.key;
  if(k >= '0' && k <= '9'){
    if(pinKeyboardMode === 'pin'){
      const arr = pinValue.split(''); arr[pinActiveIndex] = k; pinValue = arr.join('').slice(0,PIN_MAX);
      if(pinActiveIndex < PIN_MAX - 1) pinActiveIndex++;
      renderPinBoxes();
    } else {
      const arr = pinLoginValue.split(''); arr[pinActiveIndex] = k; pinLoginValue = arr.join('').slice(0,PIN_MAX);
      if(pinActiveIndex < PIN_MAX - 1) pinActiveIndex++;
      renderPinLoginBoxes();
    }
    e.preventDefault();
    return;
  }
  if(k === 'Backspace'){
    if(pinKeyboardMode === 'pin'){
      const arr = pinValue.split(''); if(arr[pinActiveIndex] && arr[pinActiveIndex] !== ''){ arr[pinActiveIndex] = ''; } else if(pinActiveIndex > 0){ pinActiveIndex--; arr[pinActiveIndex] = ''; } pinValue = arr.join(''); renderPinBoxes();
    } else {
      const arr = pinLoginValue.split(''); if(arr[pinActiveIndex] && arr[pinActiveIndex] !== ''){ arr[pinActiveIndex] = ''; } else if(pinActiveIndex > 0){ pinActiveIndex--; arr[pinActiveIndex] = ''; } pinLoginValue = arr.join(''); renderPinLoginBoxes();
    }
    e.preventDefault();
    return;
  }
  if(k === 'Enter'){
    if(pinKeyboardMode === 'login'){
      const btn = document.getElementById('pinLoginBtn'); if(btn && !btn.disabled) btn.click();
    }
    else if(pinKeyboardMode === 'pin'){
      const btn = document.getElementById('pinSaveBtn'); if(btn && !btn.disabled) btn.click();
    }
    e.preventDefault();
    return;
  }
}
const pinLoginBtnEl = document.getElementById('pinLoginBtn'); if(pinLoginBtnEl) pinLoginBtnEl.addEventListener('click', async ()=>{
  const msg = document.getElementById('pinLoginMsg'); if(pinLoginValue.length < PIN_MIN){ if(msg) msg.textContent = 'PIN must be 4 to 6 digits'; return; }
  if(!loginAttemptUid){ if(msg) msg.textContent = 'No username selected for login'; return; }
  const h = await hashPin(pinLoginValue); if(!h){ if(msg) msg.textContent = 'Hash failed'; return; }
  const ok = await ensureFirebaseConnected(); if(!ok){ if(msg) msg.textContent = 'Could not connect to Firebase'; return; }
  try{
    const pinSnap = await firebaseDB.ref('/pins/' + loginAttemptUid).once('value'); const p = pinSnap.val();
    if(!p || p.hash !== h){ if(msg) msg.textContent = 'Incorrect PIN for that username'; return; }
    const playerSnap = await firebaseDB.ref('/players/' + loginAttemptUid).once('value'); const pdata = playerSnap.val() || {};
    const foundName = pdata.username || loginAttemptUsername || 'Unknown';
    username = foundName; localStorage.setItem('playerName', username); localStorage.setItem('linkedAccountUid', loginAttemptUid); if(ui.usernameDisplay) ui.usernameDisplay.textContent = username; if(msg) msg.textContent = 'Logged in: ' + username; showToast('Logged in: ' + username, 3000);
    window.linkedAccountUid = loginAttemptUid; window.linkedAccountData = pdata;
    isLoggedIn = true; updatePinMenuButtons();
    loginAttemptUid = null; loginAttemptUsername = '';
    closePinLoginModal();
  }catch(e){ console.error('pin lookup failed', e); if(document.getElementById('pinLoginMsg')) document.getElementById('pinLoginMsg').textContent = 'Lookup failed'; showToast('PIN lookup failed'); }
});

// username modal handlers
const usernameLoginBtn = document.getElementById('usernameLoginBtn'); if(usernameLoginBtn) usernameLoginBtn.addEventListener('click', async ()=>{
  const msg = document.getElementById('usernameLoginMsg'); const inp = document.getElementById('loginUsernameInput'); const val = (inp && inp.value || '').trim(); if(!val){ if(msg) msg.textContent = 'Enter a username'; return; }
  const okConn = await ensureFirebaseConnected(); if(!okConn){ if(msg) msg.textContent = 'Could not connect to Firebase'; return; }
  try{
    const snap = await firebaseDB.ref('/players').orderByChild('username').equalTo(val).once('value'); const found = snap.val() || {};
    const keys = Object.keys(found);
    if(keys.length > 0){ // existing account - require PIN
      loginAttemptUid = keys[0]; loginAttemptUsername = val; closeUsernameLoginModal(); const subtitle = document.getElementById('pinLoginSubtitle'); if(subtitle) subtitle.textContent = 'Enter PIN for ' + val; openPinLoginModal();
    } else { // create new account for current firebaseUid and prompt to set PIN
      if(!firebaseUid){ const got = await ensureFirebaseConnected(); if(!got){ if(msg) msg.textContent = 'Could not sign you in'; return; } }
      try{ await firebaseDB.ref('/players/' + firebaseUid).set({ username: val, score: 0, coins:0, ts: Date.now() }); }
      catch(e){ console.error('create player failed', e); if(msg) msg.textContent = 'Could not create account'; return; }
      username = val; localStorage.setItem('playerName', username); localStorage.setItem('linkedAccountUid', firebaseUid); window.linkedAccountUid = firebaseUid; isLoggedIn = true; updatePinMenuButtons(); closeUsernameLoginModal(); showToast('Account created. Please set a PIN to allow cross-device login.', 3000); openPinModal();
    }
  }catch(e){ console.error('username lookup failed', e); if(msg) msg.textContent = 'Lookup failed'; }
});
const usernameLoginCancel = document.getElementById('usernameLoginCancelBtn'); if(usernameLoginCancel) usernameLoginCancel.addEventListener('click', ()=>{ closeUsernameLoginModal(); });

// open login modal from main UI
const loginPinBtn = document.getElementById('loginPinBtn'); if(loginPinBtn) loginPinBtn.addEventListener('click', ()=>{ openUsernameLoginModal(); });
const pinLoginCancel = document.getElementById('pinLoginCancelBtn'); if(pinLoginCancel) pinLoginCancel.addEventListener('click', ()=>{ closePinLoginModal(); });

// start game helper
function startGame(online, withBots=true){
  // record whether this session should be considered online (controls ad behavior)
  isOnlineMode = !!online;
  const homeControl = document.getElementById('homeControlMode'); if(homeControl) controlMode = homeControl.value; const controlModeEl = document.getElementById('controlMode'); if(controlModeEl) controlModeEl.value = controlMode; localStorage.setItem('controlMode', controlMode); updateControlUI();
  const saved = localStorage.getItem('playerName') || 'Guest'; if(online && (!saved || saved==='Guest')){ showToast('Please set a username before starting online.',2200); return; }
  const overlayE = document.getElementById('overlay'); if(overlayE) overlayE.classList.add('hidden');
  foods=[]; enemies=[]; bubbles=[];
  // If joined to a room with a center, spawn near that center; otherwise pick a random spawn
  if(currentRoom && currentRoom.center && typeof currentRoom.center.x === 'number'){
    const offset = 150 + Math.random()*100; const angle = Math.random()*Math.PI*2; player.x = currentRoom.center.x + Math.cos(angle) * offset; player.y = currentRoom.center.y + Math.sin(angle) * offset;
  } else {
    setRandomSpawn();
  }
  player.size=8 + Math.random()*8; player.hunger=100; player.score=0; player.coins=0; player.alive=true; deathHandled=false; cameraFrozen=false; pointerX=null; pointerY=null; keys={};
  // immediately update UI so score/coins reset reflects on-screen even before the first update tick
  try{ if(ui.scoreEl) ui.scoreEl.textContent = '0'; if(ui.coinsEl) ui.coinsEl.textContent = '0'; if(ui.sizeEl) ui.sizeEl.textContent = player.size.toFixed(1); if(ui.hungerEl) ui.hungerEl.style.width = Math.max(0, player.hunger) + '%'; }catch(e){}
  allowBots = withBots;  // Set bots based on mode
  // Ensure a set of small, harmless starter food is present and that the player
  // never spawns smaller than those food items.
  const starterFoodMax = 6; // food will be size 2..starterFoodMax
  // Guarantee player's start size is at least slightly larger than starter food
  player.size = Math.max(player.size, starterFoodMax + 1);
  for(let i=0;i<200;i++){ const angle = Math.random()*Math.PI*2; const dist = 80 + Math.random()*600; const f = { x: player.x + Math.cos(angle)*dist, y: player.y + Math.sin(angle)*dist, size: 2 + Math.random()*(starterFoodMax-2), wobble: Math.random()*Math.PI*2, color:'#fff59d' }; foods.push(f); }
  if(withBots){
    // spawn many local bots and also distribute additional bots across the map
    for(let i=0;i<360;i++) spawnEnemyRelative(player.x, player.y);
    setTimeout(()=>{ try{ spawnBotsAcrossMap(420); }catch(e){} }, 180);
  }  // Only spawn bots if withBots is true
  for(let i=0;i<120;i++) spawnBubbleAround(player.x, player.y); ensureAudioStarted(); setRunning(true);
  // Ads only on explicit user actions, not automatic restart
  console.log(`üéÆ [${new Date().toISOString()}] GAME STARTED: No ad shown - only on explicit actions`);
  if(online){ ensureFirebaseConnected().then(ok=>{ if(ok){ showToast('Online mode: connected to Firebase' + (withBots ? '' : ' (no bots)'),1600); uploadPlayerState(); } else { showToast('Could not connect to Firebase ‚Äî starting offline',2600); } }); } else { rebuildLeaderboards(); }
  // ensure a small bot population so online-with-bots reliably has bots
  if(withBots){ setTimeout(()=>{ ensureBotPopulation(120); }, 120); }
}



const btnLeave = document.getElementById('btnLeave'); if(btnLeave) btnLeave.addEventListener('click', ()=>{ currentRoom = { code: null, friendsOnly:false, owner:null, center:null }; allowBots = true; if(firebaseConnected && firebaseDB && firebaseUid){ try{ firebaseDB.ref('/players/' + firebaseUid).update({ room: null, ts: Date.now() }); }catch(e){} } setRunning(false); const overlayE = document.getElementById('overlay'); if(overlayE) overlayE.classList.remove('hidden'); });

const btnPause = document.getElementById('btnPause'); if(btnPause) btnPause.addEventListener('click', ()=>{ if(firebaseConnected && currentRoom.code){ showToast('Pausing disabled in online rooms. Use Exit to leave.'); return; } setRunning(!running); });

// show overlay start paused
document.getElementById('overlay').classList.remove('hidden'); setRunning(false);

// If running on a mobile/touch device, block mobile play and show a message
function isMobileDevice(){ try{ return /Mobi|Android|iPhone|iPad|iPod|Windows Phone/i.test(navigator.userAgent) || (navigator.maxTouchPoints && navigator.maxTouchPoints>0) || ('ontouchstart' in window && navigator.maxTouchPoints === 0); }catch(e){ return false; } }
if(isMobileDevice()){
  try{
    // Block mobile access with non-dismissible overlay
    const mobileBlock = document.createElement('div');
    mobileBlock.style.cssText = 'position:fixed;inset:0;background:linear-gradient(135deg,#1a1a2e,#16213e);z-index:99999;display:flex;align-items:center;justify-content:center;font-family:system-ui;color:white;text-align:center;padding:20px;user-select:none;-webkit-user-select:none;pointer-events:none;';
    mobileBlock.innerHTML = `
      <div style="max-width:400px">
        <h2 style="margin-bottom:16px;font-size:24px;color:#ff6b6b">üì± Mobile Platform Not Supported</h2>
        <p style="font-size:16px;line-height:1.6;margin-bottom:20px">Sorry, we don't support mobile devices. Please use a computer with keyboard and mouse to continue playing Aqua Odyssey.</p>
        <div style="font-size:14px;opacity:0.8">This restriction cannot be bypassed.</div>
      </div>
    `;
    document.body.appendChild(mobileBlock);
    // Prevent any interaction with the game
    document.body.style.pointerEvents = 'none';
    document.documentElement.style.pointerEvents = 'none';
  }catch(e){}
}

// self-tests
window.runTests = function(){ try { console.assert(typeof setRunning === 'function', 'setRunning should exist'); console.assert(document.getElementById('btnPause'), 'Pause button exists'); console.log('Self-tests passed.'); } catch(e){ console.error('Self-tests failed', e); } };

// Ad debugging functions
window.checkAdStatus = checkAdStatus;
window.testAd = function(type = 'reward', name = 'test-ad') {
  console.log(`üß™ [${new Date().toISOString()}] TEST AD: Manual ad test triggered`);
  tryAdBreak({ type, name });
};
window.testRewardAd = function() { testAd('reward', 'manual-reward-test'); };
window.testStartAd = function() { testAd('start', 'manual-start-test'); };

console.log(`üîß [${new Date().toISOString()}] DEBUG: Ad debugging functions loaded:`);
console.log(`   - checkAdStatus() - Check ad system status`);
console.log(`   - testAd(type, name) - Test manual ad`);
console.log(`   - testRewardAd() - Test reward ad`);
console.log(`   - testStartAd() - Test start ad`);
window.__game = {player, foods, enemies, bubbles, onlinePlayers, remotePlayers, currentRoom};

// initial leader render
rebuildLeaderboards();

// On page load, restore login state and update menu buttons
const savedUsername = localStorage.getItem('playerName');
const savedUid = localStorage.getItem('linkedAccountUid');
if(savedUsername && savedUsername !== 'Guest') {
  username = savedUsername;
  if(ui.usernameDisplay) ui.usernameDisplay.textContent = username;
  isLoggedIn = true;
  
  // Auto-login if we have saved credentials
  if(savedUid && firebaseConnected){
    // Verify account still exists
    firebaseDB.ref('/players/' + savedUid).once('value').then(snap => {
      if(snap.exists()){
        const data = snap.val();
        username = data.username || savedUsername;
        localStorage.setItem('playerName', username);
        if(ui.usernameDisplay) ui.usernameDisplay.textContent = username;
        window.linkedAccountUid = savedUid;
        window.linkedAccountData = data;
        showToast('Welcome back, ' + username + '!', 2000);
      } else {
        // Account was deleted, clean up local storage
        localStorage.removeItem('playerName');
        localStorage.removeItem('linkedAccountUid');
        localStorage.removeItem('pinSet');
        username = 'Guest';
        isLoggedIn = false;
        if(ui.usernameDisplay) ui.usernameDisplay.textContent = 'Guest';
        showToast('Your account was deleted due to inactivity.', 4000);
      }
      updatePinMenuButtons();
      updateSetPinButton();
    }).catch(e => {
      console.warn('Auto-login verification failed:', e);
    });
  }
}
updatePinMenuButtons();
updateSetPinButton();

// Run cleanup periodically (every 24 hours)
if(typeof setInterval !== 'undefined'){
  setInterval(cleanupInactiveAccounts, 24 * 60 * 60 * 1000);
  // Also run once on load after a delay
  setTimeout(cleanupInactiveAccounts, 5000);
}
</script>
</body>
</html>
