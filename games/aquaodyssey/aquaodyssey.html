<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>ilikefish.space - Aqua Odyssey</title>
<style>
  :root{--glass:rgba(255,255,255,0.08);--glass-2:rgba(255,255,255,0.06);--accent:#ffd166;--accent-2:#06c8ff;--bg-top:#7ee8fa;--bg-bottom:#123a63;--panel-radius:14px}
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%;width:100%;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;color:#fff;overflow:hidden}
  body{background:linear-gradient(180deg,var(--bg-top),var(--bg-bottom));touch-action:none}
  canvas{display:block;position:fixed;inset:0;width:100vw;height:100vh}
  .hud{position:absolute;left:12px;right:12px;top:12px;display:flex;align-items:center;justify-content:space-between;gap:12px;z-index:60}
  .panel{backdrop-filter:blur(6px);background:var(--glass);padding:10px 12px;border-radius:var(--panel-radius);box-shadow:0 6px 18px rgba(0,0,0,0.25)}
  .title{display:flex;align-items:center;gap:12px}
  .logo{width:44px;height:44px;border-radius:10px;background:linear-gradient(135deg,var(--accent),#ff9a66);display:flex;align-items:center;justify-content:center}
  .app-title{font-weight:700;font-size:18px}
  .username-display{font-size:12px;opacity:0.95}
  .stats{display:flex;gap:10px;align-items:center}
  .stat{font-size:14px;min-width:68px;text-align:center}
  .controls{display:flex;gap:8px;align-items:center}
  .btn{background:var(--glass-2);border-radius:10px;padding:8px 10px;font-weight:600;border:1px solid rgba(255,255,255,0.06);cursor:pointer}
  .side{position:absolute;left:14px;bottom:14px;display:flex;gap:12px;align-items:flex-end;z-index:50}
  .joy{width:120px;height:120px;border-radius:999px;background:linear-gradient(180deg,rgba(255,255,255,0.03),rgba(255,255,255,0.01));display:flex;align-items:center;justify-content:center;position:fixed;left:14px;bottom:14px}
  .stick{width:56px;height:56px;border-radius:999px;background:rgba(255,255,255,0.12);transform:translate(0,0)}
  .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:9999;pointer-events:auto}
  .overlay.hidden{display:none}
  .card{width:100%;max-width:820px;pointer-events:all;position:relative;z-index:10000;background:linear-gradient(180deg,rgba(255,255,255,0.06),rgba(255,255,255,0.03));padding:22px;border-radius:16px;backdrop-filter:blur(6px);text-align:center}
  .card h2{font-size:20px;margin-bottom:8px}
  .primary{background:linear-gradient(90deg,var(--accent),#ff9a66);border-radius:12px;padding:10px 14px;color:#1a1a1a;font-weight:800;cursor:pointer;border:none}
  .secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 12px;border-radius:10px;margin-left:8px}
  .info{max-height:320px;overflow:auto;padding-top:8px;font-size:13px}
  .shop{display:flex;flex-direction:column;gap:8px}
  .shop-row{display:flex;justify-content:space-between;align-items:center;padding:10px;border-radius:10px;background:rgba(255,255,255,0.02)}
  .controls-bottom{position:absolute;right:12px;bottom:12px;z-index:60;display:flex;flex-direction:column;gap:8px;align-items:flex-end}
  .chip{padding:8px 10px;border-radius:999px;background:var(--glass-2);font-weight:700}
  .bar{height:10px;border-radius:999px;background:rgba(255,255,255,0.06);overflow:hidden}
  .bar > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),var(--accent-2));width:40%}
  .depth-gauge{width:28px;height:86px;border-radius:12px;background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.04);display:flex;align-items:flex-end;padding:4px}
  .depth-fill{width:100%;background:linear-gradient(180deg,#06c8ff,#004f7a);border-radius:8px;transition:height 260ms linear}
  .hidden{display:none}
  .mode-select{display:flex;gap:6px;align-items:center}
  .boost-btn{background:linear-gradient(90deg,#ffd766,#ff8a66);padding:8px 10px;border-radius:10px;font-weight:800}
  input[type=text]{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:white}
  .err{color:#ffb3b3;font-size:12px;margin-top:6px}
  .toast{position:fixed;left:50%;transform:translateX(-50%);top:22px;padding:10px 14px;background:rgba(0,0,0,0.6);border-radius:10px;z-index:200;font-weight:700}
  @media (max-width:900px){ .hud{left:8px;right:8px;top:8px} .card{max-width:92vw} }
  @media (max-width:600px){.app-title{font-size:16px}.stat{font-size:13px}.joy{width:96px;height:96px}.stick{width:44px;height:44px}.hud{flex-direction:column;gap:6px;align-items:flex-start}}
  /* mini leaderboard (top-left, compact) */
  #miniLeaderboard{position:fixed;left:12px;top:72px;z-index:120;min-width:180px;max-width:260px;border-radius:12px;padding:8px;backdrop-filter:blur(6px);background:rgba(0,0,0,0.16);font-size:13px}
  #miniLeaderboard h4{margin:0 0 6px 0;font-size:13px}
  #miniLeaderboard .lb-row{display:flex;justify-content:space-between;gap:8px;padding:6px;border-radius:8px;background:rgba(255,255,255,0.02);margin-bottom:6px}
  #miniLeaderboard .controls{display:flex;gap:6px;align-items:center}
  #miniLeaderboard .toggle{cursor:pointer;padding:6px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent}
  #miniLeaderboard .search{flex:1;padding:6px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:white}
  #miniLeaderboard.small{min-width:160px}
</style>

<!-- Firebase compat SDKs (ensure loaded so `firebase` exists) -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

</head>
<body>
<canvas id="gameCanvas"></canvas>
<div class="hud">
  <div class="title panel">
    <div class="logo" aria-hidden><svg viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6 32c8-12 24-16 36-10 12 6 12 18 0 24C30 54 14 48 6 32z" fill="#fff" opacity="0.18"/><path d="M8 32c8-10 22-14 34-9 9 4 9 12 0 17C30 51 14 44 8 32z" fill="#fff"/></svg></div>
    <div style="display:flex;flex-direction:column"><div class="app-title">Aqua Odyssey</div><div id="usernameDisplay" class="username-display">Guest</div></div>
  </div>
  <div class="panel stats"><div class="stat">Size<br><strong id="size">1.0</strong></div><div class="stat">Score<br><strong id="score">0</strong></div><div class="stat">High<br><strong id="highscore">0</strong></div><div class="stat">Coins<br><strong id="coins">0</strong></div><div class="stat">Depth<br><strong id="depthVal">0 m</strong></div><div class="stat">Coords<br><strong id="coords">0,0</strong></div></div>
  <div class="controls"><div class="panel"><div style="font-size:12px;opacity:0.85">Hunger</div><div class="bar" style="width:120px;margin-top:6px"><i id="hungerBar" style="width:100%"></i></div></div>
    <div class="mode-select panel" style="align-items:center">Control: <select id="controlMode" style="margin-left:8px;padding:6px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.06)"><option value="mouse">Mouse</option><option value="keyboard">Keyboard</option><option value="mobile">Mobile</option></select></div>
    <button id="btnPause" class="btn panel">Pause</button>
    <button id="btnLeave" class="btn panel">Exit</button>
  </div>
</div>

<!-- compact in-game leaderboard (top-left) -->
<div id="miniLeaderboard" class="panel small">
  <div style="display:flex;align-items:center;justify-content:space-between;gap:8px">
    <h4 style="margin:0">Leaderboard</h4>
    <div style="display:flex;gap:6px;align-items:center">
      <input id="miniSearch" class="search" placeholder="search" />
      <button id="miniToggle" class="toggle">▼</button>
    </div>
  </div>
  <div id="miniList" style="margin-top:8px;max-height:220px;overflow:auto"></div>
  <div id="miniFooter" style="margin-top:6px;font-size:12px;opacity:0.9;display:flex;justify-content:space-between"><div id="miniYou">You: -</div><div id="miniCount">0</div></div>
</div>

<div class="side">
  <div class="joy panel" id="joystick"><div class="stick" id="stick"></div></div>
</div>
<div class="controls-bottom">
  <div style="display:flex;align-items:center;gap:10px"><div class="chip panel">FPS: <span id="fps">0</span></div><div style="text-align:center" class="panel" aria-hidden><div style="font-size:12px;opacity:0.85">Depth</div><div class="depth-gauge" id="depthGauge"><div class="depth-fill" id="depthFill" style="height:4%"></div></div></div></div>
  <button id="boostMobile" class="boost-btn panel">BOOST</button>
</div>
<div id="toastArea"></div>
<div class="overlay" id="overlay">
  <div class="card" id="homeCard">
    <h2>Aqua Odyssey</h2>
    <p>Survive as long as possible — larger fish eat smaller fish. You get hungrier the bigger you are. New things keep spawning: the sea is endless.</p>

    <!-- Play / room controls -->
    <div style="display:flex;gap:8px;margin-bottom:8px;align-items:center;justify-content:center;flex-wrap:wrap">
      <button id="startOfflineBtn" class="primary">Play Offline</button>
      <button id="startOnlineBtn" class="primary" style="margin-left:8px">Play Online</button>
      <button id="fbSetupBtn" class="secondary" style="margin-left:8px">Connect Firebase</button>
      <button id="infoBtn" class="secondary" style="margin-left:8px">Info</button>
      <button id="leaderboardBtn" class="secondary" style="margin-left:8px">Leaderboard</button>
      <button id="shopBtn" class="secondary" style="margin-left:8px">Shop</button>
      <div style="margin-left:12px;display:flex;align-items:center;gap:8px">
        <div id="connIndicator" style="width:12px;height:12px;border-radius:999px;background:#999;border:2px solid rgba(0,0,0,0.3)"></div>
        <div id="connText" style="font-size:12px;opacity:0.9">Offline</div>
        <div id="connMs" style="font-size:12px;opacity:0.9;margin-left:6px"></div>
      </div>
    </div>

    <!-- Room creation / join -->
    <div style="display:flex;gap:8px;margin-bottom:8px;align-items:center;justify-content:center;flex-wrap:wrap">
      <input id="roomCodeInput" placeholder="Room code (6 chars)" style="padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:white;min-width:160px"/>
      <button id="generateRoomBtn" class="secondary">Generate</button>
      <label style="display:flex;align-items:center;gap:6px"><input id="friendsOnlyCheckbox" type="checkbox"/> Friends-only</label>
      <button id="createRoomBtn" class="primary">Create Room</button>
      <button id="joinRoomBtn" class="primary" style="background:linear-gradient(90deg,#9ae66a,#66d9ff)">Join Room</button>
    </div>

    <div style="display:flex;gap:8px;margin-bottom:8px;align-items:center;justify-content:center;flex-wrap:wrap">
      <button id="spectateToggleBtn" class="secondary">Spectate Mode</button>
    </div>

    <div style="display:flex;gap:8px;margin-bottom:8px;align-items:center;justify-content:center;flex-wrap:wrap">
      <input id="usernameInput" type="text" placeholder="Enter username" style="margin-left:8px;min-width:180px"/><button id="setNameBtn" class="secondary">Set</button>
    </div>
    <div id="nameErr" class="err"></div>
    <div id="homeInfo" class="info"><strong>History &amp; Lore</strong><div id="loreList"><p>The ocean rose and swallowed the lands — the whole world flooded. Only the fish survived. Their descendants now roam the endless water.</p></div><strong>Controls</strong><ul><li>Mouse: move with cursor</li><li>Keyboard: WASD / Arrow keys, Hold Shift to boost (loses size)</li><li>Mobile: tap anywhere and drag to move (Roblox-like). Pick Mobile and then choose "Floating Joystick" or "Touch Anywhere".</li></ul></div>
    <div id="shopPanel" class="info hidden"><strong>Shop</strong>
      <div style="margin:8px 0;display:flex;gap:8px"><input id="shopSearch" placeholder="Search" style="flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:white"/><select id="shopSort" style="padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:white"><option value="price-asc">Price ↑</option><option value="price-desc">Price ↓</option><option value="name">Name</option></select></div>
    <div id="leaderboardPanel" class="info hidden"><strong>Leaderboard</strong>
      <div style="display:flex;gap:8px;margin-top:8px;align-items:center;margin-bottom:8px">
        <input id="leaderboardSearch" placeholder="Search players" style="flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:white"/>
        <select id="leaderboardFilter" style="padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:white"><option value="all">All</option><option value="online">Online only</option><option value="offline">Offline only</option></select>
        <button id="findMeBtn" class="secondary">Find Me</button>
      </div>
      <div id="leaderboardList" style="margin-top:8px"></div>
    </div>
      <div id="shopItems" class="shop"></div>
    </div>
  </div>
</div>

<!-- Hidden fallback elements (these IDs were referenced by JS previously but were not present) -->
<select id="homeControlMode" class="hidden" style="display:none;">
  <option value="mouse">Mouse</option>
  <option value="keyboard">Keyboard</option>
  <option value="mobile">Mobile</option>
</select>
<select id="mobileStyle" class="hidden" style="display:none;">
  <option value="floating">floating</option>
  <option value="touch">touch</option>
</select>

<script>
// ---------- setup ----------
const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d'); let DPR = Math.max(1, window.devicePixelRatio || 1);
function resize(){ DPR = Math.max(1, window.devicePixelRatio || 1); canvas.width = Math.floor(window.innerWidth * DPR); canvas.height = Math.floor(window.innerHeight * DPR); ctx.setTransform(DPR,0,0,DPR,0,0); }
window.addEventListener('resize', resize); window.addEventListener('orientationchange', resize); resize();

// Move Firebase-related variables up-front so functions that reference them do not run before they exist
let firebaseApp = null, firebaseDB = null, firebaseAuth = null;
let firebaseConnected = false, firebaseUid = null;

// other global basics
function overlayVisible(){ const o = document.getElementById('overlay'); return o && !o.classList.contains('hidden'); }

// prevent default context menu on canvas (we use right-click to boost)
canvas.addEventListener('contextmenu', (e)=>{ e.preventDefault(); });

// toast
function showToast(msg, ms=2200){ const t = document.createElement('div'); t.className='toast'; t.textContent = msg; document.getElementById('toastArea').appendChild(t); setTimeout(()=>{ t.style.transition='opacity 400ms'; t.style.opacity='0'; setTimeout(()=>t.remove(),420); }, ms); }

// prevent default scrolling on touch inside game
document.body.addEventListener('touchmove', (e)=>{ if(overlayVisible()) return; e.preventDefault(); }, {passive:false});

// world: simulate infinite by spawning relative to player and trimming far entities
const camera = { x: 0, y: 0, scale: 1 };
let cameraFrozen = false; let deathCameraX = 0, deathCameraY = 0; // when frozen, camera shows these coords
function screenToWorld(sx, sy){ return { x: camera.x + sx / camera.scale, y: camera.y + sy / camera.scale }; }

let running = false, lastTime = performance.now(), fpsCounter = 0, fpsTimer = 0;
const ui = { sizeEl: document.getElementById('size'), scoreEl: document.getElementById('score'), highEl: document.getElementById('highscore'), coinsEl: document.getElementById('coins'), hungerEl: document.getElementById('hungerBar'), fpsEl: document.getElementById('fps'), depthEl: document.getElementById('depthVal'), depthFill: document.getElementById('depthFill'), usernameDisplay: document.getElementById('usernameDisplay'), coordsDisplay: document.getElementById('coords') };

// define setRunning to control game loop & pause button label
function setRunning(v){ const was = running; running = !!v; const btn = document.getElementById('btnPause'); if(btn) btn.textContent = running ? 'Pause' : 'Resume'; if(running && !was){ lastTime = performance.now(); requestAnimationFrame(mainLoop); } }

// player (reduced baseSpeed for calmer movement)
const player = { x: 0, y: 0, size: 12, baseSpeed: 140, angle: 0, skin: 'classic', color: '#ff9a66', eyeColor: '#0b1b2b', hunger: 100, coins: 0, score: 0, alive: true, vx:0, vy:0, speed:0 };

let foods = [], enemies = [], bubbles = [], currents = [];
const MAX_FOOD = 250;
const WORLD_BOUND = 4200; // prevent escaping by clamping to a large world
let enemyIdCounter = 1;
let deathHandled = false; let pausedByContext = false;

// ---------- lore (expanded) ----------
const LORE = [
  {id:1,title:'The Great Flood',text:'Centuries ago, glaciers melted and ancient storms merged — sea levels rose and swallowed the coasts. Mountains became islands and valleys became trenches. Humanity tried to adapt but the scale was too great. The survivors went to the skies; the waters took the rest.'},
  {id:2,title:'The New Shoals',text:'Out of sunken cities and overturned forests, new ecosystems grew. Fish colonized skyscraper canyons, rivers became highways of plankton and algae. Shoals formed communities, some nomadic, some stationary around deep wrecks.'},
  {id:3,title:'The Hunger Wars',text:'Competition intensified. Shoals learned to hunt in packs, ambush smaller schools, and hide in thermoclines. The Hunger Wars reshaped behavior — cunning and cooperation often beat brute strength.'},
  {id:4,title:'Abyssal Relics',text:'Beneath the waves lie artifacts of a lost age: towers of glass, rusted bridges, and murals preserved in dark caverns. Many fish now make their dens among these relics, and stories — songs really — pass down about the world that was.'},
  {id:5,title:'The Currents Pact',text:'Some ancient currents stabilized into predictable routes. Fish learned these paths like highways: migrating predators follow them, schools use them to conserve energy, and entrepreneurs — if fish had them — would have found trade lanes.'},
  {id:6,title:'The Singing',text:'Fish developed complex calls — not words, but vibrations and light patterns — to mark territories and warn kin. These songs encode memory: where a reef used to be, which shoal vanished, which bubble of air remains deep below.'}
];
function renderLore(){ const el = document.getElementById('loreList'); if(!el) return; el.innerHTML = ''; for(const entry of LORE){ const d=document.createElement('div'); d.style.marginBottom='8px'; d.innerHTML = `<strong>${entry.title}</strong><div style="font-size:13px;opacity:0.95">${entry.text}</div>`; el.appendChild(d); } }
renderLore();

// skins & shop (SKINS still exist but skins UI removed; shop will show skins as purchasable/equippable items)
const SKINS = [
  {id:'classic',name:'Classic',color:'#ff9a66',emoji:'🐟',price:0},
  {id:'azure',name:'Azure',color:'#66d9ff',emoji:'🐠',price:250},
  {id:'neon',name:'Neon',color:'#b8ff6a',emoji:'🐡',price:420},
  {id:'scarlet',name:'Scarlet',color:'#ff3e3e',emoji:'🦈',price:600},
  {id:'gold',name:'Golden',color:'#ffd700',emoji:'🐟',price:900},
  {id:'shadow',name:'Shadow',color:'#6b6b6b',emoji:'👻',price:1200},
  {id:'coral',name:'Coral',color:'#ff9acc',emoji:'🐠',price:340},
  {id:'mint',name:'Mint',color:'#7effc6',emoji:'🐡',price:480},
  {id:'glow',name:'Glow',color:'#9a66ff',emoji:'✨',price:780},
  {id:'stripe',name:'Stripe',color:'#66ffda',emoji:'🎏',price:550}
];

const SHOP_ITEMS = [
  {id:'coin_small',name:'Coin Pack: 500',type:'consumable',desc:'Instant +500 coins',price:1200,effect:()=>{ player.coins += 500 }},
  {id:'coin_large',name:'Coin Pack: 3000',type:'consumable',desc:'Instant +3000 coins',price:5200,effect:()=>{ player.coins += 3000 }},
  {id:'speed_up',name:'Engine Upgrade',type:'upgrade',desc:'Permanent +40 base speed',price:2500,effect:()=>{ player.baseSpeed += 40 }},
  {id:'bubble_trail',name:'Bubble Trail',type:'cosmetic',desc:'Leaves a small bubble trail',price:900,effect:()=>{ player.trail='bubbles' }},
  {id:'deep_theme',name:'Abyss Theme',type:'theme',desc:'Darker deep-ocean background',price:3500,effect:()=>{ document.documentElement.style.setProperty('--bg-top','#0b3b5a'); document.documentElement.style.setProperty('--bg-bottom','#001428'); }},
  {id:'meal_box',name:'Meal Box',type:'consumable',desc:'Restores hunger +40',price:800,effect:()=>{ player.hunger = Math.min(100, player.hunger + 40); }},
  {id:'magnet',name:'Coin Magnet (30s)',type:'consumable',desc:'Attract small coins for 30s',price:1800,effect:()=>{ player.magnetUntil = Date.now()+30000; }},
  {id:'mega_pack',name:'Mega Coin Pack: 10,000',type:'consumable',desc:'Big coin boost',price:15000,effect:()=>{ player.coins += 10000 }},
  {id:'skin_pack',name:'Starter Skins',type:'bundle',desc:'Unlocks 2 skins',price:900,effect:()=>{ owned.add('azure'); owned.add('coral'); saveOwned(); }},
  {id:'speed_small',name:'Speed +15',type:'upgrade',desc:'Permanent +15 base speed',price:1200,effect:()=>{ player.baseSpeed += 15 }}
];

const owned = new Set(JSON.parse(localStorage.getItem('ownedSkins')||'["classic"]'));
let equipped = localStorage.getItem('equippedSkin') || 'classic';
function saveOwned(){ localStorage.setItem('ownedSkins', JSON.stringify(Array.from(owned))); localStorage.setItem('equippedSkin', equipped); }

// username handling + profanity filter
const usernameInput = document.getElementById('usernameInput'); const setNameBtn = document.getElementById('setNameBtn'); const nameErr = document.getElementById('nameErr');
let username = localStorage.getItem('playerName') || 'Guest'; if(ui.usernameDisplay) ui.usernameDisplay.textContent = username; if(usernameInput) usernameInput.value = (username==='Guest' ? '' : username);
const BANNED = ['fuck','shit','bitch','cunt','asshole','dick','bastard','damn','whore','motherfucker','nigger','faggot'];
function normalizeName(s){ s = s.toLowerCase(); const map = { '0':'o','1':'i','3':'e','4':'a','5':'s','7':'t','@':'a','$':'s' }; let out=''; for(const ch of s){ if(map[ch]) out += map[ch]; else if(/[a-z0-9]/.test(ch)) out += ch; } return out; }
function levenshtein(a,b){ if(a===b) return 0; const m=a.length, n=b.length; const dp = Array.from({length:m+1},(_,i)=>Array(n+1).fill(0)); for(let i=0;i<=m;i++) dp[i][0]=i; for(let j=0;j<=n;j++) dp[0][j]=j; for(let i=1;i<=m;i++){ for(let j=1;j<=n;j++){ const cost = a[i-1]===b[j-1]?0:1; dp[i][j] = Math.min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+cost); } } return dp[m][n]; }
function isNameAllowed(raw){ if(!raw || raw.trim().length<2) return {ok:false,reason:'Name too short'}; if(raw.length>20) return {ok:false,reason:'Name too long'}; if(/[!@#\$%\^&*\(\)\+={}\[\]|\;:'"<>,\?~`]/.test(raw)) return {ok:false,reason:'Name contains invalid symbols'}; const norm = normalizeName(raw); for(const bad of BANNED){ if(norm.includes(bad)) return {ok:false,reason:'Name contains disallowed word'}; const dist = levenshtein(norm, bad); if(dist <= 1) return {ok:false,reason:'Name contains disallowed or obfuscated word'}; } return {ok:true}; }
if(setNameBtn){
  setNameBtn.addEventListener('click', ()=>{
    const val = (usernameInput && usernameInput.value || '').trim();
    const ok = isNameAllowed(val);
    if(!ok.ok){ if(nameErr) nameErr.textContent = ok.reason; return; }
    username = val;
    localStorage.setItem('playerName', username);
    if(ui.usernameDisplay) ui.usernameDisplay.textContent = username;
    if(nameErr) nameErr.textContent='';
    showToast('Username accepted: ' + username, 1800);
    if(usernameInput) usernameInput.value = username;
    uploadPlayerState();
  });
}

// Mobile control style handling: floating joystick vs touch-anywhere
let mobileStyle = localStorage.getItem('mobileStyle') || (document.getElementById('mobileStyle') ? document.getElementById('mobileStyle').value : 'floating');
if(document.getElementById('mobileStyle')) document.getElementById('mobileStyle').value = mobileStyle;
if(document.getElementById('mobileStyle')) document.getElementById('mobileStyle').addEventListener('change',(e)=>{ mobileStyle = e.target.value; localStorage.setItem('mobileStyle', mobileStyle); updateControlUI(); });

// whether device supports touch
const isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints && navigator.maxTouchPoints>0);
// allow user to enable mobile testing on desktop
const allowTestCheckbox = document.getElementById('allowMobileTest'); if(allowTestCheckbox){ allowTestCheckbox.checked = localStorage.getItem('allowMobileTest') === '1'; allowTestCheckbox.addEventListener('change',(e)=>{ localStorage.setItem('allowMobileTest', e.target.checked ? '1' : '0'); updateMobileOptionVisibility(); updateControlUI(); }); }
function updateMobileOptionVisibility(){ const show = isTouch || (allowTestCheckbox && allowTestCheckbox.checked); const cmEl = document.getElementById('controlMode'); if(cmEl){ for(const opt of cmEl.options){ if(opt.value==='mobile'){ opt.style.display = show ? 'block' : 'none'; } } if(cmEl.value==='mobile' && !show){ cmEl.value='mouse'; controlMode='mouse'; localStorage.setItem('controlMode','mouse'); } } }

// helper: generate enemy names
function genEnemyName(){ const adj = ['Drift','Wave','Coral','Reef','Bram','Glim','Scale','Torrent','Murk','Glint']; const suf = Math.floor(Math.random()*999); return adj[Math.floor(Math.random()*adj.length)] + '_' + suf; }

// shop rendering (with small color thumbnails for skins)
function renderShop(filter='',sortBy='price-asc'){ const shopItemsEl = document.getElementById('shopItems'); if(!shopItemsEl) return; shopItemsEl.innerHTML=''; let list = SHOP_ITEMS.concat(SKINS.map(s=>Object.assign({type:'skin'},s))).filter(i=>i.name.toLowerCase().includes((filter||'').toLowerCase())); if(sortBy==='price-asc') list.sort((a,b)=>a.price-b.price); if(sortBy==='price-desc') list.sort((a,b)=>b.price-a.price); if(sortBy==='name') list.sort((a,b)=>a.name.localeCompare(b.name));
 for(const it of list){ const row = document.createElement('div'); row.className='shop-row'; const left = document.createElement('div');
    let thumb = '';
    if(it.type==='skin' || it.color){ thumb = `<div style="width:56px;height:40px;border-radius:8px;background:${it.color||'#999'};display:inline-block;margin-right:8px;vertical-align:middle;border:2px solid rgba(255,255,255,0.06)"></div>`; }
    left.innerHTML = `${thumb}<div style="display:inline-block;vertical-align:middle"><div style=\"font-weight:800\">${it.name}</div><div style=\"font-size:12px;opacity:0.9\">${it.desc||''}</div></div>`;
    const right = document.createElement('div'); const price = document.createElement('div'); price.style.fontWeight='800'; price.style.marginRight='8px'; price.textContent = it.price + ' c'; const btn = document.createElement('button'); btn.className='btn';
    const affordable = player.coins >= it.price;
    if(it.type==='skin'){ btn.textContent = owned.has(it.id)?(equipped===it.id?'Equipped':'Equip'):'Buy'; if(!owned.has(it.id) && !affordable) btn.disabled=true; btn.onclick=()=>{ if(owned.has(it.id)){ equipped = it.id; player.color = it.color; saveOwned(); showToast(it.name + ' equipped'); renderShop(document.getElementById('shopSearch')?document.getElementById('shopSearch').value:'', document.getElementById('shopSort')?document.getElementById('shopSort').value:'price-asc'); } else { if(player.coins >= it.price){ player.coins -= it.price; owned.add(it.id); equipped = it.id; player.color = it.color; saveOwned(); showToast('Purchased and equipped ' + it.name); renderShop(document.getElementById('shopSearch')?document.getElementById('shopSearch').value:'', document.getElementById('shopSort')?document.getElementById('shopSort').value:'price-asc'); ui.coinsEl.textContent = player.coins; } else showToast('Not enough coins'); } };
    } else { btn.textContent = 'Buy'; if(!affordable) btn.disabled=true; btn.onclick = ()=>{ if(player.coins >= it.price){ player.coins -= it.price; try{ if(it.effect) it.effect(); }catch(e){} showToast('Purchased ' + it.name); ui.coinsEl.textContent = player.coins; } else showToast('Not enough coins'); } }
    right.style.display='flex'; right.style.alignItems='center'; right.appendChild(price); right.appendChild(btn); row.appendChild(left); row.appendChild(right); shopItemsEl.appendChild(row); }
}

if(document.getElementById('shopSearch')) document.getElementById('shopSearch').addEventListener('input',(e)=>renderShop(e.target.value, document.getElementById('shopSort')?document.getElementById('shopSort').value:'price-asc'));
if(document.getElementById('shopSort')) document.getElementById('shopSort').addEventListener('change',(e)=>renderShop(document.getElementById('shopSearch')?document.getElementById('shopSearch').value:'', e.target.value));
renderShop();

// ---------- spawning & world management (infinite-ish) ----------
function randBetween(a,b){ return a + Math.random()*(b-a); }
function spawnFoodAround(cx,cy){ if(foods.length>MAX_FOOD) return; const angle = Math.random()*Math.PI*2; const dist = 300 + Math.random()*1200; const f={ x: cx + Math.cos(angle)*dist, y: cy + Math.sin(angle)*dist, size: 3 + Math.random()*6, wobble: Math.random()*Math.PI*2, color:'#fff59d' }; foods.push(f); }
function spawnEnemyRelative(cx,cy,opts={offlineBot:true}){ const base = 10 + Math.random()*36; const rel = Math.random()*player.size*0.9; const size = Math.max(8, Math.min(player.size*2.2, base + rel)); const e = { id: enemyIdCounter++, x: cx + (Math.random()-0.5)*1600, y: cy + (Math.random()-0.5)*1600, size, speed: 30 + Math.random()*110, angle: Math.random()*Math.PI*2, color: '#ff6b6b', state:'wander', target:null, hunger:100, name: genEnemyName(), offlineBot: !!opts.offlineBot }; enemies.push(e); }
function spawnBubbleAround(cx,cy){ bubbles.push({ x: cx + (Math.random()-0.5)*800, y: cy + (Math.random()-0.5)*800, r: 3+Math.random()*8, vy: 20+Math.random()*60, alpha: 0.08+Math.random()*0.18 }); }

// ensure there's always at least one fish larger than player but not absurd
let lastLargeSpawn = 0;
function ensureLargerExists(nearbyCount, allowBots){ if(!allowBots) return; let largest = player.size; for(const e of enemies) if(e.size>largest) largest=e.size; const refSize = Math.max(player.size, 8); const now = performance.now(); if(largest <= refSize * 1.05){ if(now - lastLargeSpawn > 3500 && nearbyCount < 28){ const sz = Math.min(refSize*1.9, refSize * (1.2 + Math.random()*0.6)); const e = { id: enemyIdCounter++, x: player.x + (Math.random()-0.5)*1200, y: player.y + (Math.random()-0.5)*1200, size: Math.max(sz, refSize+6), speed: 40 + Math.random()*80, angle: Math.random()*Math.PI*2, color: '#d45b5b', state:'wander', target:null, hunger:100, name: genEnemyName(), offlineBot:true }; enemies.push(e); lastLargeSpawn = now; } } }

// trim distant entities to keep runtime manageable
function trimEntities(){ const R = Math.max(window.innerWidth, window.innerHeight) * 4; foods = foods.filter(f=>Math.hypot(f.x-player.x,f.y-player.y) < R); enemies = enemies.filter(e=>Math.hypot(e.x-player.x,e.y-player.y) < R*1.5); bubbles = bubbles.filter(b=>Math.hypot(b.x-player.x,b.y-player.y) < R); }

// initial populate
for(let i=0;i<110;i++) spawnFoodAround(player.x, player.y);
for(let i=0;i<12;i++) spawnEnemyRelative(player.x, player.y);
for(let i=0;i<80;i++) spawnBubbleAround(player.x, player.y);

// ---------- input ----------
let controlMode = localStorage.getItem('controlMode') || 'mouse';
const controlModeSelect = document.getElementById('controlMode');
if(controlModeSelect){ controlModeSelect.value = controlMode; controlModeSelect.addEventListener('change', e=>{ controlMode = e.target.value; const homeControl = document.getElementById('homeControlMode'); if(homeControl) homeControl.value = controlMode; localStorage.setItem('controlMode', controlMode); updateControlUI(); }); }
const homeControl = document.getElementById('homeControlMode'); if(homeControl){ homeControl.value = controlMode; homeControl.addEventListener('change', e=>{ controlMode = e.target.value; if(controlModeSelect) controlModeSelect.value = controlMode; localStorage.setItem('controlMode', controlMode); updateControlUI(); }); }

let pointerX=null,pointerY=null; let keys = {};

// UI helper: show/hide mobile controls based on selected mode and style (minimal change)
function updateControlUI(){ const joy = document.getElementById('joystick'); const boost = document.getElementById('boostMobile'); if(!joy || !boost) return; if(controlMode === 'mobile' && mobileStyle === 'floating'){ joy.style.display = 'flex'; boost.style.display = 'block'; } else if(controlMode === 'mobile' && mobileStyle === 'touch'){ joy.style.display = 'none'; boost.style.display = 'block'; } else { joy.style.display = 'none'; boost.style.display = 'none'; try{ usingJoy = false; lastJoyStrength = 0; touchAnywhereStart = null; }catch(e){} } }
// initial UI sync
setTimeout(()=>{ updateMobileOptionVisibility(); updateControlUI(); }, 10);

window.addEventListener('mousemove', e=>{ if(overlayVisible()) return; if(controlMode==='mouse'){ pointerX = e.clientX; pointerY = e.clientY; } });
window.addEventListener('mousedown', e=>{ if(overlayVisible()) return; if(e.button===2){ boosting = true; } });
window.addEventListener('mouseup', e=>{ if(overlayVisible()) return; if(e.button===2){ boosting = false; } });

// --- MOBILE DRAG & pointer handling (kept) ---
let touchAnywhereStart = null;
window.addEventListener('touchmove', (e)=>{ if(overlayVisible()) return; const t = e.touches[0]; if(!t) return; pointerX = t.clientX; pointerY = t.clientY; e.preventDefault(); }, {passive:false});
window.addEventListener('touchend', (e)=>{ if(overlayVisible()) return; pointerX = null; pointerY = null; touchAnywhereStart = null; });
window.addEventListener('touchcancel', (e)=>{ pointerX = null; pointerY = null; touchAnywhereStart = null; }, {passive:false});

window.addEventListener('keydown', e=>{ if(overlayVisible()) return; keys[e.key.toLowerCase()] = true; if(e.key===' '){ e.preventDefault(); boosting=true; } if(e.key==='Shift'){ boosting=true; } }); window.addEventListener('keyup', e=>{ if(overlayVisible()) return; keys[e.key.toLowerCase()] = false; if(e.key===' '){ boosting=false; } if(e.key==='Shift'){ boosting=false; } });

// boost button supports pointer events for reliability
const boostBtn = document.getElementById('boostMobile'); if(boostBtn){ boostBtn.addEventListener('pointerdown', (e)=>{ if(overlayVisible()) return; boosting=true; e.preventDefault(); }); boostBtn.addEventListener('pointerup', ()=>{ boosting=false; }); boostBtn.addEventListener('pointercancel', ()=>{ boosting=false; }); boostBtn.addEventListener('touchstart', (e)=>{ if(overlayVisible()) return; boosting=true; e.preventDefault(); }, {passive:false}); boostBtn.addEventListener('touchend', ()=>{ boosting=false; }); boostBtn.addEventListener('touchcancel', ()=>{ boosting=false; }); }
let boosting=false;

// joystick: pointer events for better cross-device support
const joystick = document.getElementById('joystick'); const stick = document.getElementById('stick'); let usingJoy=false; let joyCenter = null; let joyPointerId = null; let lastJoyStrength = 0;
function joyPointerDown(e){ if(overlayVisible()) return; if(controlMode !== 'mobile' || mobileStyle !== 'floating') return; usingJoy=true; joyPointerId = e.pointerId; e.preventDefault(); const rect = joystick.getBoundingClientRect(); joyCenter = {x: rect.left+rect.width/2, y: rect.top+rect.height/2}; }
function joyPointerMove(e){ if(!usingJoy) return; if(joyPointerId!=null && e.pointerId !== joyPointerId) return; e.preventDefault(); const cx = joyCenter.x, cy = joyCenter.y; const dx = Math.max(-36, Math.min(36, e.clientX - cx)); const dy = Math.max(-36, Math.min(36, e.clientY - cy)); stick.style.transform = `translate(${dx}px,${dy}px)`; pointerX = cx + dx*1.6; pointerY = cy + dy*1.6; lastJoyStrength = Math.min(1, Math.hypot(dx,dy)/36); }
function joyPointerUp(e){ if(joyPointerId!=null && e.pointerId !== joyPointerId) return; usingJoy=false; joyPointerId = null; stick.style.transform='translate(0,0)'; pointerX=null; pointerY=null; lastJoyStrength = 0; try{ const joy = document.getElementById('joystick'); if(joy && joy._orig){ joy.style.position = joy._orig.position; joy.style.left = joy._orig.left; joy.style.top = joy._orig.top; joy.style.bottom = joy._orig.bottom; delete joy._orig; } if(joy) delete joy._touch; }catch(err){} }
if(joystick){ joystick.addEventListener('pointerdown', joyPointerDown); window.addEventListener('pointermove', joyPointerMove); window.addEventListener('pointerup', joyPointerUp); }

// pointer fallback
window.addEventListener('pointerdown', (e)=>{
  try{
    if(overlayVisible()) return;
    if(e.pointerType === 'touch'){
      if(controlMode === 'mobile'){
        pointerX = e.clientX; pointerY = e.clientY;
        const joyEl = document.getElementById('joystick');
        if(mobileStyle === 'floating' && joyEl && !joyEl.contains(e.target) && !joyEl._touch){
          if(!joyEl._orig) joyEl._orig = {left: joyEl.style.left || '', bottom: joyEl.style.bottom || '', top: joyEl.style.top || '', position: joyEl.style.position || ''};
          joyEl.style.position = 'fixed'; joyEl.style.left = (e.clientX - joyEl.offsetWidth/2) + 'px'; joyEl.style.top = (e.clientY - joyEl.offsetHeight/2) + 'px'; joyEl.style.bottom = '';
          usingJoy = true; joyEl._touch = true; const rect = joyEl.getBoundingClientRect(); joyCenter = {x: rect.left+rect.width/2, y: rect.top+rect.height/2}; pointerX = joyCenter.x; pointerY = joyCenter.y; stick.style.transform = 'translate(0,0)'; lastJoyStrength = 0;
        }
      } else if(controlMode === 'mouse'){
        pointerX = e.clientX; pointerY = e.clientY;
      }
    }
  }catch(err){}
}, {passive:false});
window.addEventListener('pointermove', (e)=>{
  try{
    if(overlayVisible()) return;
    if(e.pointerType === 'touch'){
      if(usingJoy && joyCenter && controlMode==='mobile' && mobileStyle==='floating'){
        const dx = Math.max(-36, Math.min(36, e.clientX - joyCenter.x));
        const dy = Math.max(-36, Math.min(36, e.clientY - joyCenter.y));
        stick.style.transform = `translate(${dx}px,${dy}px)`;
        pointerX = joyCenter.x + dx*1.6; pointerY = joyCenter.y + dy*1.6; lastJoyStrength = Math.min(1, Math.hypot(dx,dy)/36);
        e.preventDefault();
        return;
      }
      if(controlMode === 'mobile' && mobileStyle === 'touch' && touchAnywhereStart){
        const dx = e.clientX - touchAnywhereStart.x; const dy = e.clientY - touchAnywhereStart.y; lastJoyStrength = Math.min(1, Math.hypot(dx,dy)/160);
        pointerX = e.clientX; pointerY = e.clientY; e.preventDefault(); return;
      }
      if(controlMode === 'mouse' || controlMode === 'mobile'){ pointerX = e.clientX; pointerY = e.clientY; }
    }
  }catch(err){}
}, {passive:false});
window.addEventListener('pointerup', (e)=>{
  try{
    if(e.pointerType === 'touch'){
      pointerX = null; pointerY = null; touchAnywhereStart = null; try{ const joy = document.getElementById('joystick'); if(joy && joy._orig){ joy.style.position = joy._orig.position; joy.style.left = joy._orig.left; joy.style.top = joy._orig.top; joy.style.bottom = joy._orig.bottom; delete joy._orig; } if(joy) delete joy._touch; }catch(e){}
      usingJoy = false; lastJoyStrength = 0;
    }
  }catch(err){}
});

// ---------- audio (WebAudio improved) ----------
const AudioContext = window.AudioContext || window.webkitAudioContext; let audioCtx=null, masterGain=null, ambGain=null;
function ensureAudio(){ if(!audioCtx){ audioCtx = new AudioContext(); masterGain = audioCtx.createGain(); masterGain.gain.value = 0.07; masterGain.connect(audioCtx.destination);
    ambGain = audioCtx.createGain(); ambGain.gain.value = 0.02; ambGain.connect(masterGain);
    const pad = audioCtx.createOscillator(); pad.type = 'sine'; pad.frequency.value = 80; const padFilter = audioCtx.createBiquadFilter(); padFilter.type = 'lowpass'; padFilter.frequency.value = 600; pad.connect(padFilter); padFilter.connect(ambGain); pad.start();
    const bufferSize = 2*audioCtx.sampleRate; const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate); const data = noiseBuffer.getChannelData(0); for(let i=0;i<bufferSize;i++){ data[i] = (Math.random()*2-1)*0.02; } const nb = audioCtx.createBufferSource(); nb.buffer = noiseBuffer; nb.loop=true; const nGain = audioCtx.createGain(); nGain.gain.value = 0.01; nb.connect(nGain); nGain.connect(masterGain); nb.start(); } }
function playEat(){ if(!audioCtx) return; const now = audioCtx.currentTime; const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type='triangle'; o.frequency.setValueAtTime(700, now); o.frequency.exponentialRampToValueAtTime(330, now+0.12); g.gain.setValueAtTime(0.12, now); g.gain.exponentialRampToValueAtTime(0.001, now+0.12); o.connect(g); g.connect(masterGain); o.start(now); o.stop(now+0.14); }
function playBoost(){ if(!audioCtx) return; const now = audioCtx.currentTime; const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type='sawtooth'; o.frequency.setValueAtTime(240, now); o.frequency.exponentialRampToValueAtTime(720, now+0.12); g.gain.setValueAtTime(0.06, now); g.gain.exponentialRampToValueAtTime(0.001, now+0.12); o.connect(g); g.connect(masterGain); o.start(now); o.stop(now+0.16); }
function playDeath(){ if(!audioCtx) return; const now = audioCtx.currentTime; const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type='sawtooth'; o.frequency.setValueAtTime(240, now); o.frequency.exponentialRampToValueAtTime(40, now+0.9); g.gain.setValueAtTime(0.28, now); g.gain.exponentialRampToValueAtTime(0.001, now+0.9); o.connect(g); g.connect(masterGain); o.start(now); o.stop(now+0.95); }
function ensureAudioStarted(){ try{ ensureAudio(); } catch(e){} }

// ---------- Firebase (compat) ----------
// keep firebaseConfig as before (update to your project values if needed)
const firebaseConfig = {
  apiKey: "AIzaSyCK2mIqOVp1d0VV3C6dycHTvnVtaE4CspQ",
  authDomain: "aqua-odyssey.firebaseapp.com",
  databaseURL: "https://aqua-odyssey-default-rtdb.firebaseio.com",
  projectId: "aqua-odyssey",
  storageBucket: "aqua-odyssey.firebasestorage.app",
  messagingSenderId: "54640172756",
  appId: "1:54640172756:web:608837b0b971f896812541",
  measurementId: "G-ZZBZERRPCH"
};

let onlinePlayers = {}; // map uid -> {username,score,timestamp,x,y,room}
let remotePlayers = {}; // uid -> enemy object reference for rendering in-world

// current room state for this client (null = public)
let currentRoom = { code: null, friendsOnly: false, owner: null, center: null };
let allowBots = true; // toggled off when in friends-only rooms

// spectating state
let spectatingUid = null;
let spectateModeEnabled = false;

function updateConnUI(connected, pingMs=null){
  const dot = document.getElementById('connIndicator'); const text = document.getElementById('connText'); const msEl = document.getElementById('connMs');
  if(dot && text){
    if(connected){ dot.style.background='#4caf50'; text.textContent='Online'; if(msEl) msEl.textContent = pingMs ? `${Math.round(pingMs)} ms` : ''; }
    else { dot.style.background='#999'; text.textContent='Offline'; if(msEl) msEl.textContent = ''; }
  }
}

// init firebase and auth anonymously, subscribe to players
function ensureFirebaseConnected(){
  if(firebaseConnected) return Promise.resolve(true);
  try{
    if(typeof firebase === 'undefined'){ throw new Error('firebase SDK is not loaded'); }
    firebaseApp = firebase.initializeApp(firebaseConfig);
    firebaseAuth = firebase.auth();
    firebaseDB = firebase.database();
    return firebaseAuth.signInAnonymously().then(cred=>{
      firebaseUid = cred.user.uid;
      console.log('Signed into Firebase as', firebaseUid);
      const pingPath = '/ping_test/'+firebaseUid;
      const start = performance.now();
      return firebaseDB.ref(pingPath).set({ts:Date.now()}).then(()=>{
        const pingMs = performance.now() - start;
        firebaseConnected = true;
        updateConnUI(true, pingMs);
        // subscribe to players; handle permission errors gracefully
        try{
          firebaseDB.ref('/players').on('value', snap=>{
            const val = snap.val() || {};
            onlinePlayers = val;
            syncRemotePlayers(onlinePlayers);
            rebuildLeaderboards();
          }, err=>{
            console.error('players.on error', err);
            // if permission denied, mark disconnected (UI + local)
            if(err && err.code === 'PERMISSION_DENIED'){
              firebaseConnected = false; updateConnUI(false);
              showToast('Firebase permission denied: check your RTDB rules and auth.', 3500);
            }
          });
        } catch(e){
          console.error('subscribe failed', e);
        }
        // try to write initial player object (safe)
        try{
          firebaseDB.ref('/players/'+firebaseUid).set({username: username || 'Guest', score: player.score||0, ts: Date.now(), x: player.x, y: player.y, size: player.size, room: currentRoom.code || null}).catch(err=>{
            console.error('write players failed', err);
            if(err && err.code === 'PERMISSION_DENIED'){
              firebaseConnected = false; updateConnUI(false); showToast('Firebase permission denied — offline mode.',2200);
            }
          });
        }catch(e){}
        return true;
      }).catch(err=>{
        console.error('ping failed', err);
        firebaseConnected = false;
        updateConnUI(false);
        showToast('Could not fully connect to Firebase — continuing in offline mode.',3800);
        return false;
      });
    }).catch(err=>{
      console.error('auth failed', err);
      firebaseConnected = false;
      updateConnUI(false);
      showToast('Firebase auth failed — offline mode.',2200);
      return false;
    });
  } catch(e){
    console.error('firebase init error', e);
    firebaseConnected = false;
    updateConnUI(false);
    showToast('Firebase not available — offline mode.',2000);
    return Promise.resolve(false);
  }
}

// upload local player state to firebase (if connected)
function uploadPlayerState(){
  if(!firebaseConnected || !firebaseDB || !firebaseUid) return;
  const p = {username: username || 'Guest', score: player.score||0, ts: Date.now(), size: player.size||0, x: player.x||0, y: player.y||0, room: currentRoom.code || null};
  firebaseDB.ref('/players/' + firebaseUid).set(p).catch(err=>{
    console.error('upload player failed', err);
    if(err && err.code === 'PERMISSION_DENIED'){
      updateConnUI(false);
      firebaseConnected = false;
      showToast('Firebase permission denied — offline mode.',2200);
    }
  });
  try{
    firebaseDB.ref('/bestScores/' + firebaseUid).transaction(curr=>{
      if(!curr || (player.score || 0) > (curr.best || 0)){
        return { best: player.score || 0, username: username || 'Guest', uid: firebaseUid, ts: Date.now() };
      }
      return;
    }).catch(err=>{ console.warn('bestScores transaction failed', err); });
  }catch(e){}
}

// remove player from online list when leaving (best effort)
function removePlayerOnLeave(){
  if(firebaseConnected && firebaseDB && firebaseUid){
    try{ firebaseDB.ref('/players/'+firebaseUid).remove(); }catch(e){}
  }
}
window.addEventListener('beforeunload', ()=>{ removePlayerOnLeave(); });

// ---------- Remote player sync: only show players in same room ----------
function isSameRoomForClient(playerObj){
  const theirRoom = playerObj && (playerObj.room===undefined ? null : playerObj.room);
  const myRoom = currentRoom.code || null;
  if(myRoom === null || myRoom === undefined) {
    return (theirRoom === null || theirRoom === undefined || theirRoom === '');
  }
  return theirRoom === myRoom;
}

function syncRemotePlayers(playersObj){
  const seen = new Set();
  for(const uid in playersObj){
    if(uid === firebaseUid) continue;
    const p = playersObj[uid];
    if(!isSameRoomForClient(p)) continue;
    seen.add(uid);
    if(remotePlayers[uid]){
      const ent = remotePlayers[uid]; ent.x = p.x !== undefined ? p.x : ent.x; ent.y = p.y !== undefined ? p.y : ent.y; ent.size = p.size || ent.size; ent.name = p.username || ent.name; ent.color = ent.color || '#66ccff';
    } else {
      const ent = { id: 'rp_' + uid, x: (p.x!==undefined? p.x : player.x + (Math.random()-0.5)*300), y: (p.y!==undefined? p.y : player.y + (Math.random()-0.5)*300), size: p.size || 12, speed: 40 + Math.random()*80, angle: Math.random()*Math.PI*2, color: '#66ccff', state:'wander', name: p.username || 'Player', remoteUid: uid, isRemote:true };
      enemies.push(ent); remotePlayers[uid] = ent;
    }
  }
  for(const uid in remotePlayers){ if(!seen.has(uid)){ const ent = remotePlayers[uid]; const idx = enemies.indexOf(ent); if(idx>=0) enemies.splice(idx,1); delete remotePlayers[uid]; } }
}

// ---------- Leaderboard handling (NO BOTS IN UI) ----------
function rebuildLeaderboards(){
  // Only include real online players from Firebase (if connected). Always include the local player's row (me).
  const list = [];
  if(firebaseConnected){
    for(const uid in onlinePlayers){
      const p = onlinePlayers[uid];
      if(isSameRoomForClient(p)){
        list.push({id: uid, username: (p.username||'Guest'), score: p.score||0, online:true});
      }
    }
  }
  // Always add your own local entry so player sees their score
  list.push({id:'__me', username: username || 'Guest', score: player.score||0, me:true});
  // Sort by score descending
  list.sort((a,b)=>b.score - a.score);
  // Render mini and full leader now
  renderMiniLeader(list.slice(0,10));
  renderFullLeaderFullHistoric(list);
}

function renderMiniLeader(list){
  const miniList = document.getElementById('miniList'); if(!miniList) return;
  miniList.innerHTML = '';
  if(!list || list.length===0){
    miniList.innerHTML = '<div style="opacity:0.9;padding:6px">No players online</div>';
    const miniYou = document.getElementById('miniYou'); if(miniYou) miniYou.textContent = `You: ${player.score||0}`;
    const miniCount = document.getElementById('miniCount'); if(miniCount) miniCount.textContent = `0`;
    return;
  }
  list.forEach((p, idx)=>{
    const row = document.createElement('div'); row.className='lb-row';
    const left = document.createElement('div'); left.style.fontWeight = p.me ? '800' : '600'; left.style.fontSize='13px';
    left.textContent = `${idx+1}. ${p.username}`;
    const right = document.createElement('div'); right.style.opacity=0.95; right.textContent = p.score;
    row.appendChild(left); row.appendChild(right); miniList.appendChild(row);
  });
  const myEntry = list.find(i=>i.me) || list.find(i=>i.username === username);
  const miniYou = document.getElementById('miniYou'); if(miniYou) miniYou.textContent = myEntry ? `You: ${myEntry.score}` : `You: ${player.score||0}`;
  const miniCount = document.getElementById('miniCount'); if(miniCount) miniCount.textContent = `${list.length}`;
}

function renderFullLeaderFullHistoric(prebuiltList){
  const el = document.getElementById('leaderboardList'); if(!el) return;
  el.innerHTML = '';
  const search = (document.getElementById('leaderboardSearch') && document.getElementById('leaderboardSearch').value) || '';
  const filter = (document.getElementById('leaderboardFilter') && document.getElementById('leaderboardFilter').value) || 'all';
  // Use provided list (from rebuild) or compute from onlinePlayers
  let merged = prebuiltList || [];
  if(!merged || merged.length===0){
    if(firebaseConnected){
      for(const uid in onlinePlayers){
        merged.push({id:uid, username:onlinePlayers[uid].username||'Guest', score:onlinePlayers[uid].score||0, online:true});
      }
    }
    merged.push({id:'__me', username: username || 'Guest', score: player.score||0, me:true});
  }
  let arr = merged.slice();
  if(search) arr = arr.filter(x=>x.username.toLowerCase().includes(search.toLowerCase()));
  if(filter==='online') arr = arr.filter(x=>x.online);
  if(filter==='offline') arr = arr.filter(x=>!x.online && !x.me);
  // Note: bots are deliberately NOT included in the UI lists
  arr.slice(0,200).forEach((p,idx)=>{
    const r = document.createElement('div'); r.style.display='flex'; r.style.justifyContent='space-between'; r.style.padding='6px 0'; r.style.borderBottom='1px solid rgba(255,255,255,0.03)';
    const leftWrap = document.createElement('div'); leftWrap.style.display='flex'; leftWrap.style.alignItems='center'; leftWrap.style.gap='8px';
    const nameDiv = document.createElement('div'); nameDiv.style.fontWeight = p.me ? '800' : '600'; nameDiv.innerHTML = `${idx+1}. ${p.username}${p.online?'<span style="opacity:0.7;margin-left:6px">(online)</span>':''}`;
    leftWrap.appendChild(nameDiv);
    const rightDiv = document.createElement('div'); rightDiv.style.opacity=0.95; rightDiv.textContent = p.score;
    const btnWrap = document.createElement('div'); btnWrap.style.display='flex'; btnWrap.style.gap='6px'; btnWrap.style.alignItems='center';
    if(p.id !== '__me' && p.id && typeof p.id === 'string' && p.id.indexOf('bot_') === -1){
      const specBtn = document.createElement('button'); specBtn.className='btn'; specBtn.textContent = 'Spectate'; specBtn.style.padding='6px 8px';
      specBtn.onclick = ()=>{ if(!firebaseConnected){ showToast('Connect Firebase to spectate players.'); return; } if(p.id === firebaseUid){ showToast('Cannot spectate yourself'); return; } spectatePlayer(p.id); };
      btnWrap.appendChild(specBtn);
    }
    r.appendChild(leftWrap);
    const rightArea = document.createElement('div'); rightArea.style.display='flex'; rightArea.style.alignItems='center'; rightArea.style.gap='8px';
    rightArea.appendChild(rightDiv);
    rightArea.appendChild(btnWrap);
    r.appendChild(rightArea);
    el.appendChild(r);
  });
}

// search handler for mini
const miniSearchEl = document.getElementById('miniSearch'); if(miniSearchEl) miniSearchEl.addEventListener('input',(e)=>{
  const q = e.target.value.toLowerCase();
  const merged = [];
  if(firebaseConnected){
    for(const uid in onlinePlayers){
      const p = onlinePlayers[uid];
      if(isSameRoomForClient(p)){
        merged.push({id:uid, username:p.username||'Guest', score:p.score||0, online:true});
      }
    }
  }
  merged.push({id:'__me', username: username || 'Guest', score: player.score||0, me:true});
  const res = merged.filter(x=>x.username.toLowerCase().includes(q)).sort((a,b)=>b.score-a.score).slice(0,10);
  renderMiniLeader(res);
});

// mini toggle (collapse/expand)
const miniToggle = document.getElementById('miniToggle'); if(miniToggle){ miniToggle.addEventListener('click', ()=>{
  const mini = document.getElementById('miniLeaderboard');
  if(!mini) return;
  mini.classList.toggle('small');
  const t = document.getElementById('miniToggle');
  t.textContent = mini.classList.contains('small') ? '▼' : '▲';
}); }

// find myself in full leaderboard
function findMeInFull(){ const panel = document.getElementById('leaderboardPanel'); if(!panel) return; panel.classList.remove('hidden'); const homeInfoE = document.getElementById('homeInfo'); if(homeInfoE) homeInfoE.classList.add('hidden'); renderFullLeaderFullHistoric(); }
const findMeBtn = document.getElementById('findMeBtn'); if(findMeBtn) findMeBtn.addEventListener('click', ()=>{ findMeInFull(); });

// ---------- ensure bots appear in-game only (not UI) ----------
function ensureOfflineBotsVisible(){ if(Math.random() < 0.06) { if(enemies.length < 40) for(let i=0;i<4;i++) spawnEnemyRelative(player.x, player.y); } }

// ---------- spawning tweaks: spawn player randomly near center (not always 0,0) ----------
function setRandomSpawn(){ player.x = (Math.random()*2 - 1) * (WORLD_BOUND * 0.5); player.y = (Math.random()*2 - 1) * (WORLD_BOUND * 0.5); }

// ---------- update & AI ----------
function handleBounds(){ let clamped=false; if(player.x < -WORLD_BOUND){ player.x = -WORLD_BOUND; clamped=true; } if(player.x > WORLD_BOUND){ player.x = WORLD_BOUND; clamped=true; } if(player.y < -WORLD_BOUND){ player.y = -WORLD_BOUND; clamped=true; } if(player.y > WORLD_BOUND){ player.y = WORLD_BOUND; clamped=true; } if(clamped){ for(let i=0;i<2;i++) spawnEnemyRelative(player.x + randBetween(-200,200), player.y + randBetween(-200,200)); player.hunger = Math.max(0, player.hunger - 8); } }

function update(dt){ if(!running) return;
  const nearbyCount = enemies.filter(e=>Math.hypot(e.x-player.x,e.y-player.y) < 1600).length;
  const densityFactor = Math.max(0.08, 1 - nearbyCount/80);
  const spawnSpeedFactor = player.speed < 3 ? 0.32 : 1;
  const spawnFactor = player.alive ? spawnSpeedFactor : 0.06;

  const allowSpawnBots = allowBots;

  if(Math.random() < 0.12 * spawnFactor * densityFactor) spawnFoodAround(player.x, player.y);
  if(allowSpawnBots && Math.random() < 0.004 * spawnFactor * densityFactor) spawnEnemyRelative(player.x, player.y);
  if(Math.random() < 0.08 * spawnFactor * densityFactor) spawnBubbleAround(player.x, player.y);

  let vx=0, vy=0;
  if(player.alive){
    if(((controlMode==='mouse') || (controlMode==='mobile' && mobileStyle==='touch')) && pointerX!=null && pointerY!=null){ const w = screenToWorld(pointerX, pointerY); vx = w.x - player.x; vy = w.y - player.y; }
    if(controlMode==='keyboard'){ if(keys['w']||keys['arrowup']) vy-=1; if(keys['s']||keys['arrowdown']) vy+=1; if(keys['a']||keys['arrowleft']) vx-=1; if(keys['d']||keys['arrowright']) vx+=1; }
    const mag = Math.hypot(vx,vy);
    let movingSpeed = 0;
    if(mag>0.01){ player.angle = Math.atan2(vy, vx); const speedFactor = player.baseSpeed * (1 - Math.min(0.75, (player.size-8)/300)); let sp = speedFactor * (1 + (boosting?1.2:0));
      if(controlMode==='keyboard' && boosting) sp *= 1.4;
      if(usingJoy || (controlMode==='mobile' && touchAnywhereStart)){
        sp *= Math.max(0.18, Math.min(1, lastJoyStrength));
      }
      const dx = Math.cos(player.angle) * sp * dt/1000; const dy = Math.sin(player.angle) * sp * dt/1000; player.x += dx; player.y += dy; movingSpeed = Math.hypot(dx,dy) / (dt/1000);
      if(boosting){ player.size = Math.max(8, player.size - 0.05 * dt/1000); player.hunger = Math.max(0, player.hunger - 0.12 * dt/1000); playBoost(); }
    } else {
      const dx = Math.cos(player.angle) * 8 * dt/1000; const dy = Math.sin(player.angle) * 8 * dt/1000; player.x += dx; player.y += dy; movingSpeed = Math.hypot(dx,dy)/(dt/1000);
    }
    player.vx = movingSpeed * Math.cos(player.angle); player.vy = movingSpeed * Math.sin(player.angle); player.speed = movingSpeed;
  } else {
    player.vx = 0; player.vy = 0; player.speed = 0;
  }

  handleBounds();

  const baseDecay = dt/5000 * Math.max(0.6, player.size/24);
  const movementDecay = (player.speed/80) * (dt/1000) * Math.max(0.8, player.size/24);
  player.hunger -= baseDecay + movementDecay;
  if(ui.hungerEl) ui.hungerEl.style.width = Math.max(0, player.hunger) + '%';
  if(player.hunger <= 0 && player.alive){ player.alive=false; if(!deathHandled){ deathHandled=true; deathCameraX = player.x; deathCameraY = player.y; cameraFrozen = true; deathSequence(); playDeath(); } }

  for(const f of foods) f.wobble += 0.02 * dt/16;
  for(let i=bubbles.length-1;i>=0;i--){ const b=bubbles[i]; b.y -= b.vy * dt/1000; if(Math.hypot(b.x-player.x,b.y-player.y)>8000) bubbles.splice(i,1); }

  for(const e of enemies){
    if(e.isRemote){
      e.x += Math.cos(e.angle) * (e.speed*0.05) * dt/1000; e.y += Math.sin(e.angle) * (e.speed*0.05) * dt/1000; if(Math.random()<0.008) e.angle += (Math.random()-0.5)*1.2; continue;
    }
    e.hunger = (e.hunger||100) - dt/12000 * (e.size/24);
    let prey=null; let preyDist=1e9;
    let threat=null; let threatDist=1e9;
    const dToPlayer = Math.hypot(player.x-e.x,player.y-e.y);
    if(player.alive){ if(player.size <= e.size * 1.05 && dToPlayer < preyDist){ prey = {type:'player',ref:player,x:player.x,y:player.y,size:player.size}; preyDist = dToPlayer; } if(player.size > e.size * 1.05 && dToPlayer < threatDist){ threat = {type:'player',ref:player,x:player.x,y:player.y,size:player.size}; threatDist = dToPlayer; } }
    for(const other of enemies){ if(other===e) continue; const d = Math.hypot(other.x-e.x, other.y-e.y); if(other.size <= e.size * 1.05 && d < preyDist){ prey = {type:'enemy',ref:other,x:other.x,y:other.y,size:other.size}; preyDist = d; } if(other.size > e.size * 1.05 && d < threatDist){ threat = {type:'enemy',ref:other,x:other.x,y:other.y,size:other.size}; threatDist = d; } }
    if(threat && threatDist < 420){ e.state='flee'; const ang = Math.atan2(e.y - threat.y, e.x - threat.x); e.x += Math.cos(ang) * (e.speed*0.9) * dt/1000; e.y += Math.sin(ang) * (e.speed*0.9) * dt/1000; e.angle = ang;
    } else if(prey){ e.state='hunt'; const ang = Math.atan2(prey.y - e.y, prey.x - e.x); e.x += Math.cos(ang) * e.speed * dt/1000; e.y += Math.sin(ang) * e.speed * dt/1000; e.angle = ang; for(const ally of enemies){ if(ally!==e && Math.hypot(ally.x-e.x, ally.y-e.y) < 450 && (!ally.target || ally.target.size < prey.size)) ally.target = prey; }
    } else { e.state='wander'; e.x += Math.cos(e.angle) * (e.speed*0.18) * dt/1000; e.y += Math.sin(e.angle) * (e.speed*0.18) * dt/1000; if(Math.random()<0.01) e.angle += (Math.random()-0.5)*1.2; }
  }

  for(let i=foods.length-1;i>=0;i--){ const f=foods[i]; const d=Math.hypot(player.x-f.x,player.y-f.y); if(d < player.size + f.size*0.7){ foods.splice(i,1); player.size += f.size*0.08; player.score += 1; player.coins += 1; player.hunger = Math.min(100, player.hunger + 6); playEat(); } }
  for(let i=enemies.length-1;i>=0;i--){ const e=enemies[i]; const d=Math.hypot(player.x-e.x,player.y-e.y); if(d < player.size + e.size*0.6){ if(e.size > player.size * 1.05){ if(player.alive){ player.alive=false; if(!deathHandled){ deathHandled=true; deathCameraX = player.x; deathCameraY = player.y; cameraFrozen = true; deathSequence(); playDeath(); } } } else if(player.size > e.size * 1.05){ player.size += e.size*0.18; player.score += Math.round(e.size/6); player.coins += Math.round(e.size/8); enemies.splice(i,1); playEat(); } } }

  for(let i=enemies.length-1;i>=0;i--){ for(let j=enemies.length-1;j>=0;j--){ if(i===j) continue; const a=enemies[i], b=enemies[j]; const d=Math.hypot(a.x-b.x,a.y-b.y); if(d < a.size + b.size){ if(a.size > b.size * 1.05){ a.size += b.size*0.14; enemies.splice(j,1); if(j<i) i--; break; } } } }

  ensureLargerExists(nearbyCount, allowSpawnBots);
  trimEntities();
  ensureOfflineBotsVisible();

  const depthSigned = -Math.round(player.y);
  const sign = depthSigned >= 0 ? '+' : '-';
  if(ui.depthEl) ui.depthEl.textContent = `${sign}${Math.abs(depthSigned)} m`;
  const maxDepth = 3000; const pct = Math.min(1, Math.max(0, depthSigned) / maxDepth);
  if(ui.depthFill) ui.depthFill.style.height = `${Math.max(4, pct*100)}%`;

  if(ui.sizeEl) ui.sizeEl.textContent = player.size.toFixed(1);
  if(ui.scoreEl) ui.scoreEl.textContent = player.score;
  const highKey = 'aqua_highscore_' + (localStorage.getItem('playerName')||'Guest');
  let high = parseInt(localStorage.getItem(highKey) || '0',10);
  if(player.score > high){ high = player.score; localStorage.setItem(highKey, high); }
  if(ui.highEl) ui.highEl.textContent = high;
  if(ui.coinsEl) ui.coinsEl.textContent = player.coins;

  if(spectatingUid && (remotePlayers[spectatingUid] || onlinePlayers[spectatingUid])){
    const target = remotePlayers[spectatingUid] || onlinePlayers[spectatingUid];
    if(target) ui.coordsDisplay.textContent = `${Math.round(target.x||0)}, ${Math.round(target.y||0)} (sp:${target.name||spectatingUid})`;
  } else {
    ui.coordsDisplay.textContent = `${Math.round(player.x)}, ${Math.round(player.y)}`;
  }

  if(firebaseConnected && Math.random() < 0.06){
    uploadPlayerState();
  }
  if(Math.random() < 0.06) rebuildLeaderboards();
}

// ---------- rendering & background ----------
function updateCamera(dt){ const scale = Math.max(0.22, Math.min(1.3, (28)/(player.size+6))); camera.scale += (scale - camera.scale) * 0.08; const vw = window.innerWidth / camera.scale, vh = window.innerHeight / camera.scale; if(cameraFrozen){ camera.x = deathCameraX - vw/2; camera.y = deathCameraY - vh/2; } else if(spectatingUid && spectateModeEnabled){ const remote = remotePlayers[spectatingUid] || onlinePlayers[spectatingUid]; if(remote && typeof remote.x === 'number'){ camera.x += ((remote.x - vw/2) - camera.x) * 0.12; camera.y += ((remote.y - vh/2) - camera.y) * 0.12; return; } camera.x = player.x - vw/2; camera.y = player.y - vh/2; } else { camera.x = player.x - vw/2; camera.y = player.y - vh/2; } }
function clear(){ ctx.clearRect(0,0,canvas.width/ DPR, canvas.height/ DPR); }
function worldToScreen(wx,wy){ return { x: (wx - camera.x) * camera.scale, y: (wy - camera.y) * camera.scale }; }
function hexToRgb(hex){ hex = hex.replace('#',''); const num = parseInt(hex,16); return { r:(num>>16)&255, g:(num>>8)&255, b:num&255 }; }
function rgbToHex(r,g,b){ return '#'+((1<<24)+(Math.round(r)<<16)+(Math.round(g)<<8)+Math.round(b)).toString(16).slice(1); }
function mixColors(c1,c2,t){ const a=hexToRgb(c1); const b=hexToRgb(c2); const r=a.r + (b.r-a.r)*t; const g=a.g + (b.g-a.g)*t; const bl=a.b + (b.b-a.b)*t; return rgbToHex(r,g,bl); }
function displayColorForFish(f){ const base = f.color || '#ff9a66'; const yellow = '#fff59d'; const red = '#ff6b6b'; const ratio = (f.size - player.size) / Math.max(1, player.size); const t = Math.min(1, Math.abs(ratio) ); if(f === player) return base; if(f.size < player.size){ return mixColors(base, yellow, Math.min(1, t*1.1)); } else { return mixColors(base, red, Math.min(1, t*1.1)); } }
function drawFish(x,y,r,angle,opts={color:'#ff9a66',eye:'#0b1b2b'}, entityRef=null){ ctx.save(); const s = worldToScreen(x,y); ctx.translate(s.x, s.y); ctx.rotate(angle); const rr = r * camera.scale; ctx.beginPath(); ctx.ellipse(0,0,rr*1.25, rr, 0,0,Math.PI*2); const fillC = entityRef ? displayColorForFish(entityRef) : opts.color; ctx.fillStyle = fillC; ctx.fill(); ctx.beginPath(); ctx.moveTo(-rr*0.9,0); ctx.lineTo(-rr*1.7,-rr*0.7); ctx.lineTo(-rr*1.7,rr*0.7); ctx.closePath(); ctx.fillStyle = shade(fillC,-12); ctx.fill(); ctx.beginPath(); ctx.moveTo(rr*0.2,-rr*0.7); ctx.quadraticCurveTo(rr*0.6,-rr*1.4,rr*1.1,-rr*0.6); ctx.closePath(); ctx.fillStyle = shade(fillC,6); ctx.fill(); ctx.beginPath(); ctx.arc(rr*0.6,-rr*0.15, Math.max(2, rr*0.18),0,Math.PI*2); ctx.fillStyle = opts.eye; ctx.fill(); ctx.beginPath(); ctx.arc(rr*0.68,-rr*0.15, Math.max(1.2, rr*0.08),0,Math.PI*2); ctx.fillStyle = '#fff'; ctx.fill(); ctx.restore();
  const screen = worldToScreen(x,y);
  ctx.save(); ctx.font = `${Math.max(10,12*camera.scale)}px system-ui`; ctx.textAlign='center'; ctx.textBaseline='bottom'; ctx.lineWidth=3; if(entityRef === player){ if(player.speed < 8){ ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.fillStyle = '#ffffff'; ctx.strokeText(username, screen.x, screen.y - (rr*1.2)); ctx.fillText(username, screen.x, screen.y - (rr*1.2)); } } else if(entityRef && entityRef.name){ ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.fillStyle = '#fff'; ctx.strokeText(entityRef.name, screen.x, screen.y - (rr*1.2)); ctx.fillText(entityRef.name, screen.x, screen.y - (rr*1.2)); } ctx.restore(); }
function drawFood(f){ const t = performance.now()/600 + f.wobble; const wig = Math.sin(t)*2; drawFish(f.x, f.y + wig, f.size, Math.sin(t)*0.6 + Math.PI/6, {color:f.color, eye:'#222'}, f); }
function drawEnemy(e){ drawFish(e.x, e.y, e.size, e.angle, {color:e.color, eye:'#000'}, e); }
function drawBubble(b){ const s = worldToScreen(b.x,b.y); ctx.beginPath(); ctx.arc(s.x, s.y, b.r * camera.scale, 0, Math.PI*2); ctx.fillStyle = `rgba(255,255,255,${b.alpha})`; ctx.fill(); ctx.strokeStyle = `rgba(255,255,255,${Math.min(0.4,b.alpha)})`; ctx.stroke(); }
function shade(hex,percent){ const c = hex.replace('#',''); const num = parseInt(c,16); let r=(num>>16)+Math.round(255*percent/100); let g=((num>>8)&0x00FF)+Math.round(255*percent/100); let b=(num&0x0000FF)+Math.round(255*percent/100); r=Math.max(0,Math.min(255,r)); g=Math.max(0,Math.min(255,g)); b=Math.max(0,Math.min(255,b)); return '#'+((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1); }

function renderBackground(){ const w = canvas.width/DPR, h = canvas.height/DPR; const g = ctx.createLinearGradient(0,0,0,h); g.addColorStop(0,getComputedStyle(document.documentElement).getPropertyValue('--bg-top').trim()||'#7ee8fa'); g.addColorStop(1,getComputedStyle(document.documentElement).getPropertyValue('--bg-bottom').trim()||'#0b2f55'); ctx.fillStyle = g; ctx.fillRect(0,0,w,h); }

function render(){ clear(); renderBackground(); updateCamera(16);
  for(const f of foods) drawFood(f);
  for(const e of enemies) drawEnemy(e);
  for(const b of bubbles) drawBubble(b);
  drawFish(player.x, player.y, player.size, player.angle, {color:player.color, eye:player.eyeColor}, player);
}

// ---------- death animation & sequences ----------
function deathSequence(){ const startSize = player.size; const dur = 1200; const t0 = performance.now(); function anim(){ const t = performance.now() - t0; const p = Math.min(1, t/dur); player.size = startSize * (1 - p); clear(); render(); ctx.save(); ctx.globalAlpha = p*0.9; ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.fillRect(0,0,canvas.width/DPR,canvas.height/DPR); ctx.restore(); if(p<1) requestAnimationFrame(anim); else { const overlayE = document.getElementById('overlay'); if(overlayE) overlayE.classList.remove('hidden'); const hi = document.getElementById('homeInfo'); if(hi) hi.innerHTML = `<h3>You Died</h3><p>Score: ${player.score} — press Start to reset.</p>`; const shopPanel = document.getElementById('shopPanel'); if(shopPanel) shopPanel.classList.add('hidden'); } } requestAnimationFrame(anim); }

// ---------- main loop ----------
function mainLoop(now){ if(!running) return; const dt = Math.min(60, now - lastTime); update(dt); render(); lastTime = now; fpsTimer += dt; fpsCounter++; if(fpsTimer >= 500){ if(ui.fpsEl) ui.fpsEl.textContent = Math.round(fpsCounter / (fpsTimer/1000)); fpsTimer = 0; fpsCounter = 0; } requestAnimationFrame(mainLoop); }

// ---------- Room helpers ----------
function generateRoomCode(){ const chars='ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; let out=''; for(let i=0;i<6;i++) out += chars.charAt(Math.floor(Math.random()*chars.length)); return out; }

const generateRoomBtn = document.getElementById('generateRoomBtn'); if(generateRoomBtn) generateRoomBtn.addEventListener('click', ()=>{ const roomInput = document.getElementById('roomCodeInput'); if(roomInput) roomInput.value = generateRoomCode(); });

function createRoom(code, friendsOnly){
  if(!firebaseConnected || !firebaseDB || !firebaseUid){
    showToast('Connect to Firebase first to create a room.');
    return Promise.resolve(false);
  }
  const ref = firebaseDB.ref('/rooms/' + code);
  return ref.once('value').then(snap=>{
    if(snap.exists()){
      showToast('Room code already exists, generate another.');
      return false;
    }
    const center = { x: player.x, y: player.y };
    return ref.set({ owner: firebaseUid, created: Date.now(), friendsOnly: !!friendsOnly, center }).then(()=>{
      showToast('Room created: ' + code, 2200);
      currentRoom = { code, friendsOnly: !!friendsOnly, owner: firebaseUid, center };
      allowBots = !currentRoom.friendsOnly;
      uploadPlayerState();
      return true;
    }).catch(err=>{
      console.error('createRoom failed', err);
      showToast('Could not create room: ' + (err && err.message ? err.message : 'unknown'));
      return false;
    });
  }).catch(err=>{
    console.error('createRoom check failed', err);
    showToast('Could not check room: ' + (err && err.message ? err.message : 'unknown'));
    return false;
  });
}

function joinRoom(code){
  if(!firebaseConnected || !firebaseDB || !firebaseUid){
    showToast('Connect to Firebase first to join a room.');
    return Promise.resolve(false);
  }
  const ref = firebaseDB.ref('/rooms/' + code);
  return ref.once('value').then(snap=>{
    if(!snap.exists()){
      showToast('Room not found: ' + code, 2200);
      return false;
    }
    const obj = snap.val();
    currentRoom = { code, friendsOnly: !!obj.friendsOnly, owner: obj.owner||null, center: obj.center || null };
    allowBots = !currentRoom.friendsOnly;
    if(currentRoom.center && typeof currentRoom.center.x === 'number'){
      player.x = currentRoom.center.x + (Math.random()-0.5)*180;
      player.y = currentRoom.center.y + (Math.random()-0.5)*180;
    } else {
      setRandomSpawn();
    }
    uploadPlayerState();
    showToast('Joined room: ' + code, 1800);
    return true;
  }).catch(err=>{
    console.error('joinRoom failed', err);
    showToast('Could not join room: ' + (err && err.message ? err.message : 'unknown'));
    return false;
  });
}

const createRoomBtn = document.getElementById('createRoomBtn'); if(createRoomBtn) createRoomBtn.addEventListener('click', ()=>{
  const code = (document.getElementById('roomCodeInput').value||'').trim().toUpperCase();
  if(!code || code.length < 3){ showToast('Enter a room code (3-6 chars) or generate one.'); return; }
  const friendsOnly = !!document.getElementById('friendsOnlyCheckbox').checked;
  ensureFirebaseConnected().then(ok=>{
    if(ok) createRoom(code, friendsOnly).then(ok2=>{ if(ok2) { const overlayE = document.getElementById('overlay'); if(overlayE) overlayE.classList.add('hidden'); setRunning(true); } });
  });
});
const joinRoomBtn = document.getElementById('joinRoomBtn'); if(joinRoomBtn) joinRoomBtn.addEventListener('click', ()=>{
  const code = (document.getElementById('roomCodeInput').value||'').trim().toUpperCase();
  if(!code){ showToast('Enter a room code to join.'); return; }
  ensureFirebaseConnected().then(ok=>{
    if(ok) joinRoom(code).then(ok2=>{ if(ok2){ const overlayE = document.getElementById('overlay'); if(overlayE) overlayE.classList.add('hidden'); setRunning(true); } });
  });
});

// ---------- UI actions & spawn/reset (start buttons) ----------
const startOfflineBtn = document.getElementById('startOfflineBtn'); if(startOfflineBtn) startOfflineBtn.addEventListener('click', ()=>{ startGame(false); });
const startOnlineBtn = document.getElementById('startOnlineBtn'); if(startOnlineBtn) startOnlineBtn.addEventListener('click', ()=>{ startGame(true); });
const fbSetupBtn = document.getElementById('fbSetupBtn'); if(fbSetupBtn) fbSetupBtn.addEventListener('click', ()=>{ ensureFirebaseConnected().then(ok=>{ if(ok) showToast('Firebase connected'); else showToast('Failed to connect to Firebase'); }); });
const infoBtn = document.getElementById('infoBtn'); if(infoBtn) infoBtn.addEventListener('click', ()=>{ const hi = document.getElementById('homeInfo'); if(hi) hi.classList.remove('hidden'); const shopPanel = document.getElementById('shopPanel'); if(shopPanel) shopPanel.classList.add('hidden'); const lbPanel = document.getElementById('leaderboardPanel'); if(lbPanel) lbPanel.classList.add('hidden'); });
const shopBtn = document.getElementById('shopBtn'); if(shopBtn) shopBtn.addEventListener('click', ()=>{ const hi = document.getElementById('homeInfo'); if(hi) hi.classList.add('hidden'); const shopPanel = document.getElementById('shopPanel'); if(shopPanel) shopPanel.classList.remove('hidden'); renderShop(document.getElementById('shopSearch')?document.getElementById('shopSearch').value:'', document.getElementById('shopSort')?document.getElementById('shopSort').value:'price-asc'); });
const leaderboardBtn = document.getElementById('leaderboardBtn'); if(leaderboardBtn) leaderboardBtn.addEventListener('click', ()=>{ const hi = document.getElementById('homeInfo'); if(hi) hi.classList.add('hidden'); const lbPanel = document.getElementById('leaderboardPanel'); if(lbPanel) lbPanel.classList.remove('hidden'); renderFullLeaderFullHistoric(); });

// spectate toggle button toggles spectate-mode UI (doesn't pick a player)
const spectateToggleBtn = document.getElementById('spectateToggleBtn'); if(spectateToggleBtn) spectateToggleBtn.addEventListener('click', ()=>{
  spectateModeEnabled = !spectateModeEnabled;
  if(spectateToggleBtn) spectateToggleBtn.textContent = spectateModeEnabled ? 'Spectate: ON' : 'Spectate Mode';
  if(!spectateModeEnabled){ spectatingUid = null; showToast('Spectate mode disabled'); }
});

// helper to begin spectating a specific uid
function spectatePlayer(uid){
  if(!firebaseConnected){ showToast('Connect to Firebase to spectate'); return; }
  if(uid === firebaseUid){ showToast('Cannot spectate yourself'); return; }
  const target = onlinePlayers[uid];
  if(!target){ showToast('Player not available to spectate'); return; }
  if(!isSameRoomForClient(target)){ showToast('Player is not in your room / public area'); return; }
  spectatingUid = uid;
  spectateModeEnabled = true;
  if(spectateToggleBtn) spectateToggleBtn.textContent = 'Spectate: ON';
  showToast('Now spectating ' + (target.username || uid), 2200);
}

// play start helper
function startGame(online){
  const homeControl = document.getElementById('homeControlMode'); if(homeControl) controlMode = homeControl.value; const controlModeEl = document.getElementById('controlMode'); if(controlModeEl) controlModeEl.value = controlMode; const mobileEl = document.getElementById('mobileStyle'); if(mobileEl) mobileStyle = mobileEl.value; localStorage.setItem('controlMode', controlMode); localStorage.setItem('mobileStyle', mobileStyle); updateControlUI();
  const saved = localStorage.getItem('playerName') || 'Guest'; if(!saved || saved==='Guest'){ showToast('Please set a username before starting.',2200); return; }
  const overlayE = document.getElementById('overlay'); if(overlayE) overlayE.classList.add('hidden');
  foods=[]; enemies=[]; bubbles=[]; currents=[]; setRandomSpawn(); player.size=8 + Math.random()*8; player.hunger=100; player.score=0; player.coins=0; player.alive=true; deathHandled=false; pausedByContext=false; cameraFrozen=false; deathCameraX=0; deathCameraY=0; camera.scale = 1; camera.x = player.x - (window.innerWidth/(2*camera.scale)); camera.y = player.y - (window.innerHeight/(2*camera.scale)); pointerX=null; pointerY=null; keys={};
  for(let i=0;i<120;i++) spawnFoodAround(player.x, player.y); for(let i=0;i<14;i++) spawnEnemyRelative(player.x, player.y); for(let i=0;i<100;i++) spawnBubbleAround(player.x, player.y); ensureAudioStarted(); setRunning(true);
  if(online){ ensureFirebaseConnected().then(ok=>{ if(ok){ showToast('Online mode: connected to Firebase',1600); uploadPlayerState(); } else { showToast('Could not connect to Firebase — starting offline',2600); } }); } else { rebuildLeaderboards(); }
}

const btnLeave = document.getElementById('btnLeave'); if(btnLeave) btnLeave.addEventListener('click', ()=>{ currentRoom = { code: null, friendsOnly:false, owner:null, center:null }; allowBots = true; if(firebaseConnected && firebaseDB && firebaseUid){ try{ firebaseDB.ref('/players/' + firebaseUid + '/room').set(null); }catch(e){} } setRunning(false); const overlayE = document.getElementById('overlay'); if(overlayE) overlayE.classList.remove('hidden'); });

const btnPause = document.getElementById('btnPause'); if(btnPause) btnPause.addEventListener('click', ()=>{ if(firebaseConnected && currentRoom.code){ showToast('Pausing disabled in online rooms. Use Exit to leave.'); return; } setRunning(!running); });

// start paused on home
document.getElementById('overlay').classList.remove('hidden'); setRunning(false);

// ensure shop inputs exist handlers
(function initShopInputs(){ const search = document.getElementById('shopSearch'); const sort = document.getElementById('shopSort'); if(search) search.addEventListener('input', e=>renderShop(e.target.value, sort?sort.value:'price-asc')); if(sort) sort.addEventListener('change', e=>renderShop(search?search.value:'', e.target.value)); })();

// restore saved username display
const savedName = localStorage.getItem('playerName'); if(savedName && ui.usernameDisplay){ ui.usernameDisplay.textContent = savedName; if(usernameInput) usernameInput.value = savedName; }

// hide mobile option on non-touch by default (unless testing allowed)
updateMobileOptionVisibility();

// simple self-tests (run manually in console with window.runTests())
window.runTests = function(){
  try { console.assert(typeof setRunning === 'function', 'setRunning should exist');
        console.assert(document.getElementById('btnPause'), 'Pause button exists');
        console.log('Self-tests passed.'); }
  catch(e){ console.error('Self-tests failed', e); }
};

// expose debug
window.__game = {player, foods, enemies, bubbles, onlinePlayers, remotePlayers, currentRoom};

// initial mini leaderboard render
rebuildLeaderboards();
</script>
</body>
</html>
