<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Idle Shop Keeper ‚Äî Authoritative Multiplayer</title>
<style>
/* UI styles (kept compact) */
body{box-sizing:border-box;margin:0;padding:20px;font-family:Segoe UI,Helvetica,Arial;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);min-height:100vh;color:#222}
.game-container{max-width:1200px;margin:0 auto;background:#fff;border-radius:16px;padding:22px;box-shadow:0 18px 36px rgba(0,0,0,.12)}
.header{display:flex;align-items:center;justify-content:space-between;gap:12px}
.header h1{margin:0;font-size:1.6rem}
.small{font-size:.85rem;color:#555}
.player-code{font-size:.9rem;color:#2d3748;background:#f7fafc;padding:6px 8px;border-radius:8px;border:1px solid #e2e8f0;display:inline-block;margin-left:8px}
.copy-btn{margin-left:8px;padding:6px 8px;border-radius:8px;border:none;cursor:pointer;background:#4299e1;color:white}
.menu{margin-top:14px}
.menu-grid{display:grid;grid-template-columns:1fr 320px;gap:18px}
.card{background:#fbfcff;border:1px solid #e6eefb;padding:12px;border-radius:10px}
.menu-btn{display:flex;gap:12px;align-items:center;padding:12px;border-radius:10px;border:2px solid #e2e8f0;background:white;cursor:pointer}
.players-panel{max-height:260px;overflow:auto;margin-top:8px}
.player-row{display:flex;justify-content:space-between;align-items:center;padding:8px;border-bottom:1px dashed #e2e8f0}
.status-dot{width:10px;height:10px;border-radius:50%;display:inline-block;margin-right:8px}
.status-online{background:#38a169}.status-off{background:#cbd5e0}
.rooms-list{max-height:260px;overflow:auto;margin-top:8px}
.room-row{display:flex;justify-content:space-between;align-items:center;padding:8px;border-bottom:1px dashed #e2e8f0}
.room-host{font-weight:600}
.btn{padding:8px 10px;border-radius:8px;border:none;cursor:pointer}
.btn.primary{background:#4299e1;color:#fff}
.btn.ghost{background:#e6eefb;color:#2d3748}
.toast{position:fixed;right:18px;bottom:18px;background:#2d3748;color:#fff;padding:8px 12px;border-radius:8px;opacity:.98;z-index:9999}
.modal-backdrop{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.45);z-index:6000}
.modal{background:#fff;padding:14px;border-radius:10px;width:380px;max-width:94%}
.ping-box{display:flex;gap:8px;align-items:center}
.signal-bars{display:flex;gap:2px;align-items:end;height:14px}
.signal-bar{width:6px;background:#cbd5e0;border-radius:2px}
.signal-bar.active{background:#38a169}
@media(max-width:900px){ .menu-grid{grid-template-columns:1fr} }
</style>
</head>
<body>
<div class="game-container">
  <div class="header">
    <div>
      <h1>üè™ Idle Shop Keeper</h1>
      <div class="small">Build your retail empire ‚Äî with multiplayer</div>
    </div>
    <div style="text-align:right">
      <div class="small">Player code: <span id="playerCode" class="player-code">‚Äî</span></div>
      <div style="margin-top:8px" class="ping-box">
        <div id="pingDisplay" class="small">Ping: ‚Äî ms</div>
        <div class="signal-bars" id="signalBars" aria-hidden="true">
          <div class="signal-bar" id="bar1"></div>
          <div class="signal-bar" id="bar2"></div>
          <div class="signal-bar" id="bar3"></div>
          <div class="signal-bar" id="bar4"></div>
          <div class="signal-bar" id="bar5"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="menu" style="margin-top:16px">
    <div class="menu-grid">
      <!-- Left: main actions -->
      <div>
        <div class="card" style="margin-bottom:12px">
          <div style="display:flex;gap:8px;align-items:center;justify-content:space-between">
            <div>
              <button class="menu-btn" id="btnSingle"><div style="font-size:22px">üéÆ</div><div style="margin-left:8px"><strong>Single Player</strong><div class="small">Play solo</div></div></button>
            </div>
            <div>
              <button id="btnExportConfig" class="btn ghost">Use custom Firebase</button>
            </div>
          </div>
        </div>

        <div class="card">
          <h3 style="margin:0 0 8px 0">Multiplayer</h3>
          <div style="display:flex;gap:8px;margin-bottom:8px">
            <button id="btnLAN" class="btn primary">Create LAN Room</button>
            <button id="btnGlobal" class="btn ghost">Create/Join Room</button>
            <button id="btnRandom" class="btn ghost">Random</button>
          </div>

          <div style="margin-top:6px">
            <div class="small">Available players:</div>
            <div id="playersPanel" class="players-panel"><div class="small" style="color:#666;text-align:center">Loading...</div></div>
          </div>

          <div style="margin-top:12px">
            <div class="small">Active rooms:</div>
            <div id="roomsList" class="rooms-list"><div class="small" style="color:#666;text-align:center">Loading rooms...</div></div>
          </div>
        </div>

      </div>

      <!-- Right: info card -->
      <div>
        <div class="card">
          <h4 style="margin:0 0 8px 0">Saves & Tools</h4>
          <div style="display:flex;flex-direction:column;gap:8px">
            <button id="saveBtn" class="btn primary">Save (local + server)</button>
            <button id="savesBtn" class="btn ghost">Open Saves</button>
            <button id="exportBtn" class="btn ghost">Export</button>
            <button id="importBtn" class="btn ghost">Import</button>
          </div>

          <div style="margin-top:12px">
            <label class="small">Auto-clean rooms (host only)</label>
            <div style="display:flex;gap:8px;margin-top:8px">
              <button id="toggleAutoCleaner" class="btn ghost" title="Hidden for non-hosts">Auto-clean: OFF</button>
            </div>
            <div class="small" style="color:#666;margin-top:8px">Only the host (room creator) sees the Auto-clean control. Non-hosts cannot remove rooms.</div>
          </div>

          <div style="margin-top:10px" class="small">Favicon may 404 ‚Äî that's harmless; put a /favicon.ico if you want one.</div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- modal root + file input -->
<div id="modalRoot" style="position:fixed;inset:0;pointer-events:none;z-index:8000"></div>
<input id="importFile" type="file" accept=".json" style="display:none" />

<!-- script (module) -->
<script type="module">
/*
 Authoritative multiplayer using Firebase Realtime Database as coordinator:
 - Rooms structure:
   rooms/{roomId}:
     host: p-xxxx
     createdAt: timestamp
     expiresAt: timestamp
     state: { authoritative game state object }
     actions: { pushId: { from: playerId, type: 'buy'|'serve'|'custom', payload: {...}, ts } }
     participants: { playerId: { lastSeen } }
 - Host becomes authoritative processor: listens for actions and applies to rooms/{roomId}/state and clears actions.
 - Clients push actions and listen to rooms/{roomId}/state updates.
 - onDisconnect used to remove presence and remove host's room.
 - TTL sweeper runs client-side periodically; only host or clients with autoClean enabled remove expired rooms.
 - Ping & signal: when a data channel with a peer exists, ping round-trip is measured via datachannel 'ping'/'pong' messages; signal bars computed from ping.
 - IMPORTANT: Firebase DB rules must allow authenticated writes to /players and /rooms. Enable Anonymous Auth and set RTDB rules accordingly.
*/

import { initializeApp } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-app.js";
import { getDatabase, ref, set, push, onValue, onChildAdded, child, get, remove, update, onDisconnect, query, orderByChild } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-database.js";
import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-auth.js";

/* ---------------- CONFIG - default (replace via "Use custom Firebase") --------------- */
let firebaseConfig = {
  apiKey: "AIzaSyBn4khIpi57YvqQX2urCup2mCvpVUZ0j8k",
  authDomain: "idle-shop-keeper.firebaseapp.com",
  databaseURL: "https://idle-shop-keeper-default-rtdb.firebaseio.com",
  projectId: "idle-shop-keeper",
  storageBucket: "idle-shop-keeper.firebasestorage.app",
  messagingSenderId: "117380146729",
  appId: "1:117380146729:web:8180d507d5a2aae45e5e38",
  measurementId: "G-VS2Z5T0Y9Y"
};

/* ----------------- Initialize Firebase app & services ----------------- */
let app, db, auth;
function initFirebase(cfg) {
  try {
    app = initializeApp(cfg);
    db = getDatabase(app);
    auth = getAuth(app);
  } catch (e) {
    console.error('Firebase init failed', e);
    toast('Firebase init error ‚Äî check console');
  }
}
initFirebase(firebaseConfig);

/* ----------------- small UI helpers ----------------- */
const modalRoot = document.getElementById('modalRoot');
function showModal(html, opts={}) {
  const backdrop = document.createElement('div'); backdrop.className = 'modal-backdrop'; backdrop.style.pointerEvents='auto';
  const box = document.createElement('div'); box.className = 'modal'; box.innerHTML = html;
  backdrop.appendChild(box); modalRoot.appendChild(backdrop);
  function close(){ try{ backdrop.remove(); }catch(e){} if(opts.onClose) opts.onClose(); }
  box.querySelectorAll('[data-close]').forEach(el=>el.addEventListener('click', close));
  return { box, close };
}
function toast(msg, t=3000){
  const el = document.createElement('div'); el.className='toast'; el.textContent=msg; document.body.appendChild(el);
  setTimeout(()=> el.style.opacity='0', t-350); setTimeout(()=> el.remove(), t);
}

/* ----------------- game state (authoritative model kept compact for demo) ----------------- */
let gameState = {
  money: 100, customersServed: 0, shopLevel:1,
  inventory: {}, upgrades: {}, customers: [], workers: {}
};
const LOCAL_META_KEY = 'idle_shop_meta_v1';
let myPlayerId = null;
let myAnonUid = null;
let autoCleanerEnabled = false;

/* ----------------- helpers ----------------- */
function generateLocalId(){ return (crypto && crypto.randomUUID) ? 'p-'+crypto.randomUUID() : 'p-'+Math.random().toString(36).slice(2,9); }

/* ----------------- UI refs ----------------- */
const playerCodeEl = document.getElementById('playerCode');
const playersPanel = document.getElementById('playersPanel');
const roomsListEl = document.getElementById('roomsList');
const toggleAutoCleanerBtn = document.getElementById('toggleAutoCleaner');
const pingDisplay = document.getElementById('pingDisplay');
const barEls = [1,2,3,4,5].map(i=>document.getElementById('bar'+i));

/* ----------------- Firebase auth (anonymous) ----------------- */
signInAnonymously(getAuth(app)).catch(err=>{
  console.warn('anon sign-in failed', err);
  toast('Anonymous sign-in failed ‚Äî check Firebase config and DB rules');
});

onAuthStateChanged(getAuth(app), (user) => {
  if(user){
    myAnonUid = user.uid;
    // load local meta
    const saved = JSON.parse(localStorage.getItem(LOCAL_META_KEY) || '{}');
    if(saved && saved.playerId) myPlayerId = saved.playerId;
    else myPlayerId = 'p-' + user.uid;
    // persist meta
    localStorage.setItem(LOCAL_META_KEY, JSON.stringify({ playerId: myPlayerId }));
    playerCodeEl.textContent = myPlayerId;
    // now safe to write presence/meta
    ensurePlayerNode();
    attachRealtimeListeners();
    updateUI();
  } else {
    // not signed in yet
  }
});

/* Wait for auth before writing anything to DB ‚Äî this avoids permission_denied issues */
async function ensurePlayerNode(){
  if(!db || !myPlayerId) return;
  const metaRef = ref(db, `players/${myPlayerId}/meta`);
  const presenceRef = ref(db, `players/${myPlayerId}/presence`);
  try{
    await set(metaRef, { createdAt: Date.now(), playerId: myPlayerId });
    await set(presenceRef, { lastSeen: Date.now(), playerId: myPlayerId });
    try{ await onDisconnect(presenceRef).remove(); }catch(e){/* optional */ }
  } catch(e){
    console.warn('ensurePlayerNode failed', e);
    toast('Permission denied writing player node ‚Äî check DB rules or ensure anonymous auth is enabled.');
  }
}

/* ----------------- listen for players & rooms ----------------- */
function attachRealtimeListeners(){
  if(!db) return;
  // players list
  onValue(ref(db, 'players'), snap=>{
    const all = snap.val() || {};
    renderPlayers(all);
  });
  // rooms list (ordered by createdAt)
  const q = query(ref(db, 'rooms'));
  onValue(q, snap=>{
    const rooms = snap.val() || {};
    renderRoomsList(rooms);
  });
}

/* Render players */
function renderPlayers(all){
  playersPanel.innerHTML = '';
  const keys = Object.keys(all).sort();
  if(keys.length === 0){ playersPanel.innerHTML = '<div class="small" style="color:#666">No players</div>'; return; }
  keys.forEach(pid=>{
    const node = all[pid];
    if(!node) return;
    const pres = node.presence || {};
    const last = pres.lastSeen || 0; const online = (Date.now() - last) < 90_000;
    const div = document.createElement('div'); div.className='player-row';
    div.innerHTML = `<div><span class="status-dot ${online?'status-online':'status-off'}"></span><div style="display:inline-block;margin-left:8px"><strong>${pid}</strong><div class="small" style="color:#666">${online?'Online':'Offline'}</div></div></div>`;
    const btns = document.createElement('div');
    const invite = document.createElement('button'); invite.className='btn primary'; invite.textContent='Invite';
    invite.onclick = ()=> invitePlayer(pid);
    const join = document.createElement('button'); join.className='btn ghost'; join.textContent='Join Room';
    join.onclick = ()=> tryJoinPlayerRoom(pid);
    btns.appendChild(invite); btns.appendChild(join);
    div.appendChild(btns);
    playersPanel.appendChild(div);
  });
}

/* Render rooms list stacked */
function renderRoomsList(rooms){
  roomsListEl.innerHTML = '';
  const keys = Object.keys(rooms || {});
  if(keys.length === 0){ roomsListEl.innerHTML = '<div class="small" style="color:#666">No rooms</div>'; return; }
  // sort by createdAt desc
  keys.sort((a,b)=> (rooms[b].createdAt||0) - (rooms[a].createdAt||0));
  keys.forEach(rid=>{
    const r = rooms[rid];
    if(!r) return;
    const host = r.host || '‚Äî';
    const expires = r.expiresAt || 0;
    const expired = Date.now() > expires;
    const row = document.createElement('div'); row.className='room-row';
    row.innerHTML = `<div><div class="room-host">${rid}</div><div class="small" style="color:#666">host: ${host} ¬∑ ${new Date(r.createdAt||0).toLocaleString()} ${expired? '¬∑ (expired)' : ''}</div></div>`;
    const controls = document.createElement('div');
    const view = document.createElement('button'); view.className='btn ghost'; view.textContent='View';
    view.onclick = ()=> openRoomModal(rid, r);
    controls.appendChild(view);
    if(r.host === myPlayerId){
      const openBtn = document.createElement('button'); openBtn.className='btn primary'; openBtn.textContent='Open (host)';
      openBtn.onclick = ()=> openRoomAsHost(rid, r);
      controls.appendChild(openBtn);
    } else {
      const joinBtn = document.createElement('button'); joinBtn.className='btn primary'; joinBtn.textContent='Join';
      joinBtn.onclick = ()=> joinRoomById(rid);
      controls.appendChild(joinBtn);
    }
    row.appendChild(controls);
    roomsListEl.appendChild(row);
  });
}

/* ----------------- invite / create / join helpers ----------------- */
async function invitePlayer(pid){
  if(!db) return;
  const rid = Math.random().toString(36).slice(2,9);
  try{
    // create room with authoritative empty state
    await set(ref(db, `rooms/${rid}`), { host: myPlayerId, createdAt: Date.now(), expiresAt: Date.now() + 1000*60*60, state: gameState, participants: { [myPlayerId]: { lastSeen: Date.now() } } });
    // write invite under target player's node
    await set(ref(db, `players/${pid}/invites/${rid}`), { from: myPlayerId, room: rid, ts: Date.now() });
    toast('Invite sent: ' + pid);
    // host room locally
    laterHostRoom(rid);
  } catch(e){ console.warn(e); toast('Invite failed (check permissions/rules)'); }
}

async function createRoomAndHost(){
  if(!db) return;
  const rid = Math.random().toString(36).slice(2,9);
  try{
    await set(ref(db, `rooms/${rid}`), { host: myPlayerId, createdAt: Date.now(), expiresAt: Date.now() + 1000*60*60, state: gameState, participants: { [myPlayerId]: { lastSeen: Date.now() } } });
    toast('Room created: ' + rid);
    laterHostRoom(rid);
  } catch(e){ console.warn(e); toast('Create room failed'); }
}

/* When hosting, we need the host to process incoming actions */
async function laterHostRoom(rid){
  // small delay so UI updates reflect new room
  setTimeout(()=> hostRoom(rid), 250);
}

/* Join room by ID (client) */
async function joinRoomById(rid){
  if(!db) return;
  // add participant
  try {
    await set(ref(db, `rooms/${rid}/participants/${myPlayerId}`), { lastSeen: Date.now(), joinedAt: Date.now() });
  } catch(e){ console.warn('join participant set failed', e); toast('Join failed (check permissions)'); return; }
  // open local client room UI
  openRoomAsClient(rid);
}

/* Try to find a room hosted by given player and join it */
async function tryJoinPlayerRoom(pid){
  try {
    const snap = await get(ref(db, 'rooms'));
    if(!snap.exists()){ toast('No active rooms'); return; }
    const rooms = snap.val();
    for(const rid in rooms){
      if(rooms[rid].host === pid){ await joinRoomById(rid); return; }
    }
    toast('No room found for that player');
  } catch(e){ console.warn(e); toast('Query failed'); }
}

/* ----------------- Authoritative host logic ----------------- */

/*
 Host responsibilities:
 - Listen to rooms/{rid}/actions (onChildAdded)
 - For each action: validate, apply to rooms/{rid}/state (authoritative), then remove that action entry
 - When host disconnects, onDisconnect should remove the room node (we attempt to set this when hosting)
 - Hosts MAY run autoCleaner to remove expired rooms
*/
const hosting = {}; // map roomId -> listener cleanup

async function hostRoom(rid){
  if(!db) return;
  const actionsRef = ref(db, `rooms/${rid}/actions`);
  const stateRef = ref(db, `rooms/${rid}/state`);
  // attach listener for new actions
  const unsub = onChildAdded(actionsRef, async (snap) => {
    const action = snap.val();
    const key = snap.key;
    if(!action) return;
    // apply simple validation: require from and type
    if(!action.from || !action.type) {
      // invalid action: remove
      await remove(child(actionsRef, key)).catch(()=>{});
      return;
    }
    // Ensure this host is still the current host in DB
    const metaSnap = await get(ref(db, `rooms/${rid}/host`));
    const hostId = (metaSnap && metaSnap.exists()) ? metaSnap.val() : null;
    // if host in DB changed, stop processing
    const roomSnap = await get(ref(db, `rooms/${rid}`));
    const roomObj = roomSnap.val() || {};
    if(roomObj.host !== myPlayerId) {
      // not host anymore; stop listener
      toast('No longer host, stopping authoritative processing for room ' + rid);
      try { hosting[rid]?.off(); } catch(e){}
      return;
    }
    // load current authoritative state
    const stSnap = await get(stateRef);
    let currentState = stSnap.exists() ? stSnap.val() : (roomObj.state || {});
    if(!currentState) currentState = {};
    // we apply simple action types: buy / serve / custom
    try {
      if(action.type === 'buy') {
        const keyItem = action.payload?.itemKey;
        if(!keyItem) { /* ignore */ }
        else {
          currentState.inventory = currentState.inventory || {};
          currentState.inventory[keyItem] = (currentState.inventory[keyItem]||0) + 1;
          // deduct money? for authoritative demo we accept it
        }
      } else if(action.type === 'serve') {
        const want = action.payload?.itemKey;
        if(want && (currentState.inventory?.[want]||0) > 0) {
          currentState.inventory[want] = currentState.inventory[want] - 1;
          currentState.customersServed = (currentState.customersServed||0) + 1;
        }
      } else if(action.type === 'custom') {
        // host-authorized custom patch: merge payload
        currentState = Object.assign({}, currentState, action.payload || {});
      }
      // write back authoritative state
      await set(stateRef, currentState).catch(()=>{});
    } catch(e) {
      console.warn('action apply failed', e);
    } finally {
      // remove processed action
      await remove(child(actionsRef, key)).catch(()=>{});
    }
  });

  // store cleanup handle so we can stop listening later
  hosting[rid] = { off: () => { try { snapOff(actionsRef); } catch(e){} } };

  // ensure onDisconnect: if host leaves, remove the room (so clients don't get orphaned)
  try {
    const roomRef = ref(db, `rooms/${rid}`);
    await onDisconnect(roomRef).remove();
  } catch(e){ /* best-effort */ }

  toast('Hosting authoritative room: ' + rid);
}

/* helper wrapper for safe removal (not part of firebase SDK) */
function snapOff(refObj){
  try { onChildAdded(refObj, ()=>{}).off; } catch(e){}
}

/* ----------------- client-side: send actions to room ----------------- */
async function clientSendAction(rid, type, payload){
  if(!db) return;
  const actionsRef = ref(db, `rooms/${rid}/actions`);
  try {
    await push(actionsRef, { from: myPlayerId, type, payload: payload||{}, ts: Date.now() });
  } catch(e) { console.warn('sendAction failed', e); toast('Action send failed'); }
}

/* ----------------- room UI: host & client views ----------------- */
function openRoomModal(rid, roomObj){
  const html = `<h3>Room ${rid}</h3><div style="margin-top:8px"><div class="small">Host: ${roomObj.host}</div><div class="small">Created: ${new Date(roomObj.createdAt||0).toLocaleString()}</div></div><div style="text-align:right;margin-top:12px"><button class="btn ghost" data-close>Close</button></div>`;
  showModal(html);
}

function openRoomAsHost(rid, roomObj){
  // open host control modal
  const html = `<h3>Hosting: ${rid}</h3>
    <div style="margin-top:8px"><div class="small">Host: ${roomObj.host}</div><div class="small">Created: ${new Date(roomObj.createdAt||0).toLocaleString()}</div></div>
    <div style="margin-top:12px"><button id="hostCloseRoom" class="btn ghost">Close Room (delete)</button><button id="hostToggleCleaner" class="btn primary" style="margin-left:8px">${autoCleanerEnabled?'Stop cleaner':'Start cleaner'}</button></div>
    <div style="text-align:right;margin-top:10px"><button class="btn ghost" data-close>Done</button></div>`;
  const m = showModal(html);
  m.box.querySelector('#hostCloseRoom').addEventListener('click', async ()=>{
    try{ await remove(ref(db, `rooms/${rid}`)); toast('Room removed'); m.close(); } catch(e){ toast('Remove failed'); }
  });
  m.box.querySelector('#hostToggleCleaner').addEventListener('click', ()=>{
    autoCleanerEnabled = !autoCleanerEnabled;
    m.box.querySelector('#hostToggleCleaner').textContent = autoCleanerEnabled ? 'Stop cleaner' : 'Start cleaner';
    updateAutoCleanerUI();
  });
  // ensure host listener running
  hostRoom(rid);
}

/* open as client (listening to authoritative state) */
function openRoomAsClient(rid){
  const html = `<h3>Joined: ${rid}</h3><div style="margin-top:8px" id="roomStateArea"><div class="small" style="color:#666">Loading state...</div></div>
    <div style="margin-top:10px"><div style="display:flex;gap:8px"><button id="actBuy" class="btn primary">Buy (demo)</button><button id="actServe" class="btn ghost">Serve (demo)</button></div></div>
    <div style="text-align:right;margin-top:10px"><button class="btn ghost" data-close>Close</button></div>`;
  const m = showModal(html);
  const stateArea = m.box.querySelector('#roomStateArea');
  // listen to authoritative state updates
  const stateRef = ref(db, `rooms/${rid}/state`);
  const unsub = onValue(stateRef, snap=>{
    const val = snap.val();
    stateArea.innerHTML = `<div class="small" style="white-space:pre-wrap">${JSON.stringify(val, null, 2)}</div>`;
  });
  // actions
  m.box.querySelector('#actBuy').addEventListener('click', ()=> clientSendAction(rid, 'buy', { itemKey: 'apple' }));
  m.box.querySelector('#actServe').addEventListener('click', ()=> clientSendAction(rid, 'serve', { itemKey: 'apple' }));
  m.close = () => { try{ unsub(); }catch(e){}; m.box.parentElement.remove(); };
}

/* ----------------- joinHost helpers ----------------- */
async function joinRoomByIdAndOpen(rid){
  await joinRoomById(rid);
  openRoomAsClient(rid);
}

/* ----------------- room cleanup sweeper (TTL) ----------------- */
async function sweepExpiredRooms(){
  if(!db) return;
  try {
    const snap = await get(ref(db, 'rooms'));
    if(!snap.exists()) return;
    const rooms = snap.val();
    const now = Date.now();
    for(const rid in rooms){
      const r = rooms[rid];
      if(!r) continue;
      if((r.expiresAt || 0) < now){
        // only hosts or clients with autoCleanerEnabled remove
        if(r.host === myPlayerId || autoCleanerEnabled){
          try { await remove(ref(db, `rooms/${rid}`)); console.log('sweeper removed', rid); } catch(e){}
        }
      }
    }
  } catch(e){ console.warn('sweep failed', e); }
}

/* run sweeper every minute */
setInterval(()=> { sweepExpiredRooms(); }, 60_000);

/* update Auto-cleaner UI (hidden for non-hosts) */
function updateAutoCleanerUI(){
  toggleAutoCleanerBtn.textContent = 'Auto-clean: ' + (autoCleanerEnabled ? 'ON' : 'OFF');
  // hide toggle if not host of any room
  // We check rooms list to see if we host any active room
  get(ref(db, 'rooms')).then(snap=>{
    const rooms = snap.val() || {};
    const hostingAny = Object.values(rooms).some(r => r.host === myPlayerId);
    toggleAutoCleanerBtn.style.display = hostingAny ? 'inline-block' : 'none';
  }).catch(()=> toggleAutoCleanerBtn.style.display = 'none');
}

/* ----------------- ping & signal bar (via DataChannel when connected) ----------------- */
let dataChannel = null;
let pc = null;
let pingLast = null;

function createPC(){
  pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
  pc.ondatachannel = e => {
    dataChannel = e.channel;
    wireDataChannel();
  };
  pc.oniceconnectionstatechange = ()=> {
    if(pc && (pc.iceConnectionState === 'disconnected' || pc.iceConnectionState === 'failed')) {
      pingDisplay.textContent = 'Ping: ‚Äî ms';
      setSignalBars(null);
    }
  };
  return pc;
}
function wireDataChannel(){
  if(!dataChannel) return;
  dataChannel.onopen = ()=> { pingDisplay.textContent = 'Ping: measuring...'; sendPing(); };
  dataChannel.onmessage = ev => {
    try {
      const msg = JSON.parse(ev.data);
      if(msg.type === 'ping') {
        // reply with pong + timestamp
        dataChannel.send(JSON.stringify({ type:'pong', t: msg.t }));
      } else if(msg.type === 'pong') {
        const now = performance.now();
        const rtt = Math.round(now - (msg.t || 0));
        pingLast = rtt;
        pingDisplay.textContent = 'Ping: ' + rtt + ' ms';
        setSignalBars(rtt);
      }
    } catch(e){}
  };
}
function sendPing(){
  if(!dataChannel || dataChannel.readyState !== 'open') return;
  const t = performance.now();
  dataChannel.send(JSON.stringify({ type:'ping', t }));
  // schedule next ping
  setTimeout(()=> sendPing(), 2000);
}
function setSignalBars(ping){
  // map ping to bars: <=50ms =>5, <=100=>4, <=200=>3, <=400=>2, >400=>1, null=>0
  let bars = 0;
  if(ping == null) bars = 0;
  else if(ping <= 50) bars = 5;
  else if(ping <= 100) bars = 4;
  else if(ping <= 200) bars = 3;
  else if(ping <= 400) bars = 2;
  else bars = 1;
  barEls.forEach((el, idx) => {
    if(idx < bars) el.classList.add('active'); else el.classList.remove('active');
  });
}

/* ----------------- UI wiring (safe order) ----------------- */
function updateUI(){
  playerCodeEl.textContent = myPlayerId || '‚Äî';
  updateAutoCleanerUI();
}

/* event handlers (buttons) */
document.getElementById('btnSingle').addEventListener('click', () => {
  // show minimal singleplayer start
  showModal(`<h3>Single Player</h3><div style="margin-top:8px">Starting single player (local).</div><div style="text-align:right;margin-top:10px"><button class="btn ghost" data-close>Close</button></div>`);
});

document.getElementById('btnLAN').addEventListener('click', () => createRoomAndHost());
document.getElementById('btnGlobal').addEventListener('click', () => {
  // create/join modal
  const m = showModal(`<h3>Rooms</h3><div style="margin-top:8px"><button id="createRoom" class="btn primary">Create Room</button><button id="joinRoom" class="btn ghost" style="margin-left:8px">Join by ID</button></div><div style="text-align:right;margin-top:10px"><button class="btn ghost" data-close>Close</button></div>`);
  m.box.querySelector('#createRoom').addEventListener('click', async ()=>{ m.close(); await createRoomAndHost(); });
  m.box.querySelector('#joinRoom').addEventListener('click', ()=>{ m.close(); joinRoomPrompt(); });
});
document.getElementById('btnRandom').addEventListener('click', async ()=>{
  // try to find first room without many participants
  try{
    const snap = await get(ref(db, 'rooms'));
    if(!snap.exists()){ await createRoomAndHost(); return; }
    const rooms = snap.val();
    const keys = Object.keys(rooms || {});
    if(keys.length === 0){ await createRoomAndHost(); return; }
    // join the first one not hosted by me
    for(const k of keys){
      if(rooms[k].host !== myPlayerId){ await joinRoomById(k); toast('Joined room ' + k); return; }
    }
    // else create
    await createRoomAndHost();
  } catch(e){ console.warn(e); toast('Random match failed'); }
});

document.getElementById('saveBtn').addEventListener('click', async ()=>{
  // save local + mirror to player node (quick save)
  try {
    localStorage.setItem('idle_quick_save_'+myPlayerId, JSON.stringify(gameState));
    if(db && myPlayerId) await set(ref(db, `players/${myPlayerId}/saves/quick`), { state: gameState, ts: Date.now() });
    toast('Saved');
  } catch(e){ toast('Save failed (check permissions)'); }
});
document.getElementById('savesBtn').addEventListener('click', ()=> openSavesDialog());
document.getElementById('exportBtn').addEventListener('click', ()=> {
  const payload = { savedAt: Date.now(), playerId: myPlayerId, state: gameState };
  const data = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(payload, null, 2));
  const a = document.createElement('a'); a.href = data; a.download = `idle-shop-${myPlayerId||'anon'}-${new Date().toISOString().slice(0,19)}.json`; document.body.appendChild(a); a.click(); a.remove();
  toast('Export started');
});
document.getElementById('importBtn').addEventListener('click', ()=> document.getElementById('importFile').click());
document.getElementById('importFile').addEventListener('change', (e)=> {
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  const r = new FileReader(); r.onload = (ev)=> {
    try { const p = JSON.parse(ev.target.result); if(p.state) { gameState = p.state; toast('Imported'); updateUI(); } else toast('Invalid import file'); } catch(e){ toast('Import failed'); }
  }; r.readAsText(f); e.target.value = '';
});

toggleAutoCleanerBtn.addEventListener('click', ()=>{
  // this control is only visible if you host something ‚Äî but still guard
  autoCleanerEnabled = !autoCleanerEnabled;
  toggleAutoCleanerBtn.textContent = 'Auto-clean: ' + (autoCleanerEnabled ? 'ON' : 'OFF');
});

/* joinRoom prompt */
function joinRoomPrompt(){
  const nm = 'rid_'+Math.random().toString(36).slice(2,6);
  const m = showModal(`<h3>Join Room</h3><div style="margin-top:8px"><input id="${nm}" placeholder="room id" class="input" /></div><div style="text-align:right;margin-top:10px"><button class="btn ghost" data-close>Cancel</button><button id="doJoin" class="btn primary">Join</button></div>`);
  m.box.querySelector('#doJoin').addEventListener('click', async ()=> {
    const rid = m.box.querySelector('#'+nm).value.trim(); if(!rid) { toast('Enter room id'); return; }
    m.close();
    await joinRoomByIdAndOpen(rid);
  });
}

/* opens saves dialog */
function openSavesDialog(){
  const store = Object.keys(localStorage).filter(k => k.startsWith('idle_quick_save_'));
  const html = `<h3>Saves</h3><div style="margin-top:8px">${store.map(k=>`<div style="display:flex;gap:8px;align-items:center;margin:6px 0"><div style="flex:1"><strong>${k}</strong></div><div style="display:flex;gap:6px"><button class="btn primary" data-load="${k}">Load</button><button class="btn ghost" data-del="${k}">Delete</button></div></div>`).join('') || '<div class="small" style="color:#666">No saves found</div>'}</div><div style="text-align:right;margin-top:10px"><button class="btn ghost" data-close>Close</button></div>`;
  const m = showModal(html);
  m.box.querySelectorAll('[data-load]').forEach(b => b.addEventListener('click', ()=> { const k = b.getAttribute('data-load'); const v = localStorage.getItem(k); if(v){ try{ gameState = JSON.parse(v); toast('Loaded ' + k); updateUI(); m.close(); }catch(e){ toast('Load failed'); } } }));
  m.box.querySelectorAll('[data-del]').forEach(b => b.addEventListener('click', ()=> { const k = b.getAttribute('data-del'); localStorage.removeItem(k); toast('Deleted ' + k); m.close(); }));
}

/* ----------------- accept invites (listen under my player node) ----------------- */
if(db){
  // listen invites for me (shows modal when created)
  onValue(ref(db, `players`), snap => {
    const all = snap.val() || {};
    if(!myPlayerId) return;
    const me = all[myPlayerId] || {};
    const invites = (me.invites) || {};
    const keys = Object.keys(invites);
    if(keys.length > 0){
      const id = keys[0]; const inv = invites[id];
      if(inv && inv.room){
        const m = showModal(`<h3>Invite</h3><div style="margin-top:8px">From <strong>${inv.from}</strong> to room <strong>${inv.room}</strong></div><div style="text-align:right;margin-top:10px"><button class="btn ghost" data-close>Ignore</button><button id="acceptInvite" class="btn primary">Join</button></div>`);
        m.box.querySelector('#acceptInvite').addEventListener('click', async ()=> {
          m.close();
          await remove(ref(db, `players/${myPlayerId}/invites/${id}`)).catch(()=>{});
          await joinRoomByIdAndOpen(inv.room);
        });
      }
    }
  });
}

/* ----------------- allow custom firebase config (confirmation required) ----------------- */
document.getElementById('btnExportConfig').addEventListener('click', ()=>{
  const m = showModal(`<h3>Set custom Firebase config</h3><div style="margin-top:8px"><textarea id="cfgArea" style="width:100%;height:160px" placeholder='Paste JSON firebaseConfig here'></textarea></div><div style="display:flex;gap:8px;margin-top:8px"><button id="applyCfg" class="btn primary">Apply (confirm)</button><button class="btn ghost" data-close>Cancel</button></div>`);
  m.box.querySelector('#applyCfg').addEventListener('click', ()=>{
    const txt = m.box.querySelector('#cfgArea').value.trim();
    if(!txt) return toast('Paste config JSON');
    try {
      const json = JSON.parse(txt);
      // ask confirm
      const c = confirm(`Replace Firebase config with provided JSON? This will re-initialize the app and sign in anonymously again. Continue?`);
      if(!c) return;
      // re-init Firebase with provided config
      initFirebase(json);
      toast('Firebase config applied ‚Äî reloading listeners');
      // re-sign in anonymously
      signInAnonymously(getAuth(app)).catch(()=>{});
      m.close();
    } catch(e){ toast('Invalid JSON'); }
  });
});

/* ----------------- Fix: ensure functions defined before usage ‚Äî done above ----------------- */

/* ----------------- initial UI update & sweeper visibility ----------------- */
updateUI();
setTimeout(()=> updateAutoCleanerUI(), 1500);

</script>
</body>
</html>
