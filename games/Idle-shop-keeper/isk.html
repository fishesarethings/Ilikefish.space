<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Idle Shop Keeper</title>
<style>
  /* (kept your original CSS mostly unchanged) */
  body { box-sizing: border-box; margin: 0; padding: 20px; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg,#667eea 0%,#764ba2 100%); min-height:100vh; color:#333; }
  .game-container { max-width:1200px; margin:0 auto; background:white; border-radius:20px; padding:30px; box-shadow:0 20px 40px rgba(0,0,0,0.1); }
  .main-menu { text-align:center; }
  .subtitle { color:#666; font-size:1.2rem; margin:10px 0 40px 0; }
  .menu-options { max-width:600px; margin:0 auto; }
  .menu-btn { width:100%; background:white; border:2px solid #e2e8f0; border-radius:15px; padding:20px; margin-bottom:15px; cursor:pointer; transition:all 0.3s ease; display:flex; align-items:center; gap:20px; text-align:left; }
  .menu-btn:hover { border-color:#4299e1; transform:translateY(-2px); box-shadow:0 8px 25px rgba(66,153,225,0.15); }
  .single-player { background:linear-gradient(135deg,#48bb78,#38a169); color:white; border-color:#38a169; }
  .single-player:hover { background:linear-gradient(135deg,#38a169,#2f855a); border-color:#2f855a; }
  .multiplayer { position: relative; }
  .btn-icon { font-size:2.5rem; min-width:60px; }
  .btn-text h3 { margin:0 0 5px 0; font-size:1.2rem; }
  .btn-text p { margin:0; color:#666; font-size:0.9rem; }
  .single-player .btn-text p { color:rgba(255,255,255,0.8); }
  .status-indicator { margin-left:auto; font-size:0.8rem; font-weight:bold; display:flex; align-items:center; gap:8px; }
  .status-dot { width:12px; height:12px; border-radius:50%; display:inline-block; }
  .status-dot.green { background:#38a169; } .status-dot.yellow { background:#ecc94b; } .status-dot.red { background:#e53e3e; }
  .multiplayer-section { margin-top:40px; }
  .multiplayer-section h2 { color:#4a5568; margin-bottom:20px; font-size:1.3rem; }
  .game-screen { animation:fadeIn 0.5s ease-in; }
  @keyframes fadeIn { from {opacity:0; transform:translateY(20px);} to {opacity:1; transform:translateY(0);} }
  .header { text-align:center; margin-bottom:30px; }
  .header h1 { color:#4a5568; margin:0; font-size:2.5rem; }
  .stats { display:grid; grid-template-columns:repeat(auto-fit,minmax(200px,1fr)); gap:20px; margin-bottom:30px; }
  .stat-card { background:linear-gradient(135deg,#48bb78,#38a169); color:white; padding:20px; border-radius:15px; text-align:center; box-shadow:0 4px 15px rgba(72,187,120,0.3); }
  .stat-card h3 { margin:0 0 10px 0; font-size:1.1rem; opacity:0.9; }
  .stat-value { font-size:2rem; font-weight:bold; margin:0; }
  .game-sections { display:grid; grid-template-columns:1fr 1fr; gap:30px; margin-bottom:30px; }
  .section { background:#f7fafc; border-radius:15px; padding:25px; border:2px solid #e2e8f0; }
  .section h2 { color:#2d3748; margin:0 0 20px 0; font-size:1.5rem; text-align:center; }
  .inventory-grid { display:grid; grid-template-columns:repeat(auto-fill,minmax(120px,1fr)); gap:15px; }
  .item-card { background:white; border-radius:10px; padding:15px; text-align:center; border:2px solid #e2e8f0; transition:all 0.3s ease; }
  .item-card:hover { transform:translateY(-2px); box-shadow:0 4px 15px rgba(0,0,0,0.1); }
  .item-emoji { font-size:2rem; margin-bottom:8px; }
  .item-name { font-weight:bold; margin-bottom:5px; font-size:0.9rem; }
  .item-count { color:#666; font-size:0.8rem; margin-bottom:10px; }
  .buy-btn, .upgrade-btn { background:linear-gradient(135deg,#4299e1,#3182ce); color:white; border:none; padding:8px 16px; border-radius:8px; cursor:pointer; font-size:0.8rem; font-weight:bold; transition:all 0.3s ease; width:100%; }
  .buy-btn:hover, .upgrade-btn:hover { background:linear-gradient(135deg,#3182ce,#2c5282); transform:translateY(-1px); }
  .buy-btn:disabled, .upgrade-btn:disabled { background:#cbd5e0; cursor:not-allowed; transform:none; }
  .upgrades-section { grid-column:1 / -1; }
  .upgrades-grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(250px,1fr)); gap:20px; }
  .upgrade-card { background:white; border-radius:12px; padding:20px; border:2px solid #e2e8f0; text-align:center; }
  .upgrade-card h3 { color:#2d3748; margin:0 0 10px 0; }
  .upgrade-description { color:#666; font-size:0.9rem; margin-bottom:15px; }
  .customer-queue { background:#fff5f5; border:2px solid #fed7d7; border-radius:12px; padding:20px; margin-bottom:20px; }
  .customer { display:flex; align-items:center; justify-content:space-between; background:white; padding:15px; border-radius:8px; margin-bottom:10px; border:1px solid #e2e8f0; }
  .customer-info { display:flex; align-items:center; gap:10px; }
  .customer-emoji { font-size:1.5rem; }
  .serve-btn { background:linear-gradient(135deg,#48bb78,#38a169); color:white; border:none; padding:8px 16px; border-radius:6px; cursor:pointer; font-weight:bold; }
  .serve-btn:hover { background:linear-gradient(135deg,#38a169,#2f855a); }
  .serve-btn:disabled { background:#cbd5e0; cursor:not-allowed; }
  .small { font-size:0.85rem; color:#555; }
  .controls { display:flex; gap:10px; align-items:center; justify-content:center; margin-top:10px; }
  .players-list { max-height:160px; overflow:auto; padding:8px; border-radius:8px; background:#f7fafc; border:1px solid #e2e8f0; }
  .player-row { display:flex; justify-content:space-between; align-items:center; padding:6px 8px; border-bottom:1px dashed #e2e8f0; }
  .player-row:last-child { border-bottom: none; }
  /* modal & toast */
  .modal-backdrop { position:fixed; inset:0; background:rgba(0,0,0,0.45); display:flex; align-items:center; justify-content:center; z-index:2000; }
  .modal { background:white; padding:18px; border-radius:12px; width:320px; max-width:90%; box-shadow:0 8px 30px rgba(0,0,0,0.25); }
  .modal h3 { margin:0 0 8px 0; font-size:1.1rem; color:#2d3748; }
  .modal .row { margin-top:10px; }
  .input { width:100%; padding:8px 10px; border-radius:8px; border:1px solid #e2e8f0; }
  .btn { padding:8px 12px; border-radius:8px; border:none; cursor:pointer; }
  .btn.primary { background:#4299e1; color:white; }
  .btn.ghost { background:#e2e8f0; color:#2d3748; }
  #toastArea { position:fixed; right:18px; bottom:18px; display:flex; flex-direction:column; gap:8px; z-index:3000; }
  .toast { background:#2d3748; color:white; padding:8px 12px; border-radius:8px; opacity:0.95; min-width:180px; }
  @media (max-width:768px) { .game-sections { grid-template-columns:1fr; } .stats { grid-template-columns:1fr; } .upgrades-grid { grid-template-columns:1fr; } }
</style>
</head>
<body>
  <div class="game-container">
    <!-- Main Menu Screen -->
    <div id="mainMenu" class="main-menu">
      <div class="header">
        <h1>üè™ Idle Shop Keeper</h1>
        <p class="subtitle">Build your retail empire!</p>
      </div>

      <div class="menu-options">
        <button class="menu-btn single-player" id="btnSingle">
          <div class="btn-icon">üéÆ</div>
          <div class="btn-text"><h3>Single Player</h3><p>Play solo and build your shop</p></div>
        </button>

        <div style="margin:10px 0; text-align:left">
          <strong>Friends & Recent</strong>
          <div style="display:flex; gap:10px; margin-top:8px; justify-content:center">
            <button id="btnFriends" class="menu-btn multiplayer">üë• Friends</button>
            <button id="btnRecent" class="menu-btn multiplayer">üïò Recent</button>
          </div>
        </div>

        <div class="multiplayer-section">
          <h2>üåê Multiplayer Options</h2>

          <div style="display:grid; gap:12px;">
            <div style="display:flex; gap:12px; align-items:center;">
              <button class="menu-btn multiplayer" id="btnLAN" style="flex:1;">
                <div class="btn-icon">üè†</div>
                <div class="btn-text"><h3>Local Network (LAN)</h3><p>Play with friends on same WiFi</p></div>
                <div class="status-indicator" id="lanIndicator"><span class="status-dot green"></span><span id="lanLabel">Available</span></div>
              </button>
            </div>

            <div style="display:flex; gap:12px; align-items:center;">
              <button class="menu-btn multiplayer" id="btnRandom" style="flex:1;">
                <div class="btn-icon">üé≤</div>
                <div class="btn-text"><h3>Random Match</h3><p>Find a random opponent online</p></div>
                <div class="status-indicator" id="randIndicator"><span class="status-dot red"></span><span id="randLabel">Idle</span></div>
              </button>
            </div>

            <div style="display:flex; gap:12px; align-items:center;">
              <button class="menu-btn multiplayer" id="btnGlobal" style="flex:1;">
                <div class="btn-icon">üåç</div>
                <div class="btn-text"><h3>Global Match</h3><p>Compete with players worldwide</p></div>
                <div class="status-indicator" id="globalIndicator"><span class="status-dot red"></span><span id="globalLabel">Offline</span></div>
              </button>
            </div>

            <div style="margin-top:6px;">
              <h3 style="margin:6px 0 6px 0;">Available Players</h3>
              <div id="playersPanel" class="players-list">
                <div class="small" style="text-align:center;color:#666;">Loading players...</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Game Screen -->
    <div id="gameScreen" class="game-screen" style="display:none;">
      <div class="header"><h1>üè™ Idle Shop Keeper</h1></div>

      <div class="stats">
        <div class="stat-card"><h3>üí∞ Money</h3><p class="stat-value" id="money">$100</p></div>
        <div class="stat-card"><h3>üë• Customers Served</h3><p class="stat-value" id="customersServed">0</p></div>
        <div class="stat-card"><h3>‚≠ê Shop Level</h3><p class="stat-value" id="shopLevel">1</p></div>
      </div>

      <div class="customer-queue">
        <h2>üö∂‚Äç‚ôÇÔ∏è Customer Queue</h2>
        <div id="customerList"><p style="text-align:center;color:#666;">No customers waiting...</p></div>
      </div>

      <div class="game-sections">
        <div class="section">
          <h2>üì¶ Shop Inventory</h2>
          <div class="inventory-grid" id="inventory"></div>
        </div>

        <div class="section">
          <h2>üõí Buy Items</h2>
          <div class="small" style="text-align:center">Unlocked items: <span id="unlockedCount">6</span> / 5000</div>
          <div class="inventory-grid" id="buySection"></div>
        </div>
      </div>

      <div class="section upgrades-section">
        <h2>‚¨ÜÔ∏è Shop Upgrades</h2>
        <div class="upgrades-grid" id="upgrades"></div>

        <div style="margin-top:20px">
          <h3>üõ†Ô∏è Workers & Manager</h3>
          <div id="workersPanel" style="display:grid; grid-template-columns:repeat(auto-fit,minmax(200px,1fr)); gap:12px; margin-top:10px"></div>

          <div class="controls">
            <button id="autosaveBtn" class="upgrade-btn" style="width:auto;">Autosave: ON</button>
            <button id="saveBtn" class="upgrade-btn" style="width:auto;">Save</button>
            <button id="savesBtn" class="upgrade-btn" style="width:auto;">Saves</button>
            <button id="exitNoSave" class="upgrade-btn" style="width:auto; background:#e53e3e">Exit (no save)</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal container and toast -->
  <div id="modalRoot" style="position:fixed; inset:0; pointer-events:none; z-index:2500;"></div>
  <div id="toastArea"></div>

<script type="module">
/* ---------- Firebase + WebRTC + Game logic (no alerts, UI modals & toasts) ---------- */
/* Uses: firebase-app, firebase-database v12.x via modules */
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-app.js";
import { getDatabase, ref, set, push, onValue, onChildAdded, child, get, remove, update } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-database.js";
import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-analytics.js";

/* ---------- config (unchanged) ---------- */
const firebaseConfig = {
  apiKey: "AIzaSyBn4khIpi57YvqQX2urCup2mCvpVUZ0j8k",
  authDomain: "idle-shop-keeper.firebaseapp.com",
  databaseURL: "https://idle-shop-keeper-default-rtdb.firebaseio.com",
  projectId: "idle-shop-keeper",
  storageBucket: "idle-shop-keeper.firebasestorage.app",
  messagingSenderId: "117380146729",
  appId: "1:117380146729:web:8180d507d5a2aae45e5e38",
  measurementId: "G-VS2Z5T0Y9Y"
};

const app = initializeApp(firebaseConfig);
try { getAnalytics(app); } catch(e) { /* ignore */ }
const db = getDatabase(app);

/* ---------- helper UI (modals & toasts) ---------- */
const modalRoot = document.getElementById('modalRoot');
function showModal(contentHTML, opts = {}) {
  // opts: onClose callback
  const backdrop = document.createElement('div');
  backdrop.className = 'modal-backdrop';
  backdrop.style.pointerEvents = 'auto';
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.innerHTML = contentHTML;
  backdrop.appendChild(modal);
  modalRoot.appendChild(backdrop);
  function close() {
    try { backdrop.remove(); } catch(e) {}
    if (opts.onClose) opts.onClose();
  }
  // attach close to elements with data-close
  modal.querySelectorAll('[data-close]').forEach(el => el.addEventListener('click', close));
  return { backdrop, close, modal };
}
function toast(msg, time = 3500) {
  const area = document.getElementById('toastArea');
  const t = document.createElement('div'); t.className = 'toast'; t.textContent = msg;
  area.appendChild(t);
  setTimeout(()=> t.style.opacity = '0.0', time - 400);
  setTimeout(()=> t.remove(), time);
}

/* ---------- storage keys ---------- */
const STORAGE_KEY = 'idle_shop_saves_v1';
const META_KEY = 'idle_shop_meta_v1';

/* ---------- safer id generation ---------- */
function generateId() {
  if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') return 'p-' + crypto.randomUUID();
  return 'p-' + Math.random().toString(36).slice(2,10) + Date.now().toString(36).slice(-6);
}

/* ---------- initial state (kept from you) ---------- */
let gameState = {
  money: 100,
  customersServed: 0,
  shopLevel: 1,
  inventory: {},
  upgrades: { autoCustomer:0, fasterService:0, betterPrices:0, moreCustomers:0 },
  customers: [],
  workers: { manager:{level:0, assigned:'idle'}, restocker:{level:0, assigned:'idle'}, server:{level:0, assigned:'idle'} },
  playerId: null,
  unlockedCount: 6,
  recentOpponents: [],
  friends: [],
  autosave: true
};

const TOTAL_ITEMS = 5000;
const items = {};

function generateItems() {
  const base = [
    { key:'apple', emoji:'üçé', name:'Apple', buyPrice:5, sellPrice:8 },
    { key:'bread', emoji:'üçû', name:'Bread', buyPrice:8, sellPrice:12 },
    { key:'milk', emoji:'ü•õ', name:'Milk', buyPrice:12, sellPrice:18 },
    { key:'candy', emoji:'üç¨', name:'Candy', buyPrice:15, sellPrice:25 },
    { key:'coffee', emoji:'‚òï', name:'Coffee', buyPrice:20, sellPrice:35 },
    { key:'cake', emoji:'üéÇ', name:'Cake', buyPrice:30, sellPrice:50 }
  ];
  base.forEach(it => { items[it.key] = it; gameState.inventory[it.key] = gameState.inventory[it.key] || 0; });
  for (let i = base.length + 1; i <= TOTAL_ITEMS; i++) {
    const key = 'item_' + i;
    const buy = 5 + Math.floor(i * 0.8);
    const sell = Math.floor(buy * 1.6);
    items[key] = { emoji:'üéÅ', name:`Item ${i}`, buyPrice:buy, sellPrice:sell };
    gameState.inventory[key] = gameState.inventory[key] || 0;
  }
}

const upgradeDefinitions = {
  autoCustomer:{name:'Auto Customer',description:'Customers arrive automatically',baseCost:200},
  fasterService:{name:'Faster Service',description:'Serve customers 25% faster',baseCost:150},
  betterPrices:{name:'Better Prices',description:'Earn 20% more per sale',baseCost:300},
  moreCustomers:{name:'More Customers',description:'More customers in queue',baseCost:250}
};
const workerDefs = {
  manager:{name:'Manager',description:'Enable worker coordination; required to assign tasks',baseCost:500},
  restocker:{name:'Restocker',description:'Automatically restocks inventory when assigned',baseCost:300},
  server:{name:'Server',description:'Automatically serves customers when assigned',baseCost:350}
};
const customerTypes = [
  {emoji:'üë®', wants:['apple','bread']},
  {emoji:'üë©', wants:['milk','coffee']},
  {emoji:'üë¶', wants:['candy','cake']},
  {emoji:'üëß', wants:['apple','candy']},
  {emoji:'üßì', wants:['bread','milk']},
  {emoji:'üë¥', wants:['coffee','cake']}
];

/* ---------- UI update functions ---------- */
function updateStats() {
  document.getElementById('money').textContent = `$${gameState.money}`;
  document.getElementById('customersServed').textContent = gameState.customersServed;
  document.getElementById('shopLevel').textContent = gameState.shopLevel;
  document.getElementById('unlockedCount').textContent = gameState.unlockedCount;
  const autoBtn = document.getElementById('autosaveBtn');
  if (autoBtn) autoBtn.textContent = 'Autosave: ' + (gameState.autosave ? 'ON' : 'OFF');
}

function updateInventory() {
  const inventoryDiv = document.getElementById('inventory');
  inventoryDiv.innerHTML = '';
  const keys = Object.keys(items).slice(0, gameState.unlockedCount);
  keys.forEach(itemKey=>{
    const item = items[itemKey]; const count = gameState.inventory[itemKey]||0;
    const itemCard = document.createElement('div'); itemCard.className='item-card';
    itemCard.innerHTML = `<div class="item-emoji">${item.emoji}</div><div class="item-name">${item.name}</div><div class="item-count">Stock: ${count}</div>`;
    inventoryDiv.appendChild(itemCard);
  });
}

function updateBuySection() {
  const buyDiv = document.getElementById('buySection'); buyDiv.innerHTML='';
  const keys = Object.keys(items).slice(0, gameState.unlockedCount);
  keys.forEach(itemKey=>{
    const item = items[itemKey];
    const itemCard = document.createElement('div'); itemCard.className='item-card';
    itemCard.innerHTML = `<div class="item-emoji">${item.emoji}</div><div class="item-name">${item.name}</div><div class="item-count">$${item.buyPrice}</div><button class="buy-btn" data-key="${itemKey}">Buy</button>`;
    buyDiv.appendChild(itemCard);
  });
  buyDiv.querySelectorAll('.buy-btn').forEach(b=>{
    const key = b.getAttribute('data-key'); b.disabled = gameState.money < items[key].buyPrice;
    b.onclick = ()=> buyItem(key);
  });
}

function updateUpgrades() {
  const upgradesDiv = document.getElementById('upgrades'); upgradesDiv.innerHTML='';
  Object.keys(upgradeDefinitions).forEach(upgradeKey=>{
    const upgrade = upgradeDefinitions[upgradeKey]; const level = gameState.upgrades[upgradeKey];
    const cost = Math.floor(upgrade.baseCost * Math.pow(1.5, level));
    const upgradeCard = document.createElement('div'); upgradeCard.className='upgrade-card';
    upgradeCard.innerHTML = `<h3>${upgrade.name}</h3><div class="upgrade-description">${upgrade.description}</div><div style="margin-bottom:10px;">Level: ${level}</div><div style="margin-bottom:15px;">Cost: $${cost}</div><button class="upgrade-btn" data-key="${upgradeKey}">Upgrade</button>`;
    upgradesDiv.appendChild(upgradeCard);
  });
  upgradesDiv.querySelectorAll('.upgrade-btn').forEach(btn=>{
    const key = btn.getAttribute('data-key'); const level = gameState.upgrades[key]; const cost = Math.floor(upgradeDefinitions[key].baseCost * Math.pow(1.5, level));
    btn.disabled = gameState.money < cost; btn.onclick = ()=> buyUpgrade(key);
  });
  renderWorkersPanel();
}

function renderWorkersPanel() {
  const panel = document.getElementById('workersPanel'); panel.innerHTML='';
  Object.keys(gameState.workers).forEach(wKey=>{
    const w = gameState.workers[wKey]; const def = workerDefs[wKey]; const cost = Math.floor(def.baseCost * Math.pow(1.6, w.level));
    const card = document.createElement('div'); card.className='upgrade-card';
    card.innerHTML = `<h3>${def.name}</h3><div class="upgrade-description">${def.description}</div><div class="small">Level: ${w.level}</div><div class="small">Assigned: ${w.assigned}</div><div style="margin-top:8px; display:grid; gap:6px"><button class="upgrade-btn" data-buy="${wKey}">Buy/Upgrade ($${cost})</button>${wKey!=='manager' ? `<select id="assign_${wKey}"><option value="idle">Idle</option><option value="restock">Restock</option><option value="serve">Serve</option></select>` : `<select id="assign_${wKey}"><option value="idle">Idle</option><option value="manage">Manage</option><option value="assign">Assign Tasks</option></select>` }</div>`;
    panel.appendChild(card);
    const buyBtn = card.querySelector('[data-buy]'); buyBtn.disabled = gameState.money < cost; buyBtn.onclick = ()=> upgradeWorker(wKey);
    setTimeout(()=>{ const sel = document.getElementById('assign_'+wKey); if(sel){ sel.value = w.assigned; sel.onchange = ()=> assignWorker(wKey, sel.value); } }, 10);
  });
}

function updateCustomers() {
  const customerList = document.getElementById('customerList');
  if(gameState.customers.length === 0) { customerList.innerHTML = '<p style="text-align:center;color:#666;">No customers waiting...</p>'; return; }
  customerList.innerHTML = '';
  gameState.customers.forEach((customer,index)=>{
    const customerDiv = document.createElement('div'); customerDiv.className='customer';
    const item = items[customer.wants]; const canServe = (gameState.inventory[customer.wants]||0) > 0;
    customerDiv.innerHTML = `<div class="customer-info"><span class="customer-emoji">${customer.emoji}</span><span>Wants ${item.emoji} ${item.name} - $${item.sellPrice}</span></div><button class="serve-btn" data-i="${index}">${canServe ? 'Serve' : 'No Stock'}</button>`;
    customerList.appendChild(customerDiv);
    const btn = customerDiv.querySelector('.serve-btn'); btn.disabled = !canServe; btn.onclick = ()=> serveCustomer(index);
  });
}

/* ---------- game actions ---------- */
function buyItem(itemKey) {
  const item = items[itemKey];
  if(gameState.money >= item.buyPrice){ gameState.money -= item.buyPrice; gameState.inventory[itemKey] = (gameState.inventory[itemKey]||0)+1; updateAll(); }
}
function serveCustomer(index) {
  const customer = gameState.customers[index];
  if(!customer) return;
  const item = items[customer.wants];
  if((gameState.inventory[customer.wants]||0) > 0){
    gameState.inventory[customer.wants]--;
    let earnings = item.sellPrice;
    if(gameState.upgrades.betterPrices>0) earnings = Math.floor(earnings * (1 + 0.2 * gameState.upgrades.betterPrices));
    gameState.money += earnings;
    gameState.customersServed++;
    gameState.customers.splice(index,1);
    if(gameState.customersServed % 10 === 0){ gameState.shopLevel++; gameState.unlockedCount = Math.min(TOTAL_ITEMS, gameState.unlockedCount + 10); }
    updateAll();
  }
}
function buyUpgrade(upgradeKey) {
  const upgrade = upgradeDefinitions[upgradeKey]; const level = gameState.upgrades[upgradeKey]; const cost = Math.floor(upgrade.baseCost * Math.pow(1.5, level));
  if(gameState.money >= cost){ gameState.money -= cost; gameState.upgrades[upgradeKey]++; updateAll(); }
}
function upgradeWorker(wKey) {
  const def = workerDefs[wKey]; const level = gameState.workers[wKey].level; const cost = Math.floor(def.baseCost * Math.pow(1.6, level));
  if(gameState.money >= cost){ gameState.money -= cost; gameState.workers[wKey].level++; updateAll(); }
}
function assignWorker(wKey, task) {
  if(gameState.workers.manager.level < 1 && wKey !== 'manager') { toast('Manager required for automation'); const sel = document.getElementById('assign_'+wKey); if(sel) sel.value = 'idle'; return; }
  gameState.workers[wKey].assigned = task; updateAll();
}
function spawnCustomer() {
  const maxCustomers = 3 + gameState.upgrades.moreCustomers;
  if(gameState.customers.length < maxCustomers) {
    const customerType = customerTypes[Math.floor(Math.random()*customerTypes.length)];
    const wantedItem = customerType.wants[Math.floor(Math.random()*customerType.wants.length)];
    gameState.customers.push({ emoji: customerType.emoji, wants: wantedItem });
    updateCustomers();
  }
}
function workerTick() {
  const rest = gameState.workers.restocker;
  if(rest.level > 0 && rest.assigned === 'restock' && gameState.workers.manager.level > 0) {
    if(Math.random() < 0.3 + rest.level * 0.15) {
      const unlockedKeys = Object.keys(items).slice(0, gameState.unlockedCount);
      let cheapestKey = unlockedKeys[0]; unlockedKeys.forEach(k=>{ if(items[k].buyPrice < items[cheapestKey].buyPrice) cheapestKey = k; });
      const amount = 1 + rest.level; const cost = items[cheapestKey].buyPrice * amount;
      if(gameState.money >= cost){ gameState.money -= cost; gameState.inventory[cheapestKey] = (gameState.inventory[cheapestKey]||0) + amount; }
    }
  }
  const srv = gameState.workers.server;
  if(srv.level > 0 && srv.assigned === 'serve' && gameState.workers.manager.level > 0) {
    if(gameState.customers.length > 0 && Math.random() < 0.4 + srv.level * 0.15) {
      for(let i=0;i<gameState.customers.length;i++){ const c = gameState.customers[i]; if((gameState.inventory[c.wants]||0) > 0){ serveCustomer(i); break; } }
    }
  }
}
function updateAll() { updateStats(); updateInventory(); updateBuySection(); updateUpgrades(); updateCustomers(); try{ localStorage.setItem(META_KEY, JSON.stringify({ playerId:gameState.playerId, friends:gameState.friends, recent:gameState.recentOpponents })); }catch(e){} }

/* ---------- game loop ---------- */
let gameLoopInterval = null;
function gameLoop() {
  if(gameState.upgrades.autoCustomer > 0) if(Math.random() < 0.3 + (gameState.upgrades.autoCustomer * 0.1)) spawnCustomer();
  if(Math.random() < 0.1 + (gameState.shopLevel * 0.02)) spawnCustomer();
  workerTick();
  if(gameState.autosave) quickSave();
}

/* ---------- saves (local + firebase mirror) ---------- */
function getSaves(){ try{ return JSON.parse(localStorage.getItem(STORAGE_KEY)||'{}'); }catch(e){ return {}; } }
function setSaves(s){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(s)); }catch(e){} }

async function saveToSlotUI(slotName) {
  const name = slotName || await showTextInputModal('Save Game', 'Enter slot name', `Save-${new Date().toISOString().slice(0,19).replace(/[:T]/g,'-')}`);
  if(!name) return;
  const saves = getSaves(); const payload = { state: JSON.parse(JSON.stringify(gameState)), timestamp: Date.now() };
  saves[name] = payload; setSaves(saves);
  // mirror to firebase
  try{ if(gameState.playerId) await set(ref(db, `players/${gameState.playerId}/saves/${name}`), payload); } catch(e) { toast('Firebase save failed'); }
  toast('Saved: ' + name);
}

async function loadFromSlotUI(slotName) {
  const saves = getSaves(); if(!slotName) {
    // show modal list
    const keys = Object.keys(saves);
    if(keys.length === 0) { toast('No local saves found'); return; }
    const content = `<h3>Load Save</h3><div class="row">${keys.map(k=>`<div style="display:flex;gap:8px;align-items:center;margin:6px 0"><div style="flex:1">${k}<div class="small" style="color:#666">${new Date(saves[k].timestamp).toLocaleString()}</div></div><button class="btn primary" data-load="${k}">Load</button></div>`).join('')}</div><div style="text-align:right;margin-top:10px"><button class="btn ghost" data-close>Close</button></div>`;
    const modal = showModal(content);
    modal.modal.querySelectorAll('[data-load]').forEach(b=>b.addEventListener('click', ()=> { const k = b.getAttribute('data-load'); modal.close(); loadFromSlot(k); }));
    return;
  } else {
    await loadFromSlot(slotName);
  }
}

async function loadFromSlot(slotName) {
  const saves = getSaves();
  if(!saves[slotName]) {
    // try firebase fallback
    try {
      if(gameState.playerId) {
        const snap = await get(ref(db, `players/${gameState.playerId}/saves/${slotName}`));
        if(snap.exists()) {
          const payload = snap.val();
          gameState = JSON.parse(JSON.stringify(payload.state));
          restoreStatePostLoad();
          toast('Loaded from Firebase: ' + slotName);
          return;
        }
      }
    } catch(e){ toast('Load failed'); return; }
    toast('Slot not found: ' + slotName); return;
  }
  gameState = JSON.parse(JSON.stringify(saves[slotName].state));
  restoreStatePostLoad();
  toast('Loaded: ' + slotName);
}

function restoreStatePostLoad() {
  generateItems();
  gameState.inventory = gameState.inventory || {};
  gameState.upgrades = gameState.upgrades || { autoCustomer:0,fasterService:0,betterPrices:0,moreCustomers:0 };
  gameState.workers = gameState.workers || { manager:{level:0,assigned:'idle'}, restocker:{level:0,assigned:'idle'}, server:{level:0,assigned:'idle'} };
  gameState.recentOpponents = gameState.recentOpponents || [];
  gameState.friends = gameState.friends || [];
  updateAll();
}

function quickSave() {
  try {
    const saves = getSaves(); const key = 'quick_' + gameState.playerId;
    saves[key] = { state: JSON.parse(JSON.stringify(gameState)), timestamp: Date.now() };
    setSaves(saves);
    if(gameState.playerId) set(ref(db, `players/${gameState.playerId}/saves/${key}`), saves[key]).catch(()=>{});
  } catch(e){}
}

function toggleAutoSave() { gameState.autosave = !gameState.autosave; updateStats(); }

/* ---------- friends & recent (local + firebase meta) ---------- */
async function pushMetaToFirebase() {
  if(!gameState.playerId) return;
  try { await set(ref(db, `players/${gameState.playerId}/meta`), { friends:gameState.friends, recent:gameState.recentOpponents, lastSeen:Date.now() }); } catch(e) { console.warn(e); }
}
function addRecentOpponent(id) { if(!id) return; gameState.recentOpponents.unshift(id); gameState.recentOpponents = [...new Set(gameState.recentOpponents)].slice(0,20); try{ localStorage.setItem(META_KEY, JSON.stringify({ playerId:gameState.playerId, friends:gameState.friends, recent:gameState.recentOpponents })); }catch(e){} pushMetaToFirebase(); }
function addFriend(id) { if(!id) return; gameState.friends.unshift(id); gameState.friends = [...new Set(gameState.friends)].slice(0,50); try{ localStorage.setItem(META_KEY, JSON.stringify({ playerId:gameState.playerId, friends:gameState.friends, recent:gameState.recentOpponents })); }catch(e){} pushMetaToFirebase(); }

/* ---------- helper UI modals ---------- */
function showTextInputModal(title, subtitle, defaultValue='') {
  return new Promise((resolve) => {
    const id = 'input_' + Math.random().toString(36).slice(2,8);
    const content = `<h3>${title}</h3><div class="row"><div class="small" style="color:#666">${subtitle}</div><input id="${id}" class="input" value="${defaultValue}" /></div><div style="text-align:right;margin-top:12px"><button class="btn ghost" data-close>Cancel</button><button class="btn primary" id="okBtn">OK</button></div>`;
    const m = showModal(content, { onClose: ()=> resolve(null) });
    setTimeout(()=> {
      const input = m.modal.querySelector('#'+id); input.focus(); input.select();
      m.modal.querySelector('#okBtn').addEventListener('click', ()=> { const v = input.value.trim(); m.close(); resolve(v||null); });
    }, 10);
  });
}

/* ---------- WebRTC signaling via Firebase (UI-driven, no native dialogs) ---------- */
let pc = null, currentRoomRef = null, roomIdGlobal = null;

async function createPeerConnection(onTrackCallback) {
  const conf = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
  pc = new RTCPeerConnection(conf);
  pc.onicecandidate = (event) => {
    if(!event.candidate || !currentRoomRef) return;
    const path = `rooms/${roomIdGlobal}/candidates/${gameState.playerId}`;
    push(ref(db, path), event.candidate.toJSON()).catch(()=>{});
  };
  pc.ontrack = (ev) => { if(onTrackCallback) onTrackCallback(ev.streams[0]); };
  pc.onconnectionstatechange = () => {
    if(!pc) return;
    const state = pc.connectionState;
    if(state === 'connected') { toast('Peer connected'); }
    if(state === 'disconnected' || state === 'failed' || state === 'closed') { toast('Peer disconnected'); }
  };
  // small data channel for basic messaging
  const dc = pc.createDataChannel('game');
  dc.onopen = ()=> console.log('DataChannel open');
  dc.onmessage = (m)=> console.log('DC msg', m.data);
  return pc;
}

async function connectToRoomAsCaller(roomId) {
  roomIdGlobal = roomId; currentRoomRef = ref(db, `rooms/${roomIdGlobal}`);
  pc = await createPeerConnection();
  const offer = await pc.createOffer(); await pc.setLocalDescription(offer);
  try {
    await set(ref(db, `rooms/${roomIdGlobal}/offer`), { sdp: offer.sdp, type: offer.type, from: gameState.playerId, createdAt:Date.now() });
    // listen for answer
    onValue(ref(db, `rooms/${roomIdGlobal}/answer`), async snap => {
      const val = snap.val(); if(!val || !val.sdp) return;
      const answerDesc = { type: val.type, sdp: val.sdp };
      try { await pc.setRemoteDescription(answerDesc); } catch(e){ console.warn(e); }
      addRecentOpponent(val.from || 'peer');
      updateConnectionLabels('global', true);
    });
    // candidates (both sides push to candidates/{playerId})
    onChildAdded(ref(db, `rooms/${roomIdGlobal}/candidates`), async snap => {
      const val = snap.val(); if(!val) return;
      // val is an object of players->pushedCandidateKeys->candidate; flatten and add
      Object.values(val).forEach(async sub => { try{ await pc.addIceCandidate(sub); } catch(e){} });
    });
    toast('Room created: ' + roomIdGlobal);
    updateConnectionLabels('global', true);
  } catch(e){ toast('Failed creating room'); console.warn(e); }
}

async function connectToRoomAsCallee(roomId) {
  roomIdGlobal = roomId; currentRoomRef = ref(db, `rooms/${roomIdGlobal}`);
  const offerSnap = await get(child(ref(db), `rooms/${roomIdGlobal}/offer`));
  if(!offerSnap.exists()){ toast('Offer not found'); return; }
  const offer = offerSnap.val();
  pc = await createPeerConnection();
  await pc.setRemoteDescription({ type: offer.type, sdp: offer.sdp });
  const answer = await pc.createAnswer(); await pc.setLocalDescription(answer);
  await set(ref(db, `rooms/${roomIdGlobal}/answer`), { sdp: answer.sdp, type: answer.type, from: gameState.playerId, answeredAt:Date.now() });
  onChildAdded(ref(db, `rooms/${roomIdGlobal}/candidates`), async snap => {
    const val = snap.val(); if(!val) return;
    Object.values(val).forEach(async sub=>{ try{ await pc.addIceCandidate(sub); } catch(e){} });
  });
  addRecentOpponent(offer.from || 'peer');
  updateConnectionLabels('global', true);
  toast('Joined room: ' + roomIdGlobal);
}

async function createRoomAndWaitUI() {
  const rid = Math.random().toString(36).slice(2,10);
  try {
    await set(ref(db, `rooms/${rid}`), { createdAt:Date.now(), host:gameState.playerId });
    await connectToRoomAsCaller(rid);
    // show room id in modal
    const content = `<h3>Room Created</h3><div class="row"><div class="small" style="color:#666">Share this Room ID with another player to join:</div><div style="margin-top:8px;padding:8px;border-radius:8px;background:#f7fafc;border:1px solid #e2e8f0;text-align:center;font-weight:bold">${rid}</div></div><div style="text-align:right;margin-top:12px"><button class="btn ghost" data-close>Close</button></div>`;
    showModal(content);
  } catch(e){ toast('Failed to create room'); console.warn(e); }
}

async function joinRoomUI() {
  const roomId = await showTextInputModal('Join Room', 'Enter room ID to join', '');
  if(!roomId) return;
  try { await connectToRoomAsCallee(roomId); } catch(e){ toast('Join failed'); console.warn(e); }
}

async function randomMatchUI() {
  // try join any room with an offer and no answer; else create one
  try {
    const roomsSnap = await get(ref(db, 'rooms'));
    const rooms = roomsSnap.exists() ? roomsSnap.val() : {};
    for(const [rid,data] of Object.entries(rooms)) {
      const offerSnap = await get(child(ref(db), `rooms/${rid}/offer`));
      const answerSnap = await get(child(ref(db), `rooms/${rid}/answer`));
      if(offerSnap.exists() && !answerSnap.exists()) { await connectToRoomAsCallee(rid); document.getElementById('randLabel').innerText='Matched'; return; }
    }
    // none found -> create
    await createRoomAndWaitUI();
    document.getElementById('randLabel').innerText='Waiting';
  } catch(e){ toast('Random match failed'); console.warn(e); }
}

/* ---------- connection labels & players list (live) ---------- */
function updateConnectionLabels(which, connected) {
  const map = { globalLabel:'globalLabel', randLabel:'randLabel', lanLabel:'lanLabel' };
  if(which === 'global') {
    document.getElementById('globalLabel').textContent = connected ? 'Connected' : 'Offline';
    document.getElementById('globalIndicator').querySelector('.status-dot').className = 'status-dot ' + (connected ? 'green' : 'red');
  }
  if(which === 'random') {
    document.getElementById('randLabel').textContent = connected ? 'Matched' : 'Idle';
    document.getElementById('randIndicator').querySelector('.status-dot').className = 'status-dot ' + (connected ? 'green' : 'red');
  }
  if(which === 'lan') {
    document.getElementById('lanLabel').textContent = connected ? 'Available' : 'Unavailable';
    document.getElementById('lanIndicator').querySelector('.status-dot').className = 'status-dot ' + (connected ? 'green' : 'red');
  }
}

/* ---------- presence and available players list ---------- */
async function writePresence() {
  if(!gameState.playerId) return;
  try {
    const pRef = ref(db, `players/${gameState.playerId}/presence`);
    await set(pRef, { lastSeen: Date.now(), playerId: gameState.playerId });
    // remove presence on disconnect - best effort (server-side enforcement requires security rules)
    // We can't call onDisconnect() with module imports easily here; skip for minimal
  } catch(e){ console.warn('presence write failed', e); }
}

function listenForPlayers() {
  const playersPanel = document.getElementById('playersPanel');
  // Listen to /players for meta + presence
  onValue(ref(db, 'players'), snapshot => {
    const all = snapshot.val() || {};
    const rows = [];
    Object.keys(all).forEach(pid => {
      if(pid === gameState.playerId) return;
      const p = all[pid];
      const meta = p.meta || {};
      const pres = p.presence || {};
      const lastSeen = pres.lastSeen || 0;
      const online = (Date.now() - lastSeen) < 60_000; // consider online if seen in last minute
      const label = meta && meta.friends && meta.friends.includes(gameState.playerId) ? 'Friend' : 'Player';
      rows.push({ pid, online, label, meta });
    });
    // render
    playersPanel.innerHTML = '';
    if(rows.length === 0) { playersPanel.innerHTML = '<div class="small" style="text-align:center;color:#666">No players found</div>'; return; }
    rows.sort((a,b)=> (b.online?1:0)-(a.online?1:0));
    rows.forEach(r=>{
      const div = document.createElement('div'); div.className='player-row';
      div.innerHTML = `<div style="display:flex;gap:8px;align-items:center"><div style="width:10px;height:10px;border-radius:50%;background:${r.online?'#38a169':'#cbd5e0'}"></div><div><strong style="font-size:0.95rem">${r.pid}</strong><div class="small" style="color:#666">${r.label}</div></div></div><div style="display:flex;gap:6px"><button class="btn primary" data-invite="${r.pid}">Invite</button><button class="btn ghost" data-join="${r.pid}">Join</button></div>`;
      playersPanel.appendChild(div);
      div.querySelector('[data-invite]').addEventListener('click', ()=> invitePlayer(r.pid));
      div.querySelector('[data-join]').addEventListener('click', ()=> joinPlayerRoom(r.pid));
    });
  });
}

async function invitePlayer(pid) {
  // create a room and write an invite under players/{pid}/invites/{from}
  try {
    const rid = Math.random().toString(36).slice(2,10);
    await set(ref(db, `rooms/${rid}`), { createdAt:Date.now(), host:gameState.playerId });
    await set(ref(db, `players/${pid}/invites/${rid}`), { from:gameState.playerId, room:rid, ts:Date.now() });
    toast('Invite sent to ' + pid);
    // open room for host
    await connectToRoomAsCaller(rid);
  } catch(e){ toast('Invite failed'); console.warn(e); }
}

function listenForInvites() {
  if(!gameState.playerId) return;
  onValue(ref(db, `players/${gameState.playerId}/invites`), snapshot => {
    const invites = snapshot.val() || {};
    const keys = Object.keys(invites);
    if(keys.length === 0) return;
    // present first invite as modal
    const firstKey = keys[0]; const inv = invites[firstKey];
    const content = `<h3>Invite</h3><div class="row"><div class="small" style="color:#666">Player <strong>${inv.from}</strong> invited you to join room <strong>${inv.room}</strong></div></div><div style="text-align:right;margin-top:12px"><button class="btn ghost" data-close>Ignore</button><button class="btn primary" id="joinIt">Join</button></div>`;
    const modal = showModal(content);
    modal.modal.querySelector('#joinIt').addEventListener('click', async ()=> {
      modal.close();
      try { await connectToRoomAsCallee(inv.room); await remove(ref(db, `players/${gameState.playerId}/invites/${firstKey}`)); } catch(e){ toast('Failed to join invite'); }
    });
    // auto-clean invites older than an hour (best-effort)
  });
}

async function joinPlayerRoom(pid) {
  // attempt to read latest room hosted by pid
  try {
    const roomsSnap = await get(ref(db, 'rooms'));
    if(!roomsSnap.exists()) { toast('No active rooms'); return; }
    const rooms = roomsSnap.val();
    // find any room with host === pid and without answer
    for(const [rid, rdata] of Object.entries(rooms)) {
      if(rdata.host === pid) {
        const offerSnap = await get(child(ref(db), `rooms/${rid}/offer`));
        const answerSnap = await get(child(ref(db), `rooms/${rid}/answer`));
        if(offerSnap.exists() && !answerSnap.exists()) { await connectToRoomAsCallee(rid); return; }
      }
    }
    toast('No joinable room found for that player');
  } catch(e){ toast('Failed to query rooms'); console.warn(e); }
}

/* ---------- UI handlers wiring ---------- */
document.getElementById('btnSingle').addEventListener('click', startSinglePlayer);
document.getElementById('btnFriends').addEventListener('click', () => {
  const content = `<h3>Friends</h3><div class="row"><div class="small" style="color:#666">Add a friend by ID</div><input id="friendInput" class="input" placeholder="player-id" /></div><div style="text-align:right;margin-top:12px"><button class="btn ghost" data-close>Close</button><button class="btn primary" id="addFriendBtn">Add</button></div>`;
  const modal = showModal(content);
  modal.modal.querySelector('#addFriendBtn').addEventListener('click', ()=> {
    const v = modal.modal.querySelector('#friendInput').value.trim();
    if(v){ addFriend(v); toast('Friend added'); modal.close(); }
    else toast('Enter a valid id');
  });
});
document.getElementById('btnRecent').addEventListener('click', ()=> {
  const list = gameState.recentOpponents.length ? gameState.recentOpponents.join('\n') : '(none)';
  const content = `<h3>Recent</h3><div class="row"><pre style="white-space:pre-wrap;max-height:220px;overflow:auto">${list}</pre></div><div style="text-align:right;margin-top:12px"><button class="btn ghost" data-close>Close</button></div>`;
  showModal(content);
});
document.getElementById('btnLAN').addEventListener('click', ()=> {
  const content = `<h3>LAN</h3><div class="row"><div class="small" style="color:#666">Create or join a LAN room</div><div style="display:flex;gap:8px;margin-top:8px"><button class="btn primary" id="createLan">Create</button><button class="btn ghost" id="joinLan">Join</button></div></div><div style="text-align:right;margin-top:12px"><button class="btn ghost" data-close>Close</button></div>`;
  const modal = showModal(content);
  modal.modal.querySelector('#createLan').addEventListener('click', async ()=> { modal.close(); await createRoomAndWaitUI(); });
  modal.modal.querySelector('#joinLan').addEventListener('click', async ()=> { modal.close(); await joinRoomUI(); });
});
document.getElementById('btnRandom').addEventListener('click', ()=> { randomMatchUI(); });
document.getElementById('btnGlobal').addEventListener('click', ()=> {
  const content = `<h3>Global Match</h3><div class="row"><div class="small" style="color:#666">Create a room, join by ID, or see available players</div><div style="display:flex;gap:8px;margin-top:8px"><button class="btn primary" id="createGlobal">Create</button><button class="btn ghost" id="joinGlobal">Join by ID</button></div></div><div style="text-align:right;margin-top:12px"><button class="btn ghost" data-close>Close</button></div>`;
  const modal = showModal(content);
  modal.modal.querySelector('#createGlobal').addEventListener('click', async ()=> { modal.close(); await createRoomAndWaitUI(); });
  modal.modal.querySelector('#joinGlobal').addEventListener('click', async ()=> { modal.close(); await joinRoomUI(); });
});

/* ---------- game ui controls ---------- */
document.getElementById('autosaveBtn').addEventListener('click', ()=> { toggleAutoSave(); toast('Autosave ' + (gameState.autosave ? 'ON' : 'OFF')); });
document.getElementById('saveBtn').addEventListener('click', ()=> saveToSlotUI());
document.getElementById('savesBtn').addEventListener('click', ()=> loadFromSlotUI());
document.getElementById('exitNoSave').addEventListener('click', ()=> { document.getElementById('gameScreen').style.display='none'; document.getElementById('mainMenu').style.display='block'; if(gameLoopInterval) clearInterval(gameLoopInterval); toast('Exited to menu'); });

/* ---------- initialization ---------- */
// load meta from local
try {
  const meta = JSON.parse(localStorage.getItem(META_KEY) || '{}');
  if(meta && meta.playerId) gameState.playerId = meta.playerId;
  gameState.friends = (meta && meta.friends) || gameState.friends;
  gameState.recentOpponents = (meta && meta.recent) || gameState.recentOpponents;
} catch(e){}
// ensure id
if(!gameState.playerId){ gameState.playerId = generateId(); try{ localStorage.setItem(META_KEY, JSON.stringify({ playerId:gameState.playerId, friends:gameState.friends, recent:gameState.recentOpponents })); }catch(e){} }

// generate items & update UI later
generateItems();
updateAll();

/* ---------- presence + listeners ---------- */
writePresence();
listenForPlayers();
listenForInvites();

/* ---------- players watcher: keep presence heartbeat ---------- */
setInterval(()=> { writePresence(); }, 15_000);

/* ---------- Start single player function ---------- */
function startSinglePlayer() {
  document.getElementById('mainMenu').style.display='none'; document.getElementById('gameScreen').style.display='block';
  generateItems(); updateAll();
  if(gameLoopInterval) clearInterval(gameLoopInterval);
  gameLoopInterval = setInterval(gameLoop, 2000);
  setTimeout(()=> spawnCustomer(), 1000);
  pushMetaToFirebase();
}

/* ---------- exposes for console debugging (still available) ---------- */
window.gameState = gameState;
window.saveToSlot = saveToSlotUI;
window.loadFromSlot = loadFromSlot;
window.connectGlobal = createRoomAndWaitUI;
window.connectRandom = randomMatchUI;
window.connectLAN = createRoomAndWaitUI;

</script>
</body>
</html>
