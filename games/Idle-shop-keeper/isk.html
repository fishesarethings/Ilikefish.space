<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Idle Shop Keeper (Authoritative Rooms)</title>
<style>
/* Minimal UI changes only ‚Äî everything else preserved */
body{box-sizing:border-box;margin:0;padding:20px;font-family:'Segoe UI',sans-serif;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);min-height:100vh;color:#333}
.game-container{max-width:1200px;margin:0 auto;background:white;border-radius:20px;padding:30px;box-shadow:0 20px 40px rgba(0,0,0,0.1)}
.main-menu{text-align:center}
.subtitle{color:#666;font-size:1.2rem;margin:10px 0 40px 0}
.menu-options{max-width:680px;margin:0 auto}
.menu-btn{width:100%;background:white;border:2px solid #e2e8f0;border-radius:15px;padding:20px;margin-bottom:15px;cursor:pointer;transition:all .3s ease;display:flex;align-items:center;gap:20px;text-align:left}
.menu-btn:hover{border-color:#4299e1;transform:translateY(-2px);box-shadow:0 8px 25px rgba(66,153,225,.15)}
.single-player{background:linear-gradient(135deg,#48bb78,#38a169);color:white;border-color:#38a169}
.btn-icon{font-size:2.5rem;min-width:60px}
.btn-text h3{margin:0 0 5px;font-size:1.2rem}
.btn-text p{margin:0;color:#666;font-size:.9rem}
.player-code{font-size:.9rem;color:#2d3748;background:#f7fafc;padding:6px 8px;border-radius:8px;border:1px solid #e2e8f0;display:inline-block;margin-left:8px}
.copy-btn{margin-left:8px;padding:6px 8px;border-radius:8px;border:none;cursor:pointer;background:#4299e1;color:white}
.players-panel{margin-top:12px;padding:12px;border-radius:10px;border:1px solid #e2e8f0;background:#fbfcff;max-height:220px;overflow:auto}
.player-row{display:flex;justify-content:space-between;align-items:center;padding:6px 8px;border-bottom:1px dashed #e2e8f0}
.player-row:last-child{border-bottom:none}
.status-dot{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px}
.status-online{background:#38a169}.status-off{background:#cbd5e0}
.small{font-size:.85rem;color:#555}
.modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.45);display:flex;align-items:center;justify-content:center;z-index:3000}
.modal{background:white;padding:18px;border-radius:12px;width:380px;max-width:94%;box-shadow:0 8px 40px rgba(0,0,0,0.25)}
.input{width:100%;padding:8px 10px;border-radius:8px;border:1px solid #e2e8f0}
.btn{padding:8px 12px;border-radius:8px;border:none;cursor:pointer}
.btn.primary{background:#4299e1;color:white}
.btn.ghost{background:#e2e8f0;color:#2d3748}
#toastArea{position:fixed;right:18px;bottom:18px;display:flex;flex-direction:column;gap:8px;z-index:4000}
.toast{background:#2d3748;color:white;padding:8px 12px;border-radius:8px;opacity:0.95;min-width:160px}
#signalStatus{position:fixed;right:18px;top:18px;z-index:4500;display:flex;align-items:center;gap:8px;background:rgba(255,255,255,0.9);padding:6px;border-radius:8px;border:1px solid #e2e8f0}
.signal-bars{display:flex;gap:2px;align-items:flex-end;height:18px}
.signal-bars span{display:block;width:4px;background:#cbd5e0;border-radius:1px}
.signal-bars span.on{background:#38a169}
.ping-num{font-size:0.85rem;color:#333}
.rooms-list{margin-top:10px;max-height:160px;overflow:auto;border:1px solid #e2e8f0;padding:8px;border-radius:8px;background:#fff}
.room-row{display:flex;justify-content:space-between;align-items:center;padding:6px;border-bottom:1px dashed #eee}
.room-row:last-child{border-bottom:none}
@media(max-width:768px){.menu-options{padding:0 12px}}
</style>
</head>
<body>
<div class="game-container">
  <div id="mainMenu" class="main-menu">
    <div class="header">
      <h1>üè™ Idle Shop Keeper</h1>
      <p class="subtitle">Build your retail empire!</p>
      <div style="margin-top:12px">
        <span class="small">Your player code:</span>
        <span id="playerCode" class="player-code">‚Äî</span>
        <button id="copyPlayerCode" class="copy-btn">Copy</button>
      </div>
    </div>

    <div class="menu-options">
      <button class="menu-btn single-player" id="btnSingle">
        <div class="btn-icon">üéÆ</div>
        <div class="btn-text"><h3>Single Player</h3><p>Play solo and build your shop</p></div>
      </button>

      <div style="margin:10px 0;text-align:left">
        <strong>Friends & Recent</strong>
        <div style="display:flex;gap:10px;margin-top:8px;justify-content:center">
          <button id="btnFriends" class="menu-btn multiplayer">üë• Friends</button>
          <button id="btnRecent" class="menu-btn multiplayer">üïò Recent</button>
        </div>
      </div>

      <div class="multiplayer-section">
        <h2>üåê Multiplayer Options</h2>

        <div style="display:flex;gap:10px;margin-bottom:8px">
          <button class="menu-btn multiplayer" id="btnLAN"><div class="btn-icon">üè†</div><div class="btn-text"><h3>Local Network</h3><p>Create LAN room</p></div></button>
          <button class="menu-btn multiplayer" id="btnGlobal"><div class="btn-icon">üåç</div><div class="btn-text"><h3>Rooms</h3><p>Create / Join room</p></div></button>
        </div>

        <button class="menu-btn multiplayer" id="btnRandom"><div class="btn-icon">üé≤</div><div class="btn-text"><h3>Random Match</h3><p>Find an open room</p></div></button>

        <div style="margin-top:12px">
          <h4 style="margin:8px 0 6px 0">Available Players (online)</h4>
          <div id="playersPanel" class="players-panel"><div class="small" style="color:#666;text-align:center">Loading players...</div></div>
        </div>

        <div style="margin-top:12px">
          <h4 style="margin:8px 0 6px 0">Open Rooms</h4>
          <div id="roomsPanel" class="rooms-list"><div class="small" style="color:#666;text-align:center">Loading rooms...</div></div>
        </div>

      </div>
    </div>
  </div>

  <!-- Game Screen (simple) -->
  <div id="gameScreen" style="display:none">
    <div class="header"><h1>üè™ Idle Shop Keeper</h1></div>

    <div class="stats" style="display:flex;gap:12px;flex-wrap:wrap">
      <div class="stat-card" style="flex:1;min-width:180px"><h3>üí∞ Money</h3><p id="money" class="stat-value">$100</p></div>
      <div class="stat-card" style="flex:1;min-width:180px"><h3>üë• Customers Served</h3><p id="customersServed" class="stat-value">0</p></div>
      <div class="stat-card" style="flex:1;min-width:180px"><h3>‚≠ê Shop Level</h3><p id="shopLevel" class="stat-value">1</p></div>
    </div>

    <div style="margin-top:16px;display:flex;gap:8px;flex-wrap:wrap">
      <button id="saveBtn" class="btn primary">Save</button>
      <button id="savesBtn" class="btn ghost">Saves</button>
      <button id="exportBtn" class="btn primary">Export</button>
      <input id="importFile" type="file" accept=".json" style="display:none" />
      <button id="importBtn" class="btn ghost">Import</button>
      <button id="backBtn" class="btn ghost">Back to Menu</button>
    </div>
  </div>
</div>

<div id="modalRoot" style="position:fixed;inset:0;pointer-events:none;z-index:3500"></div>
<div id="toastArea"></div>

<!-- ping & signal overlay -->
<div id="signalStatus" style="display:none">
  <div class="signal-bars" id="signalBars">
    <span></span><span></span><span></span><span></span><span></span>
  </div>
  <div class="ping-num" id="pingNum">-- ms</div>
</div>

<script type="module">
/* ====== Authoritative multiplayer + TTL sweeper + ping + minimal UI wiring ====== */

/* Firebase imports */
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-app.js";
import { getDatabase, ref, set, push, onValue, onChildAdded, child, get, remove, update, onDisconnect, query, orderByChild } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-database.js";
import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-auth.js";

/* ---------- Config (replace with your own if needed) ---------- */
const firebaseConfig = {
  apiKey: "AIzaSyBn4khIpi57YvqQX2urCup2mCvpVUZ0j8k",
  authDomain: "idle-shop-keeper.firebaseapp.com",
  databaseURL: "https://idle-shop-keeper-default-rtdb.firebaseio.com",
  projectId: "idle-shop-keeper",
  storageBucket: "idle-shop-keeper.firebasestorage.app",
  messagingSenderId: "117380146729",
  appId: "1:117380146729:web:8180d507d5a2aae45e5e38",
  measurementId: "G-VS2Z5T0Y9Y"
};
const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const auth = getAuth(app);

/* ---------- UI helpers ---------- */
const modalRoot = document.getElementById('modalRoot');
function showModal(html, opts = {}) {
  const backdrop = document.createElement('div'); backdrop.className = 'modal-backdrop'; backdrop.style.pointerEvents = 'auto';
  const box = document.createElement('div'); box.className = 'modal'; box.innerHTML = html;
  backdrop.appendChild(box); modalRoot.appendChild(backdrop);
  const close = () => { try { backdrop.remove(); } catch(e) {} if (opts.onClose) opts.onClose(); };
  box.querySelectorAll('[data-close]').forEach(el => el.addEventListener('click', close));
  return { box, close };
}
function toast(msg, t=3000) {
  const area = document.getElementById('toastArea');
  const el = document.createElement('div'); el.className='toast'; el.textContent = msg;
  area.appendChild(el);
  setTimeout(()=> el.style.opacity='0', t-350);
  setTimeout(()=> { try{ el.remove(); }catch(e){} }, t);
}

/* ---------- keys & helpers ---------- */
const STORAGE_KEY = 'idle_shop_saves_v1';
const META_KEY = 'idle_shop_meta_v1';
function safeParse(s, fb={}){ try { return JSON.parse(s); } catch(e) { return fb; } }
function generateId(){ return (crypto && crypto.randomUUID) ? 'p-'+crypto.randomUUID() : 'p-'+Math.random().toString(36).slice(2,10); }

/* ---------- base game data (kept minimal) ---------- */
let gameState = {
  money: 100, customersServed: 0, shopLevel: 1,
  inventory: {}, upgrades:{autoCustomer:0,fasterService:0,betterPrices:0,moreCustomers:0},
  customers: [], workers:{manager:{level:0,assigned:'idle'},restocker:{level:0,assigned:'idle'},server:{level:0,assigned:'idle'}},
  playerId: null, unlockedCount:6, friends:[], recentOpponents:[], autosave:true,
  currentRoom: null, isHost: false
};

const TOTAL_ITEMS = 5000, items = {};
function generateItems(){
  const base = [
    {key:'apple',emoji:'üçé',name:'Apple',buyPrice:5,sellPrice:8},
    {key:'bread',emoji:'üçû',name:'Bread',buyPrice:8,sellPrice:12},
    {key:'milk',emoji:'ü•õ',name:'Milk',buyPrice:12,sellPrice:18},
    {key:'candy',emoji:'üç¨',name:'Candy',buyPrice:15,sellPrice:25},
    {key:'coffee',emoji:'‚òï',name:'Coffee',buyPrice:20,sellPrice:35},
    {key:'cake',emoji:'üéÇ',name:'Cake',buyPrice:30,sellPrice:50}
  ];
  base.forEach(it => { items[it.key]=it; gameState.inventory[it.key] = gameState.inventory[it.key] || 0; });
  for(let i=base.length+1;i<=TOTAL_ITEMS;i++){
    const key='item_'+i; const buy=5+Math.floor(i*0.8); const sell=Math.floor(buy*1.6);
    items[key]={emoji:'üéÅ',name:'Item '+i,buyPrice:buy,sellPrice:sell}; gameState.inventory[key]=gameState.inventory[key]||0;
  }
}

/* ---------- UI update ---------- */
function updateStats(){
  document.getElementById('money').textContent='$'+gameState.money;
  document.getElementById('customersServed').textContent=gameState.customersServed;
  document.getElementById('shopLevel').textContent=gameState.shopLevel;
  document.getElementById('playerCode').textContent=gameState.playerId || '‚Äî';
}
function updateAllUI(){ updateStats(); }

/* ---------- save helpers ---------- */
function getLocalSaves(){ return safeParse(localStorage.getItem(STORAGE_KEY), {}); }
function setLocalSaves(s){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(s)); }catch(e){} }

async function saveSlot(slotName){
  const name = slotName || ('save-'+new Date().toISOString().slice(0,19).replace(/[:T]/g,'-'));
  const saves = getLocalSaves(); saves[name] = { state: JSON.parse(JSON.stringify(gameState)), ts:Date.now() }; setLocalSaves(saves);
  try { if(gameState.playerId) await set(ref(db, `players/${gameState.playerId}/saves/${name}`), saves[name]); toast('Saved: '+name); } catch(e){ toast('Saved locally (server failed)'); }
}
async function loadSlot(name){
  const saves = getLocalSaves();
  if(saves[name]){ gameState = JSON.parse(JSON.stringify(saves[name].state)); postLoadRestore(); toast('Loaded: '+name); return; }
  try { if(gameState.playerId){ const snap = await get(ref(db, `players/${gameState.playerId}/saves/${name}`)); if(snap.exists()){ const payload = snap.val(); gameState = JSON.parse(JSON.stringify(payload.state)); postLoadRestore(); toast('Loaded from server: '+name); return; } } } catch(e){}
  toast('Save not found: '+name);
}
function postLoadRestore(){ generateItems(); updateAllUI(); }

function quickSave(){
  try{
    const saves = getLocalSaves(); const key = 'quick_'+gameState.playerId;
    saves[key] = { state: JSON.parse(JSON.stringify(gameState)), ts:Date.now() }; setLocalSaves(saves);
    if(gameState.playerId) set(ref(db, `players/${gameState.playerId}/saves/${key}`), saves[key]).catch(()=>{});
  }catch(e){}
}

/* ---------- export/import ---------- */
function exportSaveFile() {
  const payload = { savedAt: Date.now(), playerId: gameState.playerId, state: gameState };
  const data = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(payload, null, 2));
  const a = document.createElement('a'); a.href=data; a.download=`idle-shop-${gameState.playerId||'anon'}-${new Date().toISOString().slice(0,19)}.json`; document.body.appendChild(a); a.click(); a.remove();
  toast('Export started');
}
function importSaveFile(file){
  if(!file){ toast('No file'); return; }
  const r = new FileReader();
  r.onload = (e) => {
    try {
      const p = JSON.parse(e.target.result);
      if(!p || !p.state){ toast('Invalid file'); return; }
      gameState = p.state; postLoadRestore();
      const saves = getLocalSaves(); const key = 'import_'+(p.playerId||'import')+'_'+Date.now(); saves[key] = { state: JSON.parse(JSON.stringify(gameState)), ts:Date.now() }; setLocalSaves(saves);
      if(gameState.playerId) set(ref(db, `players/${gameState.playerId}/saves/${key}`), saves[key]).catch(()=>{});
      toast('Imported');
    } catch(e){ console.warn(e); toast('Import failed'); }
  };
  r.readAsText(file);
}

/* ---------- presence & players list ---------- */
async function writePresence() {
  if(!gameState.playerId) return;
  try {
    const pRef = ref(db, `players/${gameState.playerId}/presence`);
    await set(pRef, { lastSeen: Date.now(), playerId: gameState.playerId });
    try { await onDisconnect(pRef).remove(); } catch(e){}
  } catch(e) { console.warn('presence write failed', e); }
}

/* render players */
function renderPlayersPanel(allPlayers){
  const panel = document.getElementById('playersPanel'); panel.innerHTML = '';
  const rows = [];
  Object.keys(allPlayers || {}).forEach(pid => {
    if(pid === gameState.playerId) return;
    const p = allPlayers[pid];
    const pres = p.presence || {};
    const last = pres.lastSeen || 0;
    const online = (Date.now() - last) < 60000;
    rows.push({ pid, online, meta: p.meta || {} });
  });
  if(rows.length === 0){ panel.innerHTML = '<div class="small" style="text-align:center;color:#666">No players found</div>'; return; }
  rows.sort((a,b) => (b.online?1:0) - (a.online?1:0));
  rows.forEach(r => {
    const div = document.createElement('div'); div.className='player-row';
    const left = document.createElement('div'); left.style.display='flex'; left.style.alignItems='center';
    const dot = document.createElement('span'); dot.className = 'status-dot ' + (r.online ? 'status-online' : 'status-off'); left.appendChild(dot);
    const name = document.createElement('div'); name.innerHTML = `<strong style="margin-left:8px">${r.pid}</strong><div class="small" style="color:#666">${r.online ? 'Online' : 'Offline'}</div>`; left.appendChild(name);
    const right = document.createElement('div'); right.style.display='flex'; right.style.gap='6px';
    const inviteBtn = document.createElement('button'); inviteBtn.className='btn primary'; inviteBtn.textContent='Invite'; inviteBtn.onclick = ()=> invitePlayer(r.pid);
    const joinBtn = document.createElement('button'); joinBtn.className='btn ghost'; joinBtn.textContent='Join Room'; joinBtn.onclick = ()=> tryJoinPlayerRoom(r.pid);
    right.appendChild(inviteBtn); right.appendChild(joinBtn);
    div.appendChild(left); div.appendChild(right);
    panel.appendChild(div);
  });
}

/* listen players live */
onValue(ref(db, 'players'), snapshot => {
  const all = snapshot.val() || {};
  renderPlayersPanel(all);
});

/* ---------- rooms listing & TTL sweeper ---------- */
const ROOM_TTL_MS = 30 * 60 * 1000; // 30 minutes
const ROOM_SWEEPER_INTERVAL = 60 * 1000; // 60s
let sweeperId = null;

async function refreshRoomsPanel() {
  try {
    const roomsSnap = await get(ref(db, 'rooms'));
    const rooms = roomsSnap.exists() ? roomsSnap.val() : {};
    const panel = document.getElementById('roomsPanel'); panel.innerHTML = '';
    const keys = Object.keys(rooms);
    if(keys.length === 0){ panel.innerHTML = '<div class="small" style="text-align:center;color:#666">No rooms</div>'; return; }
    keys.forEach(rid => {
      const rm = rooms[rid];
      const row = document.createElement('div'); row.className = 'room-row';
      row.innerHTML = `<div><strong>${rid}</strong><div class="small" style="color:#666">${rm.host||'unknown'} ‚Ä¢ ${rm.createdAt ? new Date(rm.createdAt).toLocaleString() : ''}</div></div>`;
      const actions = document.createElement('div'); actions.style.display='flex'; actions.style.gap='6px';
      const join = document.createElement('button'); join.className='btn primary'; join.textContent='Join'; join.onclick = ()=> joinRoomById(rid);
      const watch = document.createElement('button'); watch.className='btn ghost'; watch.textContent='Watch'; watch.onclick = ()=> subscribeRoomState(rid);
      actions.appendChild(join); actions.appendChild(watch);
      row.appendChild(actions);
      panel.appendChild(row);
    });
  } catch(e) {
    console.warn('refreshRoomsPanel failed', e);
    document.getElementById('roomsPanel').innerHTML = '<div class="small" style="color:#666">Rooms unavailable</div>';
  }
}

/* small function to try removing stale rooms ‚Äî only runs when this client is elected sweeper */
async function runRoomSweeperOnce() {
  if(!gameState.playerId) return;
  try {
    const playersSnap = await get(ref(db, 'players'));
    const players = playersSnap.exists() ? playersSnap.val() : {};
    const playerKeys = Object.keys(players).sort();
    if(playerKeys.length === 0) return;
    const elected = playerKeys[0]; // lexicographically smallest playerId is sweeper
    if(elected !== gameState.playerId) return; // only elected sweeper runs cleanup
    const roomsSnap = await get(ref(db, 'rooms'));
    if(!roomsSnap.exists()) return;
    const rooms = roomsSnap.val();
    const now = Date.now();
    for(const rid in rooms) {
      try {
        const rm = rooms[rid];
        const created = rm.createdAt || 0;
        if(now - created > ROOM_TTL_MS) {
          // attempt to remove stale room
          await remove(ref(db, `rooms/${rid}`)).catch(()=>{});
        }
      } catch(e) { /* ignore per-room errors */ }
    }
  } catch(e) { console.warn('sweeper error', e); }
}

/* start periodic sweeper */
setInterval(()=> {
  runRoomSweeperOnce().catch(()=>{});
  refreshRoomsPanel();
}, ROOM_SWEEPER_INTERVAL);

/* ---------- invitations & rooms ---------- */
async function invitePlayer(pid) {
  if(!gameState.playerId) { toast('No player ID'); return; }
  const rid = Math.random().toString(36).slice(2,10);
  try {
    await set(ref(db, `rooms/${rid}`), { createdAt: Date.now(), host: gameState.playerId, authoritative:true });
    await set(ref(db, `players/${pid}/invites/${rid}`), { from: gameState.playerId, room:rid, ts:Date.now() });
    toast('Invite sent');
    showRoomCreatedModal(rid);
    // automatically host authoritative room for invite
    hostAuthoritativeRoom(rid);
  } catch(e) { console.warn(e); toast('Invite failed (permission?)'); }
}

async function tryJoinPlayerRoom(pid) {
  try {
    const roomsSnap = await get(ref(db, 'rooms'));
    if(!roomsSnap.exists()){ toast('No active rooms'); return; }
    const rooms = roomsSnap.val();
    for(const rid in rooms) {
      if(rooms[rid].host === pid) {
        const m = showModal(`<h3>Join Room</h3><div style="margin-top:8px">Join room <strong>${rid}</strong> hosted by ${pid}?</div><div style="text-align:right;margin-top:10px"><button class="btn ghost" data-close>Cancel</button><button id="confirmJoin" class="btn primary">Join</button></div>`);
        m.box.querySelector('#confirmJoin').addEventListener('click', async ()=> { m.close(); await joinRoomById(rid); });
        return;
      }
    }
    toast('No room found for that player');
  } catch(e) { console.warn(e); toast('Failed to query rooms'); }
}

function showRoomCreatedModal(rid){
  showModal(`<h3>Room Created</h3><div style="margin-top:8px"><div class="small" style="color:#666">Share this room ID:</div><div style="margin-top:8px;padding:8px;border-radius:8px;background:#f7fafc;border:1px solid #e2e8f0;text-align:center;font-weight:bold">${rid}</div></div><div style="text-align:right;margin-top:10px"><button class="btn ghost" data-close>Close</button></div>`);
}

/* ---------- authoritative room implementation (host acts as server) ---------- */
let roomActionListenerUnsub = null;
let roomStateListenerUnsub = null;
let roomHostTickInterval = null;

async function hostAuthoritativeRoom(rid) {
  gameState.currentRoom = rid;
  gameState.isHost = true;
  // set initial state in DB under rooms/{rid}/state
  try {
    const initState = { money: gameState.money, customersServed: gameState.customersServed, shopLevel: gameState.shopLevel, inventory: {} };
    Object.keys(gameState.inventory).slice(0,50).forEach(k => initState.inventory[k] = gameState.inventory[k]); // small snapshot
    await set(ref(db, `rooms/${rid}/meta`), { host: gameState.playerId, createdAt: Date.now(), authoritative:true }).catch(()=>{});
    await set(ref(db, `rooms/${rid}/state`), initState).catch(()=>{});
    // set onDisconnect cleanup for the room (host)
    try { await onDisconnect(ref(db, `rooms/${rid}`)).remove(); } catch(e){}
    // listen for actions
    const actionsRef = ref(db, `rooms/${rid}/actions`);
    // process each incoming action once
    roomActionListenerUnsub = onChildAdded(actionsRef, async (snap) => {
      const action = snap.val(); const actionKey = snap.key;
      if(!action) return;
      try {
        await processRoomActionAsHost(rid, action, actionKey);
      } catch(e) { console.warn('process action failed', e); }
    });
    // host tick: can periodically push authoritative state to DB
    roomHostTickInterval = setInterval(async ()=> {
      try {
        // optionally do room-side automation (spawn customers, worker ticks) ‚Äî simple example: increment money slowly
        // Here we only re-write authoritative state so clients stay up-to-date
        const stateSnapshot = await get(ref(db, `rooms/${rid}/state`)); // read current authoritative
        if(stateSnapshot.exists()){
          // ensure host local copy kept in sync with db snapshot
          // (host should be authoritative origin of state changes; skip merging here)
        }
      } catch(e){}
    }, 2000);
    toast('Hosting authoritative room: ' + rid);
  } catch(e) { console.warn('hostAuthoritativeRoom failed', e); toast('Failed to host room (permission?)'); }
}

/* host processes actions */
async function processRoomActionAsHost(rid, action, actionKey) {
  // basic action types: serve, buy, requestSync
  // load current authoritative
  const stateRef = ref(db, `rooms/${rid}/state`);
  const snap = await get(stateRef);
  if(!snap.exists()) { console.warn('no state for room', rid); return; }
  const state = snap.val();
  if(action.type === 'serve') {
    const idx = action.customerIndex;
    const want = action.want;
    if(!want) return;
    const stock = (state.inventory && state.inventory[want]) || 0;
    if(stock > 0) {
      state.inventory[want] = stock - 1;
      state.money = (state.money || 0) + (items[want] ? items[want].sellPrice : 0);
      state.customersServed = (state.customersServed||0) + 1;
    }
  } else if(action.type === 'buy') {
    const want = action.itemKey;
    const buyPrice = items[want] ? items[want].buyPrice : 0;
    if((state.money || 0) >= buyPrice) {
      state.money = (state.money || 0) - buyPrice;
      state.inventory = state.inventory || {};
      state.inventory[want] = (state.inventory[want]||0) + 1;
    }
  } else if(action.type === 'requestSync') {
    // no-op; host will push state below
  }
  // write updated state and remove action
  try {
    await set(stateRef, state);
    await remove(ref(db, `rooms/${rid}/actions/${actionKey}`)).catch(()=>{});
  } catch(e) { console.warn('write state or remove action failed', e); }
}

/* client: subscribe to room state & actions */
let currentRoomStateUnsub = null;
async function subscribeRoomState(rid) {
  // subscribe to state updates
  try {
    const stateRef = ref(db, `rooms/${rid}/state`);
    // onValue listening
    if(currentRoomStateUnsub) { currentRoomStateUnsub(); currentRoomStateUnsub = null; }
    currentRoomStateUnsub = onValue(stateRef, snap => {
      const val = snap.val();
      if(val) {
        // apply authoritative snapshot to local gameState (careful)
        gameState.money = val.money || gameState.money;
        gameState.customersServed = val.customersServed || gameState.customersServed;
        gameState.shopLevel = val.shopLevel || gameState.shopLevel;
        // merge inventory keys (small subset)
        if(val.inventory) {
          Object.keys(val.inventory).forEach(k => gameState.inventory[k] = val.inventory[k]);
        }
        updateAllUI();
      }
    });
    toast('Subscribed to room state: ' + rid);
  } catch(e) { console.warn('subscribeRoomState failed', e); toast('Subscribe failed'); }
}

/* join authoritative room by id */
async function joinRoomById(rid) {
  try {
    // if room has authoritative flag, treat as server room; otherwise use p2p fallback
    const metaSnap = await get(ref(db, `rooms/${rid}/meta`));
    const meta = metaSnap.exists() ? metaSnap.val() : null;
    if(meta && meta.authoritative) {
      // join authoritative mode: listen for state and post actions under rooms/{rid}/actions
      gameState.currentRoom = rid;
      gameState.isHost = false;
      // subscribe to authoritative state
      await subscribeRoomState(rid);
      toast('Joined authoritative room: '+rid);
    } else {
      // non-authoritative / legacy: attempt p2p (kept minimal)
      toast('This room is non-authoritative or missing: attempting p2p join (legacy)');
      // For p2p: call joinRoomByIdWebRTC (not implemented here) or joinRoomById() above
      // fallback behavior: simply subscribe to room state if exists
      await subscribeRoomState(rid);
    }
  } catch(e) { console.warn(e); toast('Join failed (permission?)'); }
}

/* clients send actions to authoritative host */
async function sendRoomAction(action) {
  if(!gameState.currentRoom) { toast('Not in a room'); return; }
  const actionsRef = ref(db, `rooms/${gameState.currentRoom}/actions`);
  try {
    await push(actionsRef, Object.assign({ from: gameState.playerId, ts: Date.now() }, action));
  } catch(e) { console.warn('send action failed', e); toast('Action failed (permission?)'); }
}

/* ---------- minimal client-side buy/serve adapt to authoritative rooms ---------- */
function buyItemLocal(key) {
  if(gameState.currentRoom && !gameState.isHost) {
    // send buy action
    sendRoomAction({ type:'buy', itemKey: key });
    toast('Buy request sent to host');
    return;
  }
  // local single-player or host: apply locally and if host also update room state
  const it = items[key];
  if(!it) return;
  if(gameState.money >= it.buyPrice) {
    gameState.money -= it.buyPrice;
    gameState.inventory[key] = (gameState.inventory[key] || 0) + 1;
    updateAllUI();
    if(gameState.currentRoom && gameState.isHost) {
      // host writes authoritative state
      const stateRef = ref(db, `rooms/${gameState.currentRoom}/state`);
      const small = { money: gameState.money, customersServed: gameState.customersServed, shopLevel: gameState.shopLevel, inventory: {} };
      Object.keys(gameState.inventory).slice(0,50).forEach(k=> small.inventory[k] = gameState.inventory[k]);
      set(stateRef, small).catch(()=>{});
    }
  } else {
    toast('Not enough money');
  }
}
function serveCustomerLocal(index, want) {
  if(gameState.currentRoom && !gameState.isHost) {
    // send serve action
    sendRoomAction({ type:'serve', customerIndex: index, want });
    toast('Serve request sent to host');
    return;
  }
  // local or host apply directly
  if((gameState.inventory[want]||0) > 0) {
    gameState.inventory[want]--;
    const earnings = items[want] ? items[want].sellPrice : 0;
    gameState.money += earnings;
    gameState.customersServed++;
    if(gameState.customersServed % 10 === 0) { gameState.shopLevel++; gameState.unlockedCount = Math.min(TOTAL_ITEMS, gameState.unlockedCount + 10); }
    updateAllUI();
    if(gameState.currentRoom && gameState.isHost) {
      const stateRef = ref(db, `rooms/${gameState.currentRoom}/state`);
      const small = { money: gameState.money, customersServed: gameState.customersServed, shopLevel: gameState.shopLevel, inventory: {} };
      Object.keys(gameState.inventory).slice(0,50).forEach(k=> small.inventory[k] = gameState.inventory[k]);
      set(stateRef, small).catch(()=>{});
    }
  } else {
    toast('No stock');
  }
}

/* ---------- WebRTC p2p (kept minimal; original code earlier used Firebase signaling) ---------- */
/* Note: full WebRTC handshake code left minimal since authoritative mode preferred; ping uses dataChannel when available */
let pc = null, dataChannel = null;
function createPeerConnectionForPing() {
  if(pc) return pc;
  pc = new RTCPeerConnection({ iceServers:[{urls:'stun:stun.l.google.com:19302'}] });
  pc.ondatachannel = (ev)=> {
    dataChannel = ev.channel; setupDataChannelPing();
  };
  pc.onconnectionstatechange = ()=> { if(pc.connectionState === 'connected'){ toast('P2P connected'); } };
  return pc;
}
function setupDataChannelPing(){
  if(!dataChannel) return;
  dataChannel.onmessage = (ev)=> {
    try{
      const msg = JSON.parse(ev.data);
      if(msg.type === 'ping-echo' && msg.nonce && pingTracker[msg.nonce]) {
        const sent = pingTracker[msg.nonce];
        const rtt = Date.now() - sent;
        updatePingUI(rtt);
        delete pingTracker[msg.nonce];
      } else if(msg.type === 'ping' && msg.nonce) {
        // echo back
        dataChannel.send(JSON.stringify({ type:'ping-echo', nonce: msg.nonce }));
      }
    }catch(e){}
  };
}
const pingTracker = {};
function sendPingOverDC() {
  if(!dataChannel || dataChannel.readyState !== 'open') return;
  const nonce = Math.random().toString(36).slice(2,9);
  pingTracker[nonce] = Date.now();
  dataChannel.send(JSON.stringify({ type:'ping', nonce }));
  // timeout if no response
  setTimeout(()=> { if(pingTracker[nonce]) { updatePingUI(null); delete pingTracker[nonce]; } }, 5000);
}

/* ---------- ping UI ---------- */
function updatePingUI(rtt) {
  const el = document.getElementById('signalStatus');
  const bars = document.querySelectorAll('#signalBars span');
  if(rtt === null || rtt === undefined) {
    el.style.display = 'flex';
    document.getElementById('pingNum').textContent = '-- ms';
    bars.forEach(s => s.classList.remove('on'));
    return;
  }
  document.getElementById('pingNum').textContent = rtt + ' ms';
  // thresholds: <80ms = 5, <150 =4, <300=3, <600=2, else 1
  let n = 1;
  if(rtt < 80) n = 5;
  else if(rtt < 150) n = 4;
  else if(rtt < 300) n = 3;
  else if(rtt < 600) n = 2;
  else n = 1;
  bars.forEach((s,i)=> {
    if(i < n) s.classList.add('on'); else s.classList.remove('on');
  });
  el.style.display = 'flex';
}

/* periodic ping attempt (uses dataChannel when connected) */
setInterval(()=> {
  try { sendPingOverDC(); } catch(e){}
}, 4000);

/* ---------- room presence & invites handling ---------- */
onValue(ref(db, 'players'), snapshot => {
  const all = snapshot.val() || {};
  renderPlayersPanel(all);
  refreshRoomsPanel();
});

/* listen for invites to me and pop modal to accept */
onValue(ref(db, 'players'), snapshot => {
  const all = snapshot.val() || {};
  const me = all[gameState.playerId] || {};
  const invites = me.invites || {};
  const keys = Object.keys(invites);
  if(keys.length > 0) {
    const id = keys[0]; const inv = invites[id];
    if(inv && inv.room) {
      const content = `<h3>Invite</h3><div style="margin-top:8px">Player <strong>${inv.from}</strong> invited you to room <strong>${inv.room}</strong></div><div style="text-align:right;margin-top:10px"><button class="btn ghost" data-close>Ignore</button><button id="acceptInvite" class="btn primary">Join</button></div>`;
      const m = showModal(content);
      m.box.querySelector('#acceptInvite').addEventListener('click', async ()=> {
        m.close();
        await remove(ref(db, `players/${gameState.playerId}/invites/${id}`)).catch(()=>{});
        await joinRoomById(inv.room);
      });
    }
  }
});

/* ---------- onDisconnect cleaning for presence + host rooms already attempted when creating room (onDisconnect set) ---------- */
async function ensurePlayerNode() {
  if(!gameState.playerId) return;
  try {
    await set(ref(db, `players/${gameState.playerId}/meta`), { friends: gameState.friends, lastSeen: Date.now() });
    await set(ref(db, `players/${gameState.playerId}/presence`), { lastSeen: Date.now(), playerId: gameState.playerId });
    try { await onDisconnect(ref(db, `players/${gameState.playerId}/presence`)).remove(); } catch(e){}
  } catch(e) { console.warn('ensurePlayerNode failed', e); }
}

/* ---------- startSinglePlayer (was missing earlier) ---------- */
let gameLoopInterval = null;
function startSinglePlayer() {
  document.getElementById('mainMenu').style.display = 'none';
  document.getElementById('gameScreen').style.display = 'block';
  generateItems(); updateAllUI();
  if(gameLoopInterval) clearInterval(gameLoopInterval);
  gameLoopInterval = setInterval(gameLoop, 2000);
  setTimeout(() => spawnCustomerLocal(), 1000);
  writePresence();
  ensurePlayerNode();
  toast('Single player started');
}

/* spawn customer local function for demo */
const customerTypes = [
  {emoji:'üë®', wants:['apple','bread']},
  {emoji:'üë©', wants:['milk','coffee']},
  {emoji:'üë¶', wants:['candy','cake']},
  {emoji:'üëß', wants:['apple','candy']},
  {emoji:'üßì', wants:['bread','milk']},
  {emoji:'üë¥', wants:['coffee','cake']}
];
function spawnCustomerLocal(){
  const maxCustomers = 3 + (gameState.upgrades.moreCustomers||0);
  if(gameState.customers.length < maxCustomers) {
    const ct = customerTypes[Math.floor(Math.random()*customerTypes.length)];
    const want = ct.wants[Math.floor(Math.random()*ct.wants.length)];
    gameState.customers.push({ emoji: ct.emoji, wants: want });
  }
}

/* game loop minimal */
function workerTickLocal(){
  // restocker / server automation could be added here
}
function gameLoop() {
  if(gameState.upgrades.autoCustomer > 0 && Math.random() < 0.3 + (gameState.upgrades.autoCustomer * 0.1)) spawnCustomerLocal();
  if(Math.random() < 0.1 + (gameState.shopLevel * 0.02)) spawnCustomerLocal();
  workerTickLocal();
  if(gameState.autosave) quickSave();
}

/* ---------- wiring UI elements (minimal changes) ---------- */
document.getElementById('btnSingle').addEventListener('click', startSinglePlayer);
document.getElementById('btnFriends').addEventListener('click', ()=> { showFriendsDialog(); });
document.getElementById('btnRecent').addEventListener('click', ()=> { showRecentDialog(); });
document.getElementById('btnLAN').addEventListener('click', async ()=> {
  // create authoritative room and host it (LAN label only)
  const rid = Math.random().toString(36).slice(2,10);
  try {
    await set(ref(db, `rooms/${rid}`), { createdAt: Date.now(), host: gameState.playerId, authoritative:true, lan:true });
    hostAuthoritativeRoom(rid);
    showRoomCreatedModal(rid);
  } catch(e) { console.warn(e); toast('Create room failed'); }
});
document.getElementById('btnGlobal').addEventListener('click', ()=> {
  const content = `<h3>Rooms</h3><div style="margin-top:8px"><button id="createRoomBtn" class="btn primary">Create Room</button><button id="joinRoomBtn" class="btn ghost" style="margin-left:8px">Join by ID</button></div><div style="text-align:right;margin-top:10px"><button class="btn ghost" data-close>Close</button></div>`;
  const m = showModal(content);
  m.box.querySelector('#createRoomBtn').addEventListener('click', async ()=> {
    m.close();
    const rid = Math.random().toString(36).slice(2,10);
    try {
      await set(ref(db, `rooms/${rid}`), { createdAt: Date.now(), host: gameState.playerId, authoritative:true });
      hostAuthoritativeRoom(rid);
      showRoomCreatedModal(rid);
    } catch(e) { console.warn(e); toast('Create room failed'); }
  });
  m.box.querySelector('#joinRoomBtn').addEventListener('click', ()=> { m.close(); joinRoomPrompt(); });
});
document.getElementById('btnRandom').addEventListener('click', async ()=>{
  try {
    const roomsSnap = await get(ref(db, 'rooms'));
    if(roomsSnap.exists()) {
      const rooms = roomsSnap.val();
      for(const rid in rooms) {
        const rm = rooms[rid];
        if(rm && !rm.answerer) { await joinRoomById(rid); toast('Joined ' + rid); return; }
      }
    }
    const newId = Math.random().toString(36).slice(2,10);
    await set(ref(db, `rooms/${newId}`), { createdAt: Date.now(), host: gameState.playerId, authoritative:true });
    hostAuthoritativeRoom(newId); showRoomCreatedModal(newId);
  } catch(e) { console.warn(e); toast('Random match error'); }
});
document.getElementById('copyPlayerCode').addEventListener('click', ()=> {
  const code = gameState.playerId || '';
  if(!code) { toast('Player code not ready'); return; }
  navigator.clipboard?.writeText(code).then(()=>toast('Copied')).catch(()=>toast('Copy failed'));
});
document.getElementById('saveBtn').addEventListener('click', ()=> saveSlot());
document.getElementById('savesBtn').addEventListener('click', ()=> openSavesDialog());
document.getElementById('exportBtn').addEventListener('click', ()=> exportSaveFile());
document.getElementById('importBtn').addEventListener('click', ()=> document.getElementById('importFile').click());
document.getElementById('importFile').addEventListener('change', (e) => { const f = e.target.files && e.target.files[0]; importSaveFile(f); e.target.value=''; });
document.getElementById('backBtn').addEventListener('click', ()=> { document.getElementById('gameScreen').style.display='none'; document.getElementById('mainMenu').style.display='block'; });

/* ---------- friends / recent dialogs ---------- */
function showFriendsDialog(){
  const content = `<h3>Friends</h3><div style="margin-top:8px"><input id="friendInput" class="input" placeholder="Enter player code to add"/></div><div style="display:flex;gap:8px;margin-top:8px"><button id="addFriendBtn" class="btn primary">Add</button><button class="btn ghost" data-close>Close</button></div><div style="margin-top:10px"><h4>Your friends</h4><div style="max-height:160px;overflow:auto">${gameState.friends.map(f=>`<div style="padding:6px 0">${f}</div>`).join('') || '<div class="small" style="color:#666">No friends</div>'}</div></div>`;
  const m = showModal(content);
  m.box.querySelector('#addFriendBtn').addEventListener('click', ()=> {
    const v = m.box.querySelector('#friendInput').value.trim(); if(!v){ toast('Enter code'); return; } addFriendId(v); m.close(); toast('Friend added');
  });
}
function showRecentDialog(){ showModal(`<h3>Recent</h3><div style="max-height:240px;overflow:auto;margin-top:8px">${gameState.recentOpponents.map(r=>`<div style="padding:6px 0">${r}</div>`).join('') || '<div class="small" style="color:#666">No recents</div>'}</div><div style="text-align:right;margin-top:10px"><button class="btn ghost" data-close>Close</button></div>`); }
function addFriendId(id){ if(!id) return; gameState.friends.unshift(id); gameState.friends = [...new Set(gameState.friends)].slice(0,50); localStorage.setItem(META_KEY, JSON.stringify({ playerId: gameState.playerId, friends:gameState.friends, recent:gameState.recentOpponents })); set(ref(db, `players/${gameState.playerId}/meta`), { friends:gameState.friends, lastSeen:Date.now() }).catch(()=>{}); }

/* ---------- join prompt ---------- */
function joinRoomPrompt(){
  const nm = 'joinRoomInput_' + Math.random().toString(36).slice(2,6);
  const html = `<h3>Join Room</h3><div style="margin-top:8px"><input id="${nm}" class="input" placeholder="Enter room id"/></div><div style="text-align:right;margin-top:10px"><button class="btn ghost" data-close>Cancel</button><button id="doJoin" class="btn primary">Join</button></div>`;
  const m = showModal(html);
  m.box.querySelector('#doJoin').addEventListener('click', async ()=> {
    const rid = m.box.querySelector('#'+nm).value.trim(); if(!rid){ toast('Enter room id'); return; } m.close(); await joinRoomById(rid);
  });
}

/* ---------- initialization: auth / id / items ---------- */
signInAnonymously(auth).catch(err => { console.warn('anon sign-in failed', err); toast('Anonymous sign-in failed (check Firebase config/rules)'); });

onAuthStateChanged(auth, (user) => {
  if(user) {
    const metaSaved = safeParse(localStorage.getItem(META_KEY), {});
    if(metaSaved && metaSaved.playerId) gameState.playerId = metaSaved.playerId;
    else gameState.playerId = 'p-' + user.uid;
    localStorage.setItem(META_KEY, JSON.stringify({ playerId: gameState.playerId, friends: gameState.friends, recent: gameState.recentOpponents }));
    writePresence();
    ensurePlayerNode();
    updateAllUI();
  }
});

// load meta if present
try {
  const meta = safeParse(localStorage.getItem(META_KEY), {});
  if(meta && meta.playerId) gameState.playerId = meta.playerId;
  gameState.friends = meta.friends || gameState.friends;
  gameState.recentOpponents = meta.recent || gameState.recentOpponents;
} catch(e) {}

if(!gameState.playerId) { gameState.playerId = generateId(); localStorage.setItem(META_KEY, JSON.stringify({ playerId: gameState.playerId, friends: gameState.friends, recent: gameState.recentOpponents })); }

generateItems(); updateAllUI();
setInterval(()=> { quickSave(); writePresence(); }, 15000);
refreshRoomsPanel();

/* ---------- error-tolerant DB writes (wrap common set/remove calls to show permission errors) ---------- */
async function safeSet(pathRef, value) {
  try { await set(pathRef, value); return true; } catch(e) { console.warn('safeSet error', e); if(e && e.code && e.code.includes('PERMISSION')) toast('Permission denied writing to DB ‚Äî check rules (anonymous auth).'); else toast('Write failed'); return false; }
}

/* ---------- expose debug and helpful handles ---------- */
window.gameState = gameState;
window.saveSlot = saveSlot;
window.loadSlot = loadSlot;
window.exportSaveFile = exportSaveFile;
window.buyItemLocal = buyItemLocal;
window.serveCustomerLocal = serveCustomerLocal;
window.refreshRoomsPanel = refreshRoomsPanel;
</script>
</body>
</html>
