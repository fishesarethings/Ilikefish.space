<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Idle Shop Keeper</title>
<style>
/* (kept styles minimal and compatible with your previous version) */
body{box-sizing:border-box;margin:0;padding:20px;font-family:'Segoe UI',sans-serif;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);min-height:100vh;color:#333}
.game-container{max-width:1200px;margin:0 auto;background:white;border-radius:20px;padding:30px;box-shadow:0 20px 40px rgba(0,0,0,0.1)}
.main-menu{text-align:center}
.subtitle{color:#666;font-size:1.2rem;margin:10px 0 40px 0}
.menu-options{max-width:680px;margin:0 auto}
.menu-btn{width:100%;background:white;border:2px solid #e2e8f0;border-radius:15px;padding:20px;margin-bottom:15px;cursor:pointer;transition:all .3s ease;display:flex;align-items:center;gap:20px;text-align:left}
.menu-btn:hover{border-color:#4299e1;transform:translateY(-2px);box-shadow:0 8px 25px rgba(66,153,225,.15)}
.single-player{background:linear-gradient(135deg,#48bb78,#38a169);color:white;border-color:#38a169}
.btn-icon{font-size:2.5rem;min-width:60px}
.btn-text h3{margin:0 0 5px;font-size:1.2rem}
.btn-text p{margin:0;color:#666;font-size:.9rem}
.player-code{font-size:.9rem;color:#2d3748;background:#f7fafc;padding:6px 8px;border-radius:8px;border:1px solid #e2e8f0;display:inline-block;margin-left:8px}
.copy-btn{margin-left:8px;padding:6px 8px;border-radius:8px;border:none;cursor:pointer;background:#4299e1;color:white}
.players-panel{margin-top:12px;padding:12px;border-radius:10px;border:1px solid #e2e8f0;background:#fbfcff;max-height:220px;overflow:auto}
.player-row{display:flex;justify-content:space-between;align-items:center;padding:6px 8px;border-bottom:1px dashed #e2e8f0}
.player-row:last-child{border-bottom:none}
.status-dot{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px}
.status-online{background:#38a169}.status-off{background:#cbd5e0}
.small{font-size:.85rem;color:#555}
.modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.45);display:flex;align-items:center;justify-content:center;z-index:3000;pointer-events:auto}
.modal{background:white;padding:18px;border-radius:12px;width:380px;max-width:94%;box-shadow:0 8px 40px rgba(0,0,0,0.25)}
.input{width:100%;padding:8px 10px;border-radius:8px;border:1px solid #e2e8f0}
.btn{padding:8px 12px;border-radius:8px;border:none;cursor:pointer}
.btn.primary{background:#4299e1;color:white}
.btn.ghost{background:#e2e8f0;color:#2d3748}
#toastArea{position:fixed;right:18px;bottom:18px;display:flex;flex-direction:column;gap:8px;z-index:4000}
.toast{background:#2d3748;color:white;padding:8px 12px;border-radius:8px;opacity:0.95;min-width:160px}
.pingBox{position:fixed;right:18px;top:18px;background:rgba(255,255,255,0.9);padding:6px 10px;border-radius:8px;border:1px solid #e2e8f0;z-index:4001;display:flex;align-items:center;gap:8px}
.signalBars{display:inline-flex;gap:2px;align-items:center}
.bar{width:6px;height:10px;background:#cbd5e0;border-radius:2px}
.bar.on{background:#38a169}
@media(max-width:768px){.menu-options{padding:0 12px}}
</style>
</head>
<body>
<div class="game-container">
  <div id="mainMenu" class="main-menu">
    <div class="header">
      <h1>üè™ Idle Shop Keeper</h1>
      <p class="subtitle">Build your retail empire!</p>
      <div style="margin-top:12px">
        <span class="small">Your player code:</span>
        <span id="playerCode" class="player-code">‚Äî</span>
        <button id="copyPlayerCode" class="copy-btn">Copy</button>
      </div>
    </div>

    <div class="menu-options">
      <button class="menu-btn single-player" id="btnSingle">
        <div class="btn-icon">üéÆ</div>
        <div class="btn-text"><h3>Single Player</h3><p>Play solo and build your shop</p></div>
      </button>

      <div style="margin:10px 0;text-align:left">
        <strong>Friends & Recent</strong>
        <div style="display:flex;gap:10px;margin-top:8px;justify-content:center">
          <button id="btnFriends" class="menu-btn multiplayer">üë• Friends</button>
          <button id="btnRecent" class="menu-btn multiplayer">üïò Recent</button>
        </div>
      </div>

      <div class="multiplayer-section">
        <h2>üåê Multiplayer Options</h2>
        <div style="display:grid;gap:10px">
          <div style="display:flex;gap:10px">
            <button class="menu-btn multiplayer" id="btnLAN"><div class="btn-icon">üè†</div><div class="btn-text"><h3>Local Network</h3><p>Play with friends on LAN</p></div></button>
            <button class="menu-btn multiplayer" id="btnGlobal"><div class="btn-icon">üåç</div><div class="btn-text"><h3>Create/Join Room</h3><p>Global players</p></div></button>
          </div>
          <button class="menu-btn multiplayer" id="btnRandom"><div class="btn-icon">üé≤</div><div class="btn-text"><h3>Random Match</h3><p>Find a random opponent</p></div></button>

          <div>
            <h4 style="margin:8px 0 6px 0">Available Players (online)</h4>
            <div id="playersPanel" class="players-panel"><div class="small" style="color:#666;text-align:center">Loading players...</div></div>
          </div>

          <div style="margin-top:12px">
            <h4 style="margin:6px 0">Active Rooms (create/join)</h4>
            <div id="roomsPanel" class="players-panel"><div class="small" style="color:#666;text-align:center">Loading rooms...</div></div>
            <div style="margin-top:8px;display:flex;gap:8px">
              <button id="createRoomBtn" class="btn primary">Create Room</button>
              <button id="refreshRoomsBtn" class="btn ghost">Refresh Rooms</button>
            </div>
          </div>

        </div>
      </div>
    </div>
  </div>

  <div id="gameScreen" style="display:none">
    <div class="header"><h1>üè™ Idle Shop Keeper</h1></div>
    <div class="stats" style="display:flex;gap:12px;flex-wrap:wrap">
      <div class="stat-card" style="flex:1;min-width:180px"><h3>üí∞ Money</h3><p id="money" class="stat-value">$100</p></div>
      <div class="stat-card" style="flex:1;min-width:180px"><h3>üë• Customers Served</h3><p id="customersServed" class="stat-value">0</p></div>
      <div class="stat-card" style="flex:1;min-width:180px"><h3>‚≠ê Shop Level</h3><p id="shopLevel" class="stat-value">1</p></div>
    </div>

    <div style="margin-top:16px;display:flex;gap:8px;flex-wrap:wrap">
      <button id="saveBtn" class="btn primary">Save</button>
      <button id="savesBtn" class="btn ghost">Saves</button>
      <button id="exportBtn" class="btn primary">Export</button>
      <input id="importFile" type="file" accept=".json" style="display:none" />
      <button id="importBtn" class="btn ghost">Import</button>
      <button id="backBtn" class="btn ghost">Back to Menu</button>
    </div>
  </div>
</div>

<div id="modalRoot" style="position:fixed;inset:0;pointer-events:none;z-index:3500"></div>
<div id="toastArea"></div>

<!-- Ping / signal widget -->
<div id="pingWidget" class="pingBox" style="display:none">
  <div id="pingValue">-- ms</div>
  <div class="signalBars" id="signalBars" aria-hidden="true">
    <div class="bar" id="bar1"></div><div class="bar" id="bar2"></div><div class="bar" id="bar3"></div><div class="bar" id="bar4"></div><div class="bar" id="bar5"></div>
  </div>
</div>

<script type="module">
/* ---------- Imports ---------- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-app.js";
import { getDatabase, ref, set, push, onValue, onChildAdded, child, get, remove, update, onDisconnect } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-database.js";
import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-auth.js";

/* ---------- CONFIG ---------- */
const firebaseConfig = {
  apiKey: "AIzaSyBn4khIpi57YvqQX2urCup2mCvpVUZ0j8k",
  authDomain: "idle-shop-keeper.firebaseapp.com",
  databaseURL: "https://idle-shop-keeper-default-rtdb.firebaseio.com",
  projectId: "idle-shop-keeper",
  storageBucket: "idle-shop-keeper.firebasestorage.app",
  messagingSenderId: "117380146729",
  appId: "1:117380146729:web:8180d507d5a2aae45e5e38",
  measurementId: "G-VS2Z5T0Y9Y"
};
const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const auth = getAuth(app);

/* ---------- UI helpers ---------- */
const modalRoot = document.getElementById('modalRoot');
function showModal(html, opts = {}) {
  const backdrop = document.createElement('div'); backdrop.className = 'modal-backdrop';
  const box = document.createElement('div'); box.className = 'modal'; box.innerHTML = html;
  backdrop.appendChild(box); modalRoot.appendChild(backdrop);
  const close = () => { try{ backdrop.remove(); }catch(e){} if(opts.onClose) opts.onClose(); };
  box.querySelectorAll('[data-close]').forEach(el=>el.addEventListener('click', close));
  return { box, close };
}
function toast(msg, t = 3000) {
  const area = document.getElementById('toastArea'); const el = document.createElement('div'); el.className='toast'; el.textContent = msg; area.appendChild(el);
  setTimeout(()=> el.style.opacity='0', t-350); setTimeout(()=> { try{ el.remove(); }catch(e){} }, t);
}

/* ---------- storage keys and helpers ---------- */
const STORAGE_KEY = 'idle_shop_saves_v1', META_KEY = 'idle_shop_meta_v1';
function safeParse(s, fallback={}){ try { return JSON.parse(s); } catch(e) { return fallback; } }
function generateId() { return (crypto && crypto.randomUUID) ? 'p-'+crypto.randomUUID() : 'p-'+Math.random().toString(36).slice(2,10); }

/* ---------- game state ---------- */
let gameState = {
  money: 100,
  customersServed: 0,
  shopLevel: 1,
  inventory: {},
  upgrades: { autoCustomer:0, fasterService:0, betterPrices:0, moreCustomers:0 },
  customers: [],
  workers: { manager:{level:0,assigned:'idle'}, restocker:{level:0,assigned:'idle'}, server:{level:0,assigned:'idle'} },
  playerId: null,
  unlockedCount: 6,
  friends: [],
  recentOpponents: [],
  autosave: true
};

/* ---------- items ---------- */
const TOTAL_ITEMS = 5000; const items = {};
function generateItems(){
  const base = [
    {key:'apple',emoji:'üçé',name:'Apple',buyPrice:5,sellPrice:8},
    {key:'bread',emoji:'üçû',name:'Bread',buyPrice:8,sellPrice:12},
    {key:'milk',emoji:'ü•õ',name:'Milk',buyPrice:12,sellPrice:18},
    {key:'candy',emoji:'üç¨',name:'Candy',buyPrice:15,sellPrice:25},
    {key:'coffee',emoji:'‚òï',name:'Coffee',buyPrice:20,sellPrice:35},
    {key:'cake',emoji:'üéÇ',name:'Cake',buyPrice:30,sellPrice:50}
  ];
  base.forEach(it=>{ items[it.key]=it; gameState.inventory[it.key]=gameState.inventory[it.key]||0; });
  for(let i=base.length+1;i<=TOTAL_ITEMS;i++){ const key='item_'+i; const buy=5+Math.floor(i*0.8); const sell=Math.floor(buy*1.6); items[key]={emoji:'üéÅ',name:'Item '+i,buyPrice:buy,sellPrice:sell}; gameState.inventory[key]=gameState.inventory[key]||0; }
}

/* ---------- UI updates ---------- */
function updateStats(){ try{
  document.getElementById('money').textContent='$'+gameState.money;
  document.getElementById('customersServed').textContent=gameState.customersServed;
  document.getElementById('shopLevel').textContent=gameState.shopLevel;
  document.getElementById('playerCode').textContent=gameState.playerId || '‚Äî';
}catch(e){} }
function updateAllUI(){ updateStats(); }

/* ---------- saves ---------- */
function getLocalSaves(){ return safeParse(localStorage.getItem(STORAGE_KEY), {}); }
function setLocalSaves(s){ try { localStorage.setItem(STORAGE_KEY, JSON.stringify(s)); } catch(e) {} }

async function saveSlot(slotName){
  const name = slotName || ('save-'+new Date().toISOString().slice(0,19).replace(/[:T]/g,'-'));
  const saves = getLocalSaves(); saves[name] = { state: JSON.parse(JSON.stringify(gameState)), ts: Date.now() }; setLocalSaves(saves);
  try{ if(gameState.playerId) await set(ref(db, `players/${gameState.playerId}/saves/${name}`), saves[name]); toast('Saved: '+name); } catch(e){ toast('Saved locally (upload failed)'); }
}
async function loadSlot(name){
  const saves = getLocalSaves();
  if(saves[name]){ gameState = JSON.parse(JSON.stringify(saves[name].state)); postLoadRestore(); toast('Loaded: '+name); return; }
  try{ if(gameState.playerId){ const snap = await get(ref(db, `players/${gameState.playerId}/saves/${name}`)); if(snap.exists()){ const payload = snap.val(); gameState = JSON.parse(JSON.stringify(payload.state)); postLoadRestore(); toast('Loaded from server: '+name); return; } } }catch(e){}
  toast('Save not found: '+name);
}
function postLoadRestore(){ generateItems(); gameState.inventory = gameState.inventory || {}; updateAllUI(); }

function quickSave(){ try{ const saves = getLocalSaves(); const key='quick_'+gameState.playerId; saves[key] = { state: JSON.parse(JSON.stringify(gameState)), ts: Date.now() }; setLocalSaves(saves); if(gameState.playerId) set(ref(db, `players/${gameState.playerId}/saves/${key}`), saves[key]).catch(()=>{}); }catch(e){} }

/* export/import */
function exportSaveFile(){ const payload = { savedAt: Date.now(), playerId: gameState.playerId, state: gameState }; const data = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(payload, null, 2)); const a=document.createElement('a'); a.href=data; a.download=`idle-shop-${gameState.playerId||'anon'}-${new Date().toISOString().slice(0,19)}.json`; document.body.appendChild(a); a.click(); a.remove(); toast('Export started'); }
function importSaveFile(file){ if(!file){ toast('No file'); return; } const r=new FileReader(); r.onload=(e)=>{ try{ const p = JSON.parse(e.target.result); if(!p||!p.state){ toast('Invalid file'); return; } gameState = p.state; postLoadRestore(); const saves = getLocalSaves(); const key='import_'+(p.playerId||'import')+'_'+Date.now(); saves[key] = { state: JSON.parse(JSON.stringify(gameState)), ts: Date.now() }; setLocalSaves(saves); if(gameState.playerId) set(ref(db, `players/${gameState.playerId}/saves/${key}`), saves[key]).catch(()=>{}); toast('Imported'); } catch(e){ console.warn(e); toast('Failed import'); } }; r.readAsText(file); }

/* ---------- presence & players list ---------- */
async function writePresence(){
  if(!gameState.playerId) return;
  try{
    const pRef = ref(db, `players/${gameState.playerId}/presence`);
    await set(pRef, { lastSeen: Date.now(), playerId: gameState.playerId });
    try{ await onDisconnect(pRef).remove(); } catch(e) {}
  }catch(e){ console.warn('presence write failed', e); }
}
function renderPlayersPanel(allPlayers){
  const panel = document.getElementById('playersPanel'); panel.innerHTML = '';
  const rows = [];
  Object.keys(allPlayers || {}).forEach(pid => {
    if(pid === gameState.playerId) return;
    const p = allPlayers[pid]; const pres = p.presence || {}; const last = pres.lastSeen || 0; const online = (Date.now() - last) < 60000;
    rows.push({ pid, online, meta: p.meta || {} });
  });
  if(rows.length === 0){ panel.innerHTML = '<div class="small" style="text-align:center;color:#666">No players found</div>'; return; }
  rows.sort((a,b)=> (b.online?1:0) - (a.online?1:0));
  rows.forEach(r=>{
    const div = document.createElement('div'); div.className='player-row';
    const left = document.createElement('div'); left.style.display='flex'; left.style.alignItems='center';
    const dot = document.createElement('span'); dot.className = 'status-dot ' + (r.online ? 'status-online' : 'status-off'); left.appendChild(dot);
    const name = document.createElement('div'); name.innerHTML = `<strong style="margin-left:8px">${r.pid}</strong><div class="small" style="color:#666">${r.online ? 'Online' : 'Offline'}</div>`; left.appendChild(name);
    const right = document.createElement('div'); const inviteBtn = document.createElement('button'); inviteBtn.className='btn primary'; inviteBtn.textContent='Invite'; inviteBtn.onclick = () => invitePlayer(r.pid);
    const joinBtn = document.createElement('button'); joinBtn.className='btn ghost'; joinBtn.textContent='Join Room'; joinBtn.onclick = () => tryJoinPlayerRoom(r.pid);
    right.appendChild(inviteBtn); right.appendChild(joinBtn); right.style.display='flex'; right.style.gap='6px';
    div.appendChild(left); div.appendChild(right); panel.appendChild(div);
  });
}

/* ---------- rooms list & UI ---------- */
const ROOM_TTL_MS = 1000 * 60 * 60 * 4; // 4 hours TTL for stale rooms; sweep clients will remove older rooms if no presence

function renderRoomsPanel(allRooms){
  const panel = document.getElementById('roomsPanel'); panel.innerHTML = '';
  const rows = [];
  Object.keys(allRooms || {}).forEach(rid => {
    const r = allRooms[rid];
    rows.push({ rid, host: r.host, createdAt: r.createdAt || 0, state: r.state || {}, meta: r.meta || {} });
  });
  if(rows.length === 0){ panel.innerHTML = '<div class="small" style="text-align:center;color:#666">No active rooms</div>'; return; }
  rows.sort((a,b)=> b.createdAt - a.createdAt);
  rows.forEach(r => {
    const div = document.createElement('div'); div.className='player-row';
    const left = document.createElement('div'); left.innerHTML = `<div style="font-weight:bold">${r.rid}</div><div class="small" style="color:#666">Host: ${r.host} ‚Ä¢ Age: ${Math.round((Date.now()-r.createdAt)/60000)}m</div>`;
    const right = document.createElement('div');
    const joinBtn = document.createElement('button'); joinBtn.className='btn primary'; joinBtn.textContent='Join'; joinBtn.onclick = () => joinRoomById(r.rid);
    const viewBtn = document.createElement('button'); viewBtn.className='btn ghost'; viewBtn.textContent='View'; viewBtn.onclick = () => showModal(`<h3>Room ${r.rid}</h3><div style="margin-top:8px"><div class="small" style="color:#666">Host: ${r.host}</div><pre style="max-height:200px;overflow:auto;background:#f7fafc;padding:8px;border-radius:6px;border:1px solid #e2e8f0">${JSON.stringify(r.state || {}, null, 2)}</pre></div><div style="text-align:right;margin-top:10px"><button class="btn ghost" data-close>Close</button></div>`);
    right.appendChild(joinBtn); right.appendChild(viewBtn); right.style.display='flex'; right.style.gap='6px';
    div.appendChild(left); div.appendChild(right); panel.appendChild(div);
  });
}

/* ---------- create room (host) with onDisconnect cleanup ---------- */
async function createRoom() {
  const rid = Math.random().toString(36).slice(2,10);
  const roomRef = ref(db, `rooms/${rid}`);
  try {
    await set(roomRef, { createdAt: Date.now(), host: gameState.playerId, state: { money: gameState.money, customersServed: gameState.customersServed, shopLevel: gameState.shopLevel }, meta: { createdBy: gameState.playerId } });
    // register onDisconnect for host to remove room automatically
    try { await onDisconnect(roomRef).remove(); } catch(e) { /* best effort */ }
    toast('Room created: ' + rid);
    hostRoom(rid);
  } catch(e) {
    console.warn('createRoom failed', e); toast('Failed to create room');
  }
}

/* ---------- authoritative model: actions queue processed by host ---------- */
/*
  - clients push actions to rooms/{rid}/actions (child push)
  - host listens on actions and processes them (applies to rooms/{rid}/state using transactions)
  - host removes action entry after processing
  - clients subscribe to rooms/{rid}/state to receive authoritative updates
*/

/* host processing */
let hostActionListenerHandles = {};

function hostRoom(rid){
  // set active room id for local host
  console.log('Hosting room', rid);
  // start listening for actions
  const actionsRef = ref(db, `rooms/${rid}/actions`);
  // onChildAdded handles incoming actions
  const unsub = onChildAdded(actionsRef, async (snap) => {
    const actionKey = snap.key; const action = snap.val();
    if(!action) return;
    // process action atomically: use transaction on rooms/{rid}/state
    const stateRef = ref(db, `rooms/${rid}/state`);
    try {
      await update(ref(db, `rooms/${rid}/processing/${actionKey}`), { processingBy: gameState.playerId, ts: Date.now() }); // mark processing (optional)
      await runActionTransaction(stateRef, action);
      // remove the processed action
      await remove(ref(db, `rooms/${rid}/actions/${actionKey}`));
      await remove(ref(db, `rooms/${rid}/processing/${actionKey}`)).catch(()=>{});
    } catch(e){
      console.warn('action processing failed', e);
    }
  });
  hostActionListenerHandles[rid] = unsub;
}

/* runActionTransaction: apply a single action object to the state safely via transaction */
async function runActionTransaction(stateRef, action) {
  // action format: { type: 'buy'|'serve'|..., payload: {...}, by: playerId, ts }
  try {
    // use get + set pattern: read current state, modify, write via transaction
    await set(stateRef, await applyActionToState((await get(stateRef)).val() || { money:0,customersServed:0,shopLevel:1 }, action));
  } catch(e){
    console.warn('runActionTransaction error', e);
  }
}

/* very small example action application (extendable) */
function applyActionToState(current, action) {
  const copy = JSON.parse(JSON.stringify(current || {}));
  try {
    if(action.type === 'giveMoney') {
      copy.money = (copy.money || 0) + (action.payload.amount || 0);
    } else if(action.type === 'serve') {
      copy.customersServed = (copy.customersServed || 0) + 1;
      copy.money = (copy.money || 0) + (action.payload.earn || 0);
    } else if(action.type === 'buy') {
      copy.money = (copy.money || 0) - (action.payload.cost || 0);
      copy.inventory = copy.inventory || {};
      copy.inventory[action.payload.key] = (copy.inventory[action.payload.key] || 0) + (action.payload.amount || 1);
    }
    // update shopLevel for demo
    if(copy.customersServed && (copy.customersServed % 10 === 0)) copy.shopLevel = (copy.shopLevel || 1) + 1;
  } catch(e){ console.warn('applyActionToState failed', e); }
  return copy;
}

/* client pushes an action to queue */
async function pushActionToRoom(rid, action) {
  try {
    const actionRef = push(ref(db, `rooms/${rid}/actions`));
    await set(actionRef, { ...action, by: gameState.playerId, ts: Date.now() });
  } catch(e) {
    console.warn('pushAction failed', e);
  }
}

/* clients subscribe to room state */
function subscribeToRoomState(rid) {
  const stateRef = ref(db, `rooms/${rid}/state`);
  onValue(stateRef, snap => {
    const val = snap.val();
    if(!val) return;
    // apply authoritative state snapshot to local view (don't overwrite player-specific metadata)
    gameState.money = val.money || gameState.money;
    gameState.customersServed = val.customersServed || gameState.customersServed;
    gameState.shopLevel = val.shopLevel || gameState.shopLevel;
    if(val.inventory) {
      Object.keys(val.inventory).slice(0,20).forEach(k => { gameState.inventory[k] = val.inventory[k]; });
    }
    updateAllUI();
  });
}

/* ---------- join & host flows (we still keep WebRTC datachannels for direct peer sync + ping) ---------- */
let pc = null, dataChannel = null, roomIdActive = null;
function createPeerConnection() {
  const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
  const conn = new RTCPeerConnection(configuration);
  conn.onicecandidate = (e) => {
    if(e.candidate && roomIdActive) {
      push(ref(db, `rooms/${roomIdActive}/candidates/${gameState.playerId}`), e.candidate.toJSON()).catch(()=>{});
    }
  };
  conn.ondatachannel = (ev) => {
    dataChannel = ev.channel;
    setupDataChannelHandlers();
  };
  conn.onconnectionstatechange = () => {
    if(conn.connectionState === 'connected') toast('Peer connected');
    if(conn.connectionState === 'disconnected' || conn.connectionState === 'failed') toast('Peer disconnected');
  };
  pc = conn; return conn;
}
function setupDataChannelHandlers(){
  if(!dataChannel) return;
  dataChannel.onopen = ()=> { console.log('DC open'); sendGameStateSnapshot(); startPingLoop(); document.getElementById('pingWidget').style.display='flex'; };
  dataChannel.onclose = ()=> { stopPingLoop(); document.getElementById('pingWidget').style.display='none'; };
  dataChannel.onmessage = (ev) => {
    try{
      const msg = JSON.parse(ev.data);
      if(msg.type === 'syncState'){ const s=msg.state; if(s) { gameState.money = s.money || gameState.money; gameState.customersServed = s.customersServed || gameState.customersServed; gameState.shopLevel = s.shopLevel || gameState.shopLevel; updateAllUI(); } }
      else if(msg.type === 'ping') {
        // reply with pong immediately
        dataChannel.send(JSON.stringify({ type: 'pong', ts: msg.ts }));
      } else if(msg.type === 'pong') {
        // compute RTT
        const now = Date.now(); const rtt = now - (msg.ts || now);
        updatePingDisplay(rtt);
      } else if(msg.type === 'requestSync') { sendGameStateSnapshot(); }
    }catch(e){ console.warn('dc msg parse', e); }
  };
}
function sendGameStateSnapshot(){
  if(!dataChannel||dataChannel.readyState!=='open') return;
  const invKeys = Object.keys(gameState.inventory).slice(0,12);
  const inv = {}; invKeys.forEach(k => inv[k] = gameState.inventory[k]);
  const payload = { type:'syncState', state:{ money:gameState.money, customersServed:gameState.customersServed, shopLevel:gameState.shopLevel, inventory:inv } };
  dataChannel.send(JSON.stringify(payload));
}

/* ping loop via datachannel */
let pingInterval = null;
function startPingLoop(){
  if(pingInterval) return;
  pingInterval = setInterval(()=> {
    if(!dataChannel || dataChannel.readyState !== 'open') return;
    const ts = Date.now();
    dataChannel.send(JSON.stringify({ type:'ping', ts }));
  }, 2000);
}
function stopPingLoop(){ if(pingInterval){ clearInterval(pingInterval); pingInterval=null; } }
function updatePingDisplay(ms){
  const el = document.getElementById('pingValue'); el.textContent = (ms ? ms+' ms' : '-- ms');
  // signal bars based on thresholds (smaller is better)
  const bars = [50, 120, 200, 350]; // thresholds - adjust as needed
  for(let i=1;i<=5;i++){ document.getElementById('bar'+i).classList.remove('on'); }
  if(!ms) return;
  let on = 1;
  if(ms <= bars[0]) on = 5;
  else if(ms <= bars[1]) on = 4;
  else if(ms <= bars[2]) on = 3;
  else if(ms <= bars[3]) on = 2;
  else on = 1;
  for(let i=1;i<=on;i++) document.getElementById('bar'+i).classList.add('on');
}

/* hostRoom WebRTC steps simplified (host will create offer) */
async function hostRoomWebRTC(rid){
  roomIdActive = rid;
  createPeerConnection();
  dataChannel = pc.createDataChannel('game'); setupDataChannelHandlers();
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  await set(ref(db, `rooms/${rid}/offer`), { sdp: offer.sdp, type: offer.type, from: gameState.playerId, createdAt: Date.now() });
  onValue(ref(db, `rooms/${rid}/answer`), async snap => { const val = snap.val(); if(!val||!val.sdp) return; await pc.setRemoteDescription({ type: val.type, sdp: val.sdp }).catch(()=>{}); });
  onChildAdded(ref(db, `rooms/${rid}/candidates`), snap => {
    const obj = snap.val(); if(!obj) return; Object.values(obj).forEach(async candidate => { try{ await pc.addIceCandidate(candidate); }catch(e){} });
  });
}

/* joiner using offer->answer flow */
async function joinRoomById(rid){
  roomIdActive = rid;
  createPeerConnection();
  try {
    const offerSnap = await get(ref(db, `rooms/${rid}/offer`));
    if(!offerSnap.exists()){ toast('No offer in room ' + rid); return; }
    const offer = offerSnap.val();
    await pc.setRemoteDescription({ type: offer.type, sdp: offer.sdp }).catch(()=>{});
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    await set(ref(db, `rooms/${rid}/answer`), { sdp: answer.sdp, type: answer.type, from: gameState.playerId, answeredAt: Date.now() });
    // listen for candidates
    onChildAdded(ref(db, `rooms/${rid}/candidates`), snap => {
      const obj = snap.val(); if(!obj) return; Object.values(obj).forEach(async candidate => { try{ await pc.addIceCandidate(candidate); } catch(e){} });
    });
    // subscribe to authoritative state too
    subscribeToRoomState(rid);
    toast('Joined room: ' + rid);
  } catch(e) { console.warn(e); toast('Failed to join room'); }
}

/* ---------- room sweeper (client-side) ---------- */
/* invisible by default; can be toggled via developer console or an admin modal */
let AUTO_SWEEPER_ENABLED = false;
async function clientSweepRooms() {
  try {
    const snap = await get(ref(db, 'rooms'));
    if(!snap.exists()) return;
    const rooms = snap.val();
    const now = Date.now();
    for(const rid in rooms) {
      const r = rooms[rid];
      const age = now - (r.createdAt || 0);
      if(age > ROOM_TTL_MS) {
        // check host presence
        const hostId = r.host;
        const presSnap = await get(ref(db, `players/${hostId}/presence`));
        const last = presSnap.exists() ? (presSnap.val().lastSeen || 0) : 0;
        if((now - last) > ROOM_TTL_MS) {
          // remove stale room
          await remove(ref(db, `rooms/${rid}`)).catch(()=>{});
          console.log('sweeper removed room', rid);
        }
      }
    }
  } catch(e) { console.warn('sweeper failed', e); }
}

/* schedule sweeper when enabled */
let sweeperInterval = null;
function enableSweeper(on){
  AUTO_SWEEPER_ENABLED = !!on;
  if(AUTO_SWEEPER_ENABLED) { clientSweepRooms(); sweeperInterval = setInterval(()=> clientSweepRooms(), 1000 * 60 * 10); } else { if(sweeperInterval) { clearInterval(sweeperInterval); sweeperInterval = null; } }
}

/* ---------- invites ---------- */
async function invitePlayer(pid){
  if(!gameState.playerId) { toast('Player id missing'); return; }
  const rid = Math.random().toString(36).slice(2,10);
  try {
    await set(ref(db, `rooms/${rid}`), { createdAt: Date.now(), host: gameState.playerId, state: { money: gameState.money, customersServed: gameState.customersServed, shopLevel: gameState.shopLevel }, meta: { createdBy: gameState.playerId } });
    await set(ref(db, `players/${pid}/invites/${rid}`), { from: gameState.playerId, room: rid, ts: Date.now() });
    // onDisconnect remove
    try { await onDisconnect(ref(db, `rooms/${rid}`)).remove(); } catch(e){}
    toast('Invite sent to ' + pid);
    hostRoom(rid); // start processing actions for room
  } catch(e) { console.warn(e); toast('Invite failed'); }
}

/* respond to incoming invites */
onValue(ref(db, 'players'), snapshot => {
  const players = snapshot.val() || {};
  const me = players[gameState.playerId] || {};
  const invites = (me.invites) || {};
  const keys = Object.keys(invites);
  if(keys.length > 0) {
    const id = keys[0]; const inv = invites[id];
    if(inv && inv.room) {
      const content = `<h3>Invite</h3><div style="margin-top:8px">Player <strong>${inv.from}</strong> invited you to room <strong>${inv.room}</strong></div><div style="text-align:right;margin-top:10px"><button class="btn ghost" data-close>Ignore</button><button id="acceptInvite" class="btn primary">Join</button></div>`;
      const m = showModal(content);
      m.box.querySelector('#acceptInvite').addEventListener('click', async ()=> {
        m.close();
        await remove(ref(db, `players/${gameState.playerId}/invites/${id}`)).catch(()=>{});
        await joinRoomById(inv.room);
      });
    }
  }
});

/* ---------- UI wiring ---------- */
document.getElementById('btnSingle').addEventListener('click', () => startSinglePlayer());
document.getElementById('btnFriends').addEventListener('click', openFriendsDialog);
document.getElementById('btnRecent').addEventListener('click', openRecentDialog);
document.getElementById('createRoomBtn').addEventListener('click', () => createRoom());
document.getElementById('refreshRoomsBtn').addEventListener('click', () => { refreshRooms(); });

document.getElementById('btnLAN').addEventListener('click', ()=> { const rid = Math.random().toString(36).slice(2,10); createRoom(); toast('LAN room created: ' + rid); });
document.getElementById('btnRandom').addEventListener('click', async ()=> {
  // try to find available room, otherwise create one
  try {
    const roomsSnap = await get(ref(db, 'rooms')); if(!roomsSnap.exists()){ createRoom(); return; }
    const rooms = roomsSnap.val();
    for(const rid in rooms){ const ans = await get(ref(db, `rooms/${rid}/answer`)); if(!ans.exists()){ await joinRoomById(rid); toast('Random matched to ' + rid); return; } }
    createRoom();
  } catch(e) { console.warn(e); toast('Random match failed'); }
});

document.getElementById('btnGlobal').addEventListener('click', ()=> {
  const content = `<h3>Rooms</h3><div style="margin-top:8px"><button id="createRoomModalBtn" class="btn primary">Create Room</button><button id="joinRoomModalBtn" class="btn ghost" style="margin-left:8px">Join by ID</button></div><div style="text-align:right;margin-top:10px"><button class="btn ghost" data-close>Close</button></div>`;
  const m = showModal(content);
  m.box.querySelector('#createRoomModalBtn').addEventListener('click', async ()=> { m.close(); await createRoom(); });
  m.box.querySelector('#joinRoomModalBtn').addEventListener('click', ()=> { m.close(); joinRoomPrompt(); });
});

document.getElementById('copyPlayerCode').addEventListener('click', () => {
  const code = gameState.playerId || '';
  if(!code) { toast('Not ready'); return; }
  navigator.clipboard?.writeText(code).then(()=>toast('Copied')).catch(()=>toast('Copy failed'));
});

document.getElementById('saveBtn').addEventListener('click', ()=> saveSlot());
document.getElementById('savesBtn').addEventListener('click', ()=> openSavesDialog());
document.getElementById('exportBtn').addEventListener('click', ()=> exportSaveFile());
document.getElementById('importBtn').addEventListener('click', ()=> document.getElementById('importFile').click());
document.getElementById('importFile').addEventListener('change', (e)=> { const f=e.target.files && e.target.files[0]; importSaveFile(f); e.target.value=''; });
document.getElementById('backBtn').addEventListener('click', ()=> { document.getElementById('gameScreen').style.display='none'; document.getElementById('mainMenu').style.display='block'; });

/* ---------- rooms refresh ---------- */
async function refreshRooms() {
  try {
    const snap = await get(ref(db, 'rooms')); const rooms = snap.exists() ? snap.val() : {};
    renderRoomsPanel(rooms);
  } catch(e) { console.warn(e); toast('Failed to refresh rooms'); }
}

/* ---------- friends & recent ---------- */
function openFriendsDialog(){
  const content = `<h3>Friends</h3><div style="margin-top:8px"><input id="friendInput" class="input" placeholder="Enter player code to add"/></div><div style="display:flex;gap:8px;margin-top:8px"><button id="addFriendBtn" class="btn primary">Add</button><button class="btn ghost" data-close>Close</button></div><div style="margin-top:10px"><h4>Your friends</h4><div style="max-height:160px;overflow:auto">${gameState.friends.map(f=>`<div style="padding:6px 0">${f}</div>`).join('') || '<div class="small" style="color:#666">No friends</div>'}</div></div>`;
  const m = showModal(content);
  m.box.querySelector('#addFriendBtn').addEventListener('click', ()=> { const v = m.box.querySelector('#friendInput').value.trim(); if(!v){ toast('Enter code'); return; } addFriendId(v); m.close(); toast('Friend added'); });
}
function openRecentDialog(){ showModal(`<h3>Recent</h3><div style="max-height:240px;overflow:auto;margin-top:8px">${gameState.recentOpponents.map(r=>`<div style="padding:6px 0">${r}</div>`).join('') || '<div class="small" style="color:#666">No recents</div>'}</div><div style="text-align:right;margin-top:10px"><button class="btn ghost" data-close>Close</button></div>`); }
function addFriendId(id){ if(!id) return; gameState.friends.unshift(id); gameState.friends = [...new Set(gameState.friends)].slice(0,50); localStorage.setItem(META_KEY, JSON.stringify({ playerId: gameState.playerId, friends: gameState.friends, recent: gameState.recentOpponents })); set(ref(db, `players/${gameState.playerId}/meta`), { friends: gameState.friends, lastSeen: Date.now() }).catch(()=>{}); }

/* ---------- join by ID prompt ---------- */
function joinRoomPrompt(){
  const nm = 'joinRoomInput_'+Math.random().toString(36).slice(2,6);
  const html = `<h3>Join Room</h3><div style="margin-top:8px"><input id="${nm}" class="input" placeholder="Enter room id"/></div><div style="text-align:right;margin-top:10px"><button class="btn ghost" data-close>Cancel</button><button id="doJoin" class="btn primary">Join</button></div>`;
  const m = showModal(html);
  m.box.querySelector('#doJoin').addEventListener('click', async ()=>{ const rid = m.box.querySelector('#'+nm).value.trim(); if(!rid){ toast('Enter room id'); return; } m.close(); await joinRoomById(rid); });
}

/* ---------- initialization & auth ---------- */
signInAnonymously(auth).catch(err => { console.warn('anon sign-in failed', err); toast('Anonymous sign-in failed (check Firebase config/rules)'); });

onAuthStateChanged(auth, (user) => {
  if(user){
    const savedMeta = safeParse(localStorage.getItem(META_KEY), {});
    if(savedMeta && savedMeta.playerId) gameState.playerId = savedMeta.playerId;
    else gameState.playerId = 'p-' + user.uid;
    localStorage.setItem(META_KEY, JSON.stringify({ playerId: gameState.playerId, friends: gameState.friends, recent: gameState.recentOpponents }));
    writePresence();
    set(ref(db, `players/${gameState.playerId}/meta`), { friends: gameState.friends, lastSeen: Date.now() }).catch(()=>{});
    updateAllUI();
  }
});

// load local meta if present
try{ const meta = safeParse(localStorage.getItem(META_KEY), {}); if(meta && meta.playerId) gameState.playerId = meta.playerId; gameState.friends = meta.friends || gameState.friends; gameState.recentOpponents = meta.recent || gameState.recentOpponents; } catch(e){}

/* Ensure playerId */
if(!gameState.playerId){ gameState.playerId = generateId(); localStorage.setItem(META_KEY, JSON.stringify({ playerId: gameState.playerId, friends: gameState.friends, recent: gameState.recentOpponents })); }

generateItems(); updateAllUI();
setInterval(()=>{ quickSave(); writePresence(); }, 15000);

/* live players & rooms listeners */
onValue(ref(db, 'players'), snapshot => {
  const all = snapshot.val() || {};
  renderPlayersPanel(all);
});
onValue(ref(db, 'rooms'), snapshot => {
  const rooms = snapshot.val() || {};
  renderRoomsPanel(rooms);
});

/* ---------- fix: startSinglePlayer defined once ---------- */
let gameLoopInterval = null;
function startSinglePlayer(){
  document.getElementById('mainMenu').style.display='none'; document.getElementById('gameScreen').style.display='block';
  generateItems(); updateAllUI();
  if(gameLoopInterval) clearInterval(gameLoopInterval);
  gameLoopInterval = setInterval(gameLoop, 2000);
  setTimeout(()=> spawnCustomer(), 1000);
  writePresence(); toast('Single player started');
}

/* ---------- minimal game loop / actions so multiplayer demo shows interactions ---------- */
function spawnCustomer(){ const max = 3 + (gameState.upgrades.moreCustomers||0); if((gameState.customers||[]).length < max){ const types = [{emoji:'üë®',wants:'apple'},{emoji:'üë©',wants:'milk'},{emoji:'üë¶',wants:'candy'}]; const t = types[Math.floor(Math.random()*types.length)]; gameState.customers = gameState.customers || []; gameState.customers.push({emoji:t.emoji, wants:t.wants}); updateAllUI(); } }
function workerTick(){ /* kept minimal for demo */ }
function gameLoop(){ if(gameState.upgrades.autoCustomer > 0 && Math.random() < 0.3 + (gameState.upgrades.autoCustomer*0.1)) spawnCustomer(); if(Math.random() < 0.1 + (gameState.shopLevel * 0.02)) spawnCustomer(); workerTick(); if(gameState.autosave) quickSave(); }

/* expose actions for demo (buy/serve) that push to authoritative room if connected */
async function demoBuyItem(key) {
  if(!roomIdActive){ toast('Not in a multiplayer room; performing local buy'); if(gameState.money >= items[key].buyPrice) { gameState.money -= items[key].buyPrice; gameState.inventory[key] = (gameState.inventory[key]||0)+1; updateAllUI(); } return; }
  // push action to room
  await pushActionToRoom(roomIdActive, { type:'buy', payload:{ key, amount:1, cost: items[key].buyPrice } });
  toast('Buy action queued');
}
async function demoServe() {
  if(!roomIdActive){ toast('Not in multiplayer room; local serve'); if((gameState.inventory['apple']||0)>0){ gameState.inventory['apple']--; gameState.money += items['apple'].sellPrice; gameState.customersServed++; updateAllUI(); } return; }
  await pushActionToRoom(roomIdActive, { type:'serve', payload:{ earn: 10 } });
  toast('Serve action queued');
}

/* expose to window to help debugging */
window.demoBuyItem = demoBuyItem;
window.demoServe = demoServe;

/* ---------- ping widget initial state ---------- */
document.getElementById('pingWidget').style.display='none';

/* small helper to refresh rooms initially */
refreshRooms();

/* ---------- optional: enable invisible sweeper by default? keep hidden; admin can call enableSweeper(true) in console ---------- */
/* enableSweeper(false); // default off */

</script>
</body>
</html>
