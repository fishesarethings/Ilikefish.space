<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Idle Shop Keeper</title>
<style>
/* Styles preserved and minor additions for players list */
body{box-sizing:border-box;margin:0;padding:20px;font-family:'Segoe UI',sans-serif;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);min-height:100vh;color:#333}
.game-container{max-width:1200px;margin:0 auto;background:white;border-radius:20px;padding:30px;box-shadow:0 20px 40px rgba(0,0,0,0.1)}
.main-menu{text-align:center}
.subtitle{color:#666;font-size:1.2rem;margin:10px 0 40px 0}
.menu-options{max-width:680px;margin:0 auto}
.menu-btn{width:100%;background:white;border:2px solid #e2e8f0;border-radius:15px;padding:20px;margin-bottom:15px;cursor:pointer;transition:all .3s ease;display:flex;align-items:center;gap:20px;text-align:left}
.menu-btn:hover{border-color:#4299e1;transform:translateY(-2px);box-shadow:0 8px 25px rgba(66,153,225,.15)}
.single-player{background:linear-gradient(135deg,#48bb78,#38a169);color:white;border-color:#38a169}
.btn-icon{font-size:2.5rem;min-width:60px}
.btn-text h3{margin:0 0 5px;font-size:1.2rem}
.btn-text p{margin:0;color:#666;font-size:.9rem}
.player-code{font-size:.9rem;color:#2d3748;background:#f7fafc;padding:6px 8px;border-radius:8px;border:1px solid #e2e8f0;display:inline-block;margin-left:8px}
.copy-btn{margin-left:8px;padding:6px 8px;border-radius:8px;border:none;cursor:pointer;background:#4299e1;color:white}
.players-panel{margin-top:12px;padding:12px;border-radius:10px;border:1px solid #e2e8f0;background:#fbfcff;max-height:220px;overflow:auto}
.player-row{display:flex;justify-content:space-between;align-items:center;padding:6px 8px;border-bottom:1px dashed #e2e8f0}
.player-row:last-child{border-bottom:none}
.status-dot{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px}
.status-online{background:#38a169}.status-off{background:#cbd5e0}
.small{font-size:.85rem;color:#555}
.modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.45);display:flex;align-items:center;justify-content:center;z-index:3000}
.modal{background:white;padding:18px;border-radius:12px;width:380px;max-width:94%;box-shadow:0 8px 40px rgba(0,0,0,0.25)}
.input{width:100%;padding:8px 10px;border-radius:8px;border:1px solid #e2e8f0}
.btn{padding:8px 12px;border-radius:8px;border:none;cursor:pointer}
.btn.primary{background:#4299e1;color:white}
.btn.ghost{background:#e2e8f0;color:#2d3748}
#toastArea{position:fixed;right:18px;bottom:18px;display:flex;flex-direction:column;gap:8px;z-index:4000}
.toast{background:#2d3748;color:white;padding:8px 12px;border-radius:8px;opacity:0.95;min-width:160px}
@media(max-width:768px){.menu-options{padding:0 12px}}
/* reuse other CSS minimally (stat cards, item cards etc) */
.stat-card{background:linear-gradient(135deg,#48bb78,#38a169);color:white;padding:20px;border-radius:15px;text-align:center;box-shadow:0 4px 15px rgba(72,187,120,.3)}
</style>
</head>
<body>
<div class="game-container">
  <div id="mainMenu" class="main-menu">
    <div class="header">
      <h1>üè™ Idle Shop Keeper</h1>
      <p class="subtitle">Build your retail empire!</p>
      <div style="margin-top:12px">
        <span class="small">Your player code:</span>
        <span id="playerCode" class="player-code">‚Äî</span>
        <button id="copyPlayerCode" class="copy-btn">Copy</button>
      </div>
    </div>

    <div class="menu-options">
      <button class="menu-btn single-player" id="btnSingle">
        <div class="btn-icon">üéÆ</div>
        <div class="btn-text"><h3>Single Player</h3><p>Play solo and build your shop</p></div>
      </button>

      <div style="margin:10px 0;text-align:left">
        <strong>Friends & Recent</strong>
        <div style="display:flex;gap:10px;margin-top:8px;justify-content:center">
          <button id="btnFriends" class="menu-btn multiplayer">üë• Friends</button>
          <button id="btnRecent" class="menu-btn multiplayer">üïò Recent</button>
        </div>
      </div>

      <div class="multiplayer-section">
        <h2>üåê Multiplayer Options</h2>
        <div style="display:grid;gap:10px">
          <div style="display:flex;gap:10px">
            <button class="menu-btn multiplayer" id="btnLAN"><div class="btn-icon">üè†</div><div class="btn-text"><h3>Local Network</h3><p>Play with friends on LAN</p></div></button>
            <button class="menu-btn multiplayer" id="btnGlobal"><div class="btn-icon">üåç</div><div class="btn-text"><h3>Create/Join Room</h3><p>Global players</p></div></button>
          </div>
          <button class="menu-btn multiplayer" id="btnRandom"><div class="btn-icon">üé≤</div><div class="btn-text"><h3>Random Match</h3><p>Find a random opponent</p></div></button>

          <div>
            <h4 style="margin:8px 0 6px 0">Available Players (online)</h4>
            <div id="playersPanel" class="players-panel"><div class="small" style="color:#666;text-align:center">Loading players...</div></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Basic game screen (kept minimal for brevity; full game UI still available in original) -->
  <div id="gameScreen" style="display:none">
    <div class="header"><h1>üè™ Idle Shop Keeper</h1></div>
    <div class="stats" style="display:flex;gap:12px;flex-wrap:wrap">
      <div class="stat-card" style="flex:1;min-width:180px"><h3>üí∞ Money</h3><p id="money" class="stat-value">$100</p></div>
      <div class="stat-card" style="flex:1;min-width:180px"><h3>üë• Customers Served</h3><p id="customersServed" class="stat-value">0</p></div>
      <div class="stat-card" style="flex:1;min-width:180px"><h3>‚≠ê Shop Level</h3><p id="shopLevel" class="stat-value">1</p></div>
    </div>

    <!-- minimal interactives for saving/export -->
    <div style="margin-top:16px;display:flex;gap:8px;flex-wrap:wrap">
      <button id="saveBtn" class="btn primary">Save</button>
      <button id="savesBtn" class="btn ghost">Saves</button>
      <button id="exportBtn" class="btn primary">Export</button>
      <input id="importFile" type="file" accept=".json" style="display:none" />
      <button id="importBtn" class="btn ghost">Import</button>
      <button id="backBtn" class="btn ghost">Back to Menu</button>
    </div>
  </div>
</div>

<div id="modalRoot" style="position:fixed;inset:0;pointer-events:none;z-index:3500"></div>
<div id="toastArea"></div>

<script type="module">
/* ------------- Firebase + game sync + players list ------------- */
/* Note: requires Firebase project with Anonymous Auth enabled and RTDB rules that allow auth != null */
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-app.js";
import { getDatabase, ref, set, push, onValue, onChildAdded, child, get, remove, update, onDisconnect } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-database.js";
import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-auth.js";

/* ---------- CONFIG - replace if needed ---------- */
const firebaseConfig = {
  apiKey: "AIzaSyBn4khIpi57YvqQX2urCup2mCvpVUZ0j8k",
  authDomain: "idle-shop-keeper.firebaseapp.com",
  databaseURL: "https://idle-shop-keeper-default-rtdb.firebaseio.com",
  projectId: "idle-shop-keeper",
  storageBucket: "idle-shop-keeper.firebasestorage.app",
  messagingSenderId: "117380146729",
  appId: "1:117380146729:web:8180d507d5a2aae45e5e38",
  measurementId: "G-VS2Z5T0Y9Y"
};
const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const auth = getAuth(app);

/* ---------- small UI helpers ---------- */
const modalRoot = document.getElementById('modalRoot');
function showModal(html, opts = {}) {
  const backdrop = document.createElement('div'); backdrop.className = 'modal-backdrop'; backdrop.style.pointerEvents='auto';
  const box = document.createElement('div'); box.className='modal'; box.innerHTML = html;
  backdrop.appendChild(box); modalRoot.appendChild(backdrop);
  const close = () => { try{ backdrop.remove(); }catch(e){} if(opts.onClose) opts.onClose(); };
  box.querySelectorAll('[data-close]').forEach(el=>el.addEventListener('click', close));
  return { box, close };
}
function toast(msg, t = 3000) {
  const area = document.getElementById('toastArea'); const el = document.createElement('div'); el.className='toast'; el.textContent = msg; area.appendChild(el);
  setTimeout(()=> el.style.opacity='0', t-350); setTimeout(()=> { try{ el.remove(); }catch(e){} }, t);
}

/* ---------- storage keys & helpers ---------- */
const STORAGE_KEY = 'idle_shop_saves_v1';
const META_KEY = 'idle_shop_meta_v1';
function safeParse(s, fallback={}){ try{return JSON.parse(s);}catch(e){return fallback;} }

/* ---------- stable id generation ---------- */
function generateId() { return (crypto && crypto.randomUUID) ? 'p-'+crypto.randomUUID() : 'p-'+Math.random().toString(36).slice(2,10); }

/* ---------- game state (kept simple) ---------- */
let gameState = {
  money: 100,
  customersServed: 0,
  shopLevel: 1,
  inventory: {},
  upgrades: { autoCustomer:0, fasterService:0, betterPrices:0, moreCustomers:0 },
  customers: [],
  workers: { manager:{level:0,assigned:'idle'}, restocker:{level:0,assigned:'idle'}, server:{level:0,assigned:'idle'} },
  playerId: null,
  unlockedCount: 6,
  friends: [],
  recentOpponents: [],
  autosave: true
};

/* ---------- items (same generation) ---------- */
const TOTAL_ITEMS = 5000, items = {};
function generateItems(){
  const base = [
    {key:'apple',emoji:'üçé',name:'Apple',buyPrice:5,sellPrice:8},
    {key:'bread',emoji:'üçû',name:'Bread',buyPrice:8,sellPrice:12},
    {key:'milk',emoji:'ü•õ',name:'Milk',buyPrice:12,sellPrice:18},
    {key:'candy',emoji:'üç¨',name:'Candy',buyPrice:15,sellPrice:25},
    {key:'coffee',emoji:'‚òï',name:'Coffee',buyPrice:20,sellPrice:35},
    {key:'cake',emoji:'üéÇ',name:'Cake',buyPrice:30,sellPrice:50}
  ];
  base.forEach(it=>{ items[it.key]=it; gameState.inventory[it.key]=gameState.inventory[it.key]||0; });
  for(let i=base.length+1;i<=TOTAL_ITEMS;i++){
    const key='item_'+i; const buy=5+Math.floor(i*0.8); const sell=Math.floor(buy*1.6);
    items[key]={emoji:'üéÅ',name:'Item '+i,buyPrice:buy,sellPrice:sell}; gameState.inventory[key]=gameState.inventory[key]||0;
  }
}

/* ---------- UI update functions ---------- */
function updateStats(){
  document.getElementById('money').textContent='$'+gameState.money;
  document.getElementById('customersServed').textContent=gameState.customersServed;
  document.getElementById('shopLevel').textContent=gameState.shopLevel;
  document.getElementById('playerCode').textContent=gameState.playerId || '‚Äî';
}
function updateAllUI(){ updateStats(); /* other UI updates (inventory / buttons) are minimal here */ }

/* ---------- save helpers (single implementation) ---------- */
function getLocalSaves(){ return safeParse(localStorage.getItem(STORAGE_KEY),'{}') || {}; }
function setLocalSaves(s){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(s)); }catch(e){} }

/* single save function (no duplicate name) */
async function saveSlot(slotName){
  const name = slotName || ('save-'+new Date().toISOString().slice(0,19).replace(/[:T]/g,'-'));
  const saves = getLocalSaves(); saves[name] = { state: JSON.parse(JSON.stringify(gameState)), ts: Date.now() }; setLocalSaves(saves);
  // upload to RTDB under players/{playerId}/saves/{name}
  try {
    if(gameState.playerId) await set(ref(db, `players/${gameState.playerId}/saves/${name}`), saves[name]);
    toast('Saved: ' + name);
  } catch(e) { toast('Saved locally (upload failed)'); }
}

/* load */
async function loadSlot(name){
  const saves = getLocalSaves();
  if(saves[name]){ gameState = JSON.parse(JSON.stringify(saves[name].state)); postLoadRestore(); toast('Loaded: '+name); return; }
  // try server
  try {
    if(gameState.playerId){
      const snap = await get(ref(db, `players/${gameState.playerId}/saves/${name}`));
      if(snap.exists()){ const payload = snap.val(); gameState = JSON.parse(JSON.stringify(payload.state)); postLoadRestore(); toast('Loaded from server: '+name); return; }
    }
  } catch(e){}
  toast('Save not found: '+name);
}
function postLoadRestore(){ generateItems(); gameState.inventory = gameState.inventory || {}; updateAllUI(); }

/* quickSave */
function quickSave(){
  try{
    const saves=getLocalSaves(); const key='quick_'+gameState.playerId;
    saves[key]={ state: JSON.parse(JSON.stringify(gameState)), ts: Date.now() }; setLocalSaves(saves);
    if(gameState.playerId) set(ref(db, `players/${gameState.playerId}/saves/${key}`), saves[key]).catch(()=>{});
  }catch(e){}
}

/* ---------- Export / Import ---------- */
function exportSaveFile(){
  const payload = { savedAt: Date.now(), playerId: gameState.playerId, state: gameState };
  const data = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(payload, null, 2));
  const a=document.createElement('a'); a.href=data; a.download=`idle-shop-${gameState.playerId||'anon'}-${new Date().toISOString().slice(0,19)}.json`; document.body.appendChild(a); a.click(); a.remove();
  toast('Export started');
}
function importSaveFile(file){
  if(!file){ toast('No file'); return; }
  const r=new FileReader();
  r.onload = (e)=>{
    try{
      const p = JSON.parse(e.target.result);
      if(!p || !p.state){ toast('Invalid file'); return; }
      gameState = p.state; postLoadRestore();
      // mirror into local and server quick slot
      const saves = getLocalSaves(); const key = 'import_'+(p.playerId||'import')+'_'+Date.now(); saves[key]={ state: JSON.parse(JSON.stringify(gameState)), ts:Date.now() }; setLocalSaves(saves);
      if(gameState.playerId) set(ref(db, `players/${gameState.playerId}/saves/${key}`), saves[key]).catch(()=>{});
      toast('Imported');
    }catch(e){ console.warn(e); toast('Failed import'); }
  };
  r.readAsText(file);
}

/* ---------- players list & presence ---------- */
/* write presence + onDisconnect cleanup */
async function writePresence(){
  if(!gameState.playerId) return;
  try{
    const pRef = ref(db, `players/${gameState.playerId}/presence`);
    await set(pRef, { lastSeen: Date.now(), playerId: gameState.playerId });
    // register onDisconnect to clear presence (best-effort)
    try { await onDisconnect(pRef).remove(); } catch(e) { /* if onDisconnect not supported in this context it will fail; it's optional */ }
  }catch(e){ console.warn('presence write failed', e); }
}

/* render players panel live */
function renderPlayersPanel(allPlayers){
  const panel = document.getElementById('playersPanel'); panel.innerHTML = '';
  const rows = [];
  Object.keys(allPlayers || {}).forEach(pid=>{
    if(pid === gameState.playerId) return;
    const p = allPlayers[pid];
    const pres = p.presence || {};
    const last = pres.lastSeen || 0; const online = (Date.now() - last) < 60_000;
    rows.push({ pid, online, meta: p.meta || {} });
  });
  if(rows.length === 0){ panel.innerHTML = '<div class="small" style="text-align:center;color:#666">No players found</div>'; return; }
  rows.sort((a,b)=> (b.online?1:0) - (a.online?1:0));
  rows.forEach(r=>{
    const div = document.createElement('div'); div.className='player-row';
    const left = document.createElement('div'); left.style.display='flex'; left.style.alignItems='center';
    const dot = document.createElement('span'); dot.className = 'status-dot ' + (r.online ? 'status-online' : 'status-off'); left.appendChild(dot);
    const name = document.createElement('div'); name.innerHTML = `<strong style="margin-left:8px">${r.pid}</strong><div class="small" style="color:#666">${r.online ? 'Online' : 'Offline'}</div>`; left.appendChild(name);
    const right = document.createElement('div');
    const inviteBtn = document.createElement('button'); inviteBtn.className='btn primary'; inviteBtn.textContent='Invite';
    inviteBtn.onclick = () => invitePlayer(r.pid);
    const joinBtn = document.createElement('button'); joinBtn.className='btn ghost'; joinBtn.textContent='Join Room';
    joinBtn.onclick = () => tryJoinPlayerRoom(r.pid);
    right.appendChild(inviteBtn); right.appendChild(joinBtn); right.style.display='flex'; right.style.gap='6px';
    div.appendChild(left); div.appendChild(right);
    panel.appendChild(div);
  });
}

/* listen / refresh players */
onValue(ref(db, 'players'), snapshot => {
  const all = snapshot.val() || {};
  renderPlayersPanel(all);
});

/* invite: create a room and write invite under players/{pid}/invites/{roomId} */
async function invitePlayer(pid){
  if(!gameState.playerId) { toast('Player id missing'); return; }
  const rid = Math.random().toString(36).slice(2,10);
  try{
    await set(ref(db, `rooms/${rid}`), { createdAt: Date.now(), host: gameState.playerId });
    await set(ref(db, `players/${pid}/invites/${rid}`), { from: gameState.playerId, room: rid, ts: Date.now() });
    toast('Invite sent to ' + pid);
    // optionally open room for host
    showRoomCreatedModal(rid);
  }catch(e){ console.warn(e); toast('Invite failed'); }
}

/* try to join a player's room (search for room with host=pid and open offer present) */
async function tryJoinPlayerRoom(pid){
  try{
    const roomsSnap = await get(ref(db, 'rooms')); if(!roomsSnap.exists()){ toast('No active rooms'); return; }
    const rooms = roomsSnap.val();
    for(const rid in rooms){
      if(rooms[rid].host === pid){
        // open join modal to confirm
        const content = `<h3>Join Room</h3><div style="margin-top:8px">Join room <strong>${rid}</strong> hosted by ${pid}?</div><div style="text-align:right;margin-top:10px"><button class="btn ghost" data-close>Cancel</button><button id="confirmJoin" class="btn primary">Join</button></div>`;
        const m = showModal(content);
        m.box.querySelector('#confirmJoin').addEventListener('click', async ()=> {
          m.close();
          await joinRoomById(rid);
        });
        return;
      }
    }
    toast('No room found for that player');
  }catch(e){ console.warn(e); toast('Failed to query rooms'); }
}

/* show room created modal */
function showRoomCreatedModal(rid){
  showModal(`<h3>Room Created</h3><div style="margin-top:8px"><div class="small" style="color:#666">Share this room ID:</div><div style="margin-top:8px;padding:8px;border-radius:8px;background:#f7fafc;border:1px solid #e2e8f0;text-align:center;font-weight:bold">${rid}</div></div><div style="text-align:right;margin-top:10px"><button class="btn ghost" data-close>Close</button></div>`);
}

/* ---------- minimal WebRTC + datachannel game sync ---------- */
let pc = null, dataChannel = null, roomIdActive = null;

/* create peer connection and wire ICE <-> db candidates */
function createPeerConnection() {
  const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
  const conn = new RTCPeerConnection(configuration);
  conn.onicecandidate = (e) => {
    if(e.candidate && roomIdActive) {
      push(ref(db, `rooms/${roomIdActive}/candidates/${gameState.playerId}`), e.candidate.toJSON()).catch(()=>{});
    }
  };
  conn.ondatachannel = (ev) => {
    dataChannel = ev.channel;
    setupDataChannelHandlers();
  };
  conn.onconnectionstatechange = () => {
    if(conn.connectionState === 'connected') toast('Peer connected');
    if(conn.connectionState === 'disconnected' || conn.connectionState === 'failed') toast('Peer disconnected');
  };
  pc = conn; return conn;
}
function setupDataChannelHandlers(){
  if(!dataChannel) return;
  dataChannel.onopen = ()=> { console.log('DC open'); /* send initial state */ sendGameStateSnapshot(); };
  dataChannel.onmessage = (ev) => {
    try{
      const msg = JSON.parse(ev.data);
      if(msg.type === 'syncState') {
        // Apply received snapshot carefully (only allowed fields)
        const s = msg.state;
        if(s && typeof s === 'object') {
          // Only apply safe keys, avoid full overwrite of player data
          gameState.money = s.money || gameState.money;
          gameState.customersServed = s.customersServed || gameState.customersServed;
          gameState.shopLevel = s.shopLevel || gameState.shopLevel;
          // merge inventory small amounts (for demonstration we accept numbers)
          if(s.inventory) {
            Object.keys(s.inventory).slice(0,20).forEach(k => { gameState.inventory[k] = s.inventory[k]; });
          }
          updateAllUI();
        }
      } else if(msg.type === 'requestSync') {
        sendGameStateSnapshot();
      }
    }catch(e){ console.warn('dc msg parse', e); }
  };
}
function sendGameStateSnapshot(){
  if(!dataChannel || dataChannel.readyState !== 'open') return;
  // send compact snapshot (limit inventory keys to avoid huge payloads)
  const invKeys = Object.keys(gameState.inventory).slice(0,12);
  const inv = {}; invKeys.forEach(k => inv[k] = gameState.inventory[k]);
  const payload = { type:'syncState', state:{ money:gameState.money, customersServed:gameState.customersServed, shopLevel:gameState.shopLevel, inventory:inv } };
  dataChannel.send(JSON.stringify(payload));
}

/* host: create offer and write to rooms/{rid}/offer */
async function hostRoom(rid){
  roomIdActive = rid;
  createPeerConnection();
  // create data channel as host
  dataChannel = pc.createDataChannel('game');
  setupDataChannelHandlers();
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  await set(ref(db, `rooms/${rid}/offer`), { sdp: offer.sdp, type: offer.type, from: gameState.playerId, createdAt: Date.now() });
  // listen for answer
  onValue(ref(db, `rooms/${rid}/answer`), async snap => {
    const val = snap.val(); if(!val || !val.sdp) return;
    await pc.setRemoteDescription({ type: val.type, sdp: val.sdp }).catch(()=>{});
  });
  // listen candidates posted by remote
  onChildAdded(ref(db, `rooms/${rid}/candidates`), snap => {
    const obj = snap.val(); // object keyed by playerId keys; flatten
    if(!obj) return;
    Object.values(obj).forEach(async candidate => { try{ await pc.addIceCandidate(candidate); }catch(e){} });
  });
}

/* joiner: read offer, create answer */
async function joinRoomById(rid){
  roomIdActive = rid;
  createPeerConnection();
  // fetch offer
  const offerSnap = await get(ref(db, `rooms/${rid}/offer`));
  if(!offerSnap.exists()){ toast('No offer in room ' + rid); return; }
  const offer = offerSnap.val();
  await pc.setRemoteDescription({ type: offer.type, sdp: offer.sdp }).catch(()=>{});
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);
  await set(ref(db, `rooms/${rid}/answer`), { sdp: answer.sdp, type: answer.type, from: gameState.playerId, answeredAt: Date.now() });
  // listen for candidates
  onChildAdded(ref(db, `rooms/${rid}/candidates`), snap => {
    const obj = snap.val(); if(!obj) return;
    Object.values(obj).forEach(async candidate => { try{ await pc.addIceCandidate(candidate); } catch(e){} });
  });
}

/* ---------- listeners for invites (others invite you) ---------- */
onValue(ref(db, `players`), snapshot => {
  // we handled rendering players list elsewhere; keep cheap
});

/* if an invite appears for me, show modal to accept */
onValue(ref(db, `players`), snapshot => {
  const players = snapshot.val() || {};
  const me = players[gameState.playerId] || {};
  const invites = (me.invites) || {};
  const keys = Object.keys(invites);
  if(keys.length > 0) {
    // take first invite
    const id = keys[0]; const inv = invites[id];
    if(inv && inv.room) {
      const content = `<h3>Invite</h3><div style="margin-top:8px">Player <strong>${inv.from}</strong> invited you to room <strong>${inv.room}</strong></div><div style="text-align:right;margin-top:10px"><button class="btn ghost" data-close>Ignore</button><button id="acceptInvite" class="btn primary">Join</button></div>`;
      const m = showModal(content, { onClose(){} });
      m.box.querySelector('#acceptInvite').addEventListener('click', async ()=>{
        m.close();
        // remove invite and join
        await remove(ref(db, `players/${gameState.playerId}/invites/${id}`)).catch(()=>{});
        await joinRoomById(inv.room);
      });
    }
  }
});

/* ---------- UI wiring ---------- */
document.getElementById('btnSingle').addEventListener('click', () => startSinglePlayer());
document.getElementById('btnFriends').addEventListener('click', openFriendsDialog);
document.getElementById('btnRecent').addEventListener('click', openRecentDialog);
document.getElementById('btnGlobal').addEventListener('click', () => {
  // create / join modal
  const content = `<h3>Rooms</h3><div style="margin-top:8px"><button id="createRoomBtn" class="btn primary">Create Room</button><button id="joinRoomBtn" class="btn ghost" style="margin-left:8px">Join by ID</button></div><div style="text-align:right;margin-top:10px"><button class="btn ghost" data-close>Close</button></div>`;
  const m = showModal(content);
  m.box.querySelector('#createRoomBtn').addEventListener('click', async ()=>{
    m.close();
    const rid = Math.random().toString(36).slice(2,10);
    await set(ref(db, `rooms/${rid}`), { createdAt: Date.now(), host: gameState.playerId });
    hostRoom(rid); showRoomCreatedModal(rid);
  });
  m.box.querySelector('#joinRoomBtn').addEventListener('click', ()=> {
    m.close(); joinRoomPrompt();
  });
});
document.getElementById('btnLAN').addEventListener('click', ()=> {
  const rid = Math.random().toString(36).slice(2,10); showRoomCreatedModal(rid); hostRoom(rid);
});
document.getElementById('btnRandom').addEventListener('click', async ()=>{
  // try to find room with offer and no answer; else create
  try{
    const roomsSnap = await get(ref(db, 'rooms'));
    if(roomsSnap.exists()){
      const rooms = roomsSnap.val();
      for(const rid in rooms){
        const ansSnap = await get(ref(db, `rooms/${rid}/answer`));
        if(!ansSnap.exists()){
          // join this
          await joinRoomById(rid); toast('Random matched to ' + rid); return;
        }
      }
    }
    // none found -> create and host
    const newId = Math.random().toString(36).slice(2,10);
    await set(ref(db, `rooms/${newId}`), { createdAt: Date.now(), host: gameState.playerId });
    hostRoom(newId); showRoomCreatedModal(newId);
  }catch(e){ console.warn(e); toast('Random match failed'); }
});

document.getElementById('copyPlayerCode').addEventListener('click', () => {
  const code = gameState.playerId || '';
  if(!code) { toast('Not ready'); return; }
  navigator.clipboard?.writeText(code).then(()=>toast('Copied')).catch(()=>toast('Copy failed'));
});

document.getElementById('saveBtn').addEventListener('click', ()=> saveSlot());
document.getElementById('savesBtn').addEventListener('click', ()=> openSavesDialog());
document.getElementById('exportBtn').addEventListener('click', ()=> exportSaveFile());
document.getElementById('importBtn').addEventListener('click', ()=> document.getElementById('importFile').click());
document.getElementById('importFile').addEventListener('change', (e)=> { const f=e.target.files && e.target.files[0]; importSaveFile(f); e.target.value=''; });
document.getElementById('backBtn').addEventListener('click', ()=> { document.getElementById('gameScreen').style.display='none'; document.getElementById('mainMenu').style.display='block'; });

/* friends/recent dialogs */
function openFriendsDialog(){
  const content = `<h3>Friends</h3><div style="margin-top:8px"><input id="friendInput" class="input" placeholder="Enter player code to add"/></div><div style="display:flex;gap:8px;margin-top:8px"><button id="addFriendBtn" class="btn primary">Add</button><button class="btn ghost" data-close>Close</button></div><div style="margin-top:10px"><h4>Your friends</h4><div style="max-height:160px;overflow:auto">${gameState.friends.map(f=>`<div style="padding:6px 0">${f}</div>`).join('') || '<div class="small" style="color:#666">No friends</div>'}</div></div>`;
  const m = showModal(content);
  m.box.querySelector('#addFriendBtn').addEventListener('click', ()=> {
    const v = m.box.querySelector('#friendInput').value.trim(); if(!v){ toast('Enter code'); return; } addFriendId(v); m.close(); toast('Friend added');
  });
}
function openRecentDialog(){
  showModal(`<h3>Recent</h3><div style="max-height:240px;overflow:auto;margin-top:8px">${gameState.recentOpponents.map(r=>`<div style="padding:6px 0">${r}</div>`).join('') || '<div class="small" style="color:#666">No recents</div>'}</div><div style="text-align:right;margin-top:10px"><button class="btn ghost" data-close>Close</button></div>`);
}

/* saves dialog */
function openSavesDialog(){
  const saves = getLocalSaves(); const keys = Object.keys(saves);
  const html = `<h3>Saves</h3><div style="max-height:260px;overflow:auto;margin-top:8px">${keys.map(k=>`<div style="display:flex;gap:8px;align-items:center;margin:6px 0"><div style="flex:1"><strong>${k}</strong><div class="small" style="color:#666">${new Date(saves[k].ts).toLocaleString()}</div></div><div style="display:flex;gap:6px"><button class="btn primary" data-load="${k}">Load</button><button class="btn ghost" data-del="${k}">Delete</button></div></div>`).join('') || '<div class="small" style="color:#666">No saves</div>'}</div><div style="text-align:right;margin-top:10px"><button class="btn ghost" data-close>Close</button></div>`;
  const m = showModal(html);
  m.box.querySelectorAll('[data-load]').forEach(b=>b.addEventListener('click', ()=> { const k=b.getAttribute('data-load'); m.close(); loadSlot(k); }));
  m.box.querySelectorAll('[data-del]').forEach(b=>b.addEventListener('click', ()=> { const k=b.getAttribute('data-del'); const s=getLocalSaves(); delete s[k]; setLocalSaves(s); toast('Deleted '+k); m.close(); }));
}

/* ---------- utility: joinRoom prompt ---------- */
function joinRoomPrompt(){
  const nm = 'joinRoomInput_'+Math.random().toString(36).slice(2,6);
  const html = `<h3>Join Room</h3><div style="margin-top:8px"><input id="${nm}" class="input" placeholder="Enter room id"/></div><div style="text-align:right;margin-top:10px"><button class="btn ghost" data-close>Cancel</button><button id="doJoin" class="btn primary">Join</button></div>`;
  const m = showModal(html);
  m.box.querySelector('#doJoin').addEventListener('click', async ()=>{ const rid = m.box.querySelector('#'+nm).value.trim(); if(!rid){ toast('Enter room id'); return; } m.close(); await joinRoomById(rid); });
}

/* ---------- initialization: auth, id, items, presence ---------- */
signInAnonymously(auth).catch(err => { console.warn('anon sign-in failed', err); toast('Anonymous sign-in failed (check Firebase config)'); });

onAuthStateChanged(auth, (user)=>{
  if(user){
    // prefer persisted local META playerId if exists (so user keeps same id across sessions on same browser)
    const savedMeta = safeParse(localStorage.getItem(META_KEY), {});
    if(savedMeta && savedMeta.playerId) gameState.playerId = savedMeta.playerId;
    else gameState.playerId = 'p-'+user.uid;
    // persist meta
    localStorage.setItem(META_KEY, JSON.stringify({ playerId: gameState.playerId, friends: gameState.friends, recent: gameState.recentOpponents }));
    // presence & meta push
    writePresence();
    set(ref(db, `players/${gameState.playerId}/meta`), { friends: gameState.friends, lastSeen: Date.now() }).catch(()=>{});
    updateAllUI();
  } else {
    // not signed in yet
  }
});

// read local meta if present
try{
  const meta = safeParse(localStorage.getItem(META_KEY), {});
  if(meta && meta.playerId) gameState.playerId = meta.playerId;
  gameState.friends = meta.friends || gameState.friends;
  gameState.recentOpponents = meta.recent || gameState.recentOpponents;
}catch(e){}

/* ensure id */
if(!gameState.playerId) { gameState.playerId = generateId(); localStorage.setItem(META_KEY, JSON.stringify({ playerId: gameState.playerId, friends: gameState.friends, recent: gameState.recentOpponents })); }

generateItems(); updateAllUI();
setInterval(()=> { quickSave(); writePresence(); }, 15000);

/* ---------- helper friend functions ---------- */
function addFriendId(id){ if(!id) return; gameState.friends.unshift(id); gameState.friends = [...new Set(gameState.friends)].slice(0,50); localStorage.setItem(META_KEY, JSON.stringify({ playerId: gameState.playerId, friends: gameState.friends, recent: gameState.recentOpponents })); set(ref(db, `players/${gameState.playerId}/meta`), { friends: gameState.friends, lastSeen: Date.now() }).catch(()=>{}); }

/* ---------- listen players list (live) ---------- */
onValue(ref(db, 'players'), snapshot => {
  const all = snapshot.val() || {};
  renderPlayersPanel(all);
});

/* ---------- ensure player meta and presence are created in DB for discovery ---------- */
async function ensurePlayerNode(){
  if(!gameState.playerId) return;
  try{
    // set meta node if missing
    await set(ref(db, `players/${gameState.playerId}/meta`), { friends: gameState.friends, lastSeen: Date.now() });
    // presence
    await set(ref(db, `players/${gameState.playerId}/presence`), { lastSeen: Date.now(), playerId: gameState.playerId });
    try{ await onDisconnect(ref(db, `players/${gameState.playerId}/presence`)).remove(); }catch(e){}
  }catch(e){ console.warn(e); }
}
ensurePlayerNode();

/* ---------- final notes: expose simple debug ---------- */
window.gameState = gameState;
window.saveSlot = saveSlot;
window.loadSlot = loadSlot;
window.exportSaveFile = exportSaveFile;

</script>
</body>
</html>
